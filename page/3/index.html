<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-计算机考研机试指南（七）——二叉树和二叉排序树" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（七）——二叉树和二叉排序树/">计算机考研机试指南（七）——二叉树和二叉排序树</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（七）——二叉树和二叉排序树/" class="article-date">
  <time datetime="2018-08-20T17:44:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试指南-cha-3-二叉树"><a href="#机试指南-cha-3-二叉树" class="headerlink" title="机试指南 cha 3 二叉树"></a>机试指南 cha 3 二叉树</h3><h4 id="已知前序和中序求后序遍历"><a href="#已知前序和中序求后序遍历" class="headerlink" title="已知前序和中序求后序遍历"></a>已知前序和中序求后序遍历</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;queue&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;math.h&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;stdlib.h&gt;
10 #include &lt;stack&gt;
11 using namespace std;
12 
13 char s1[100],s2[100];
14 // 前序中序求后序代码
15 typedef struct BiNode
16 {
17     struct BiNode *lchild,*rchild;
18     char data;
19 }BiNode,*BiTree;
20 
21 
22 void postOrder(BiTree t)
23 {
24     if (t)
25     {
26         postOrder(t-&gt;lchild);
27         postOrder(t-&gt;rchild);
28         cout &lt;&lt; t-&gt;data;
29     }
30 }
31 
32 BiTree buildTree(int b1,int e1,int b2,int e2)
33 {
34     // 对 b1 - e1前序 和 b2 - e2中序进行操作
35     // 每次仅能判断一个根节点，然后递归判断
36     BiTree root = (BiTree)malloc(sizeof(BiNode));
37     root-&gt;lchild = NULL;
38     root-&gt;rchild = NULL;
39     root-&gt;data = s1[b1];
40     int rootIndex;
41     for (int i = b2;i&lt;=e2;i++)
42     { // 找到中序遍历中根节点的位置
43         if (s2[i] == s1[b1])
44         {
45             rootIndex  = i;
46             break;
47         }
48     }
49     if (rootIndex != b2)
50     {
51         // 左子树不为空
52         root-&gt;lchild = buildTree(b1+1,b1+rootIndex-b2,b2,rootIndex-1);
53     }
54     if (rootIndex != e2)
55     {
56         // 右子树不为空
57         root-&gt;rchild = buildTree(b1+rootIndex-b2+1,e1,rootIndex+1,e2);
58     }
59     return root;
60 }
61 int main()
62 {
63 
64     while (cin &gt;&gt; s1 &gt;&gt; s2)
65     {
66     int len1 = strlen(s1); // 从开始地址到\0符号为止的长度
67     int len2 = strlen(s2);
68     BiTree t = buildTree(0,len1-1,0,len2-1);
69     postOrder(t);
70     cout &lt;&lt; endl;
71     }
72 
73     return 0;
74 }
</code></pre><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;queue&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;math.h&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;stdlib.h&gt;
10 #include &lt;stack&gt;
11 using namespace std;
12 
13 // 二叉树 完全二叉树 用顺序存储好一些
14 
15 int count1(int m,int n,int &amp;sum)
16 {
17     if ( m &lt;= n)
18     {
19       sum ++;
20       count1(2*m,n,sum);
21     }
22 
23     if (m+1 &lt;= n )
24     {
25        sum ++;
26        count1(2*m+1,n,sum);
27     }
28     return sum;
29 
30 }
31 int main()
32 {
33     int m,n;
34     while (scanf(&quot;%d %d&quot;,&amp;m,&amp;n)!=EOF)
35     {
36 
37         int sum = 1;
38         cout &lt;&lt; count1(2*m,n,sum)&lt;&lt; endl;
39 
40     }
41 
42     return 0;
43 }
</code></pre><h4 id="树查找"><a href="#树查找" class="headerlink" title="树查找"></a>树查找</h4><p>在顺序存储单元中查找某层元素，通过完全二叉树的两条性质，找到本层的第一个数和最后一个数打印输出即可。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;queue&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;math.h&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;stdlib.h&gt;
10 #include &lt;stack&gt;
11 using namespace std;
12 
13 const int N = 1000;
14 
15 int main()
16 {
17     int tree[N], n, d;
18     while (scanf(&quot;%d&quot;, &amp;n) != EOF)
19     {
20         for (int i = 0; i &lt; n; i++)
21         {
22             scanf(&quot;%d&quot;, &amp;tree[i]);
23         }
24         scanf(&quot;%d&quot;, &amp;d);
25         int start = (int)pow(2, d - 1); // 此层第一个数
26         if (start &gt; n)
27         {
28             printf(&quot;EMPTY\n&quot;);
29         }
30         else
31         {
32             int end = pow(2, d) - 1 &gt; n ? n : (int)pow(2, d) - 1;
33             for (int i = start - 1; i &lt; end - 1; i++)
34             {
35                 printf(&quot;%d &quot;, tree[i]);
36             }
37             printf(&quot;%d\n&quot;, tree[end - 1]);
38         }
39     }
40     return 0;
41 }
</code></pre><h3 id="机试指南-cha-3-二叉排序树"><a href="#机试指南-cha-3-二叉排序树" class="headerlink" title="机试指南 cha 3 二叉排序树"></a>机试指南 cha 3 二叉排序树</h3><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;queue&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;math.h&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;stdlib.h&gt;
10 #include &lt;stack&gt;
11 using namespace std;
12 // 二叉排序树 +前中后序遍历
13 
14 typedef struct BiNode
15 {
16     struct BiNode *lchild,*rchild;
17     int data;
18 }BiNode,*BiTree;
19 
20 void postOrder(BiTree t)
21 {
22     if (t)
23     {
24         postOrder(t-&gt;lchild);
25         postOrder(t-&gt;rchild);
26         cout &lt;&lt; t-&gt;data &lt;&lt;&#39; &#39;;
27     }
28 }
29 
30 void InOrder(BiTree t)
31 {
32     if (t)
33     {
34         InOrder(t-&gt;lchild);
35         cout &lt;&lt; t-&gt;data &lt;&lt;&#39; &#39;;
36         InOrder(t-&gt;rchild);
37     }
38 }
39 
40 void preOrder(BiTree t)
41 {
42     if (t)
43     {
44         cout &lt;&lt; t-&gt;data &lt;&lt;&#39; &#39;;
45         preOrder(t-&gt;lchild);
46         preOrder(t-&gt;rchild);
47 
48     }
49 }
50 
51 void insertBiTree(BiTree &amp;t,BiTree &amp;p)
52 {
53     if (t == NULL)
54     {
55         t = p;
56     }else
57     {
58        if (p-&gt;data &lt; t-&gt;data)
59         insertBiTree(t-&gt;lchild,p);
60        if (p-&gt;data &gt; t-&gt;data)
61         insertBiTree(t-&gt;rchild,p);
62     }
63 }
64 
65 int main()
66 {
67     BiTree t = NULL;
68     int n;
69     int x;
70     BiTree p;
71     while (cin &gt;&gt; n )
72     {
73         t = NULL;
74     for (int i = 0;i&lt;n;i++)
75     {
76         cin &gt;&gt; x;
77         p = (BiTree)malloc(sizeof(BiNode));
78         p-&gt;lchild = NULL;
79         p-&gt;rchild = NULL;
80         p-&gt;data = x;
81 
82         insertBiTree(t,p);
83     }
84     preOrder(t);cout &lt;&lt; endl;
85     InOrder(t);cout &lt;&lt; endl;
86     postOrder(t);cout &lt;&lt;endl;
87     }
88     return 0;
89 }
</code></pre><h4 id="二叉搜索树（没调过）"><a href="#二叉搜索树（没调过）" class="headerlink" title="二叉搜索树（没调过）"></a>二叉搜索树（没调过）</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;queue&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;math.h&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;stdlib.h&gt;
10 #include &lt;stack&gt;
11 using namespace std;
12 // 二叉搜索树 如何判断两个二叉搜索树相同？
13 // 就二叉排序树而言，相同元素的二叉排序树中序遍历一定相同，而不同元素二叉排序树
14 //使用前序遍历便可发现不同。
15 
16 typedef struct BiNode
17 {
18     struct BiNode *lchild,*rchild;
19     char data;
20 }BiNode,*BiTree;
21 
22 void preOrder(BiTree t,char pre[11],int &amp;i)
23 {
24     if (t)
25     {
26         pre[i++] = t-&gt;data;
27         preOrder(t-&gt;lchild,pre,i);
28         preOrder(t-&gt;rchild,pre,i);
29 
30     }
31 }
32 void insertBiTree(BiTree &amp;t,BiTree &amp;p)
33 {
34     if (t == NULL)
35     {
36         t = p;
37     }else
38     {
39        if (p-&gt;data &lt; t-&gt;data)
40         insertBiTree(t-&gt;lchild,p);
41        if (p-&gt;data &gt; t-&gt;data)
42         insertBiTree(t-&gt;rchild,p);
43     }
44 }
45 void createBiTree(BiTree &amp;t)
46 {
47     char x[11];
48     t = NULL;
49     cin &gt;&gt; x;
50     BiTree p;
51     for (int i = 0;i&lt;strlen(x);i++)
52     {
53         p = (BiTree)malloc(sizeof(BiNode));
54         p-&gt;lchild = NULL;
55         p-&gt;rchild = NULL;
56         p-&gt;data = x[i];
57         insertBiTree(t,p);
58     }
59 }
60 int main()
61 {
62     BiTree t,t2;
63     int n;
64     char pre[21];
65     char pre2[21];
66     while (cin &gt;&gt; n )
67     {
68         if (n == 0)
69             break;
70         int pre_i = 0;
71         int pre2_i = 0;
72         createBiTree(t); // 原始的树
73         preOrder(t,pre,pre_i);
74         pre[pre_i] = &#39;\0&#39;;
75         cout &lt;&lt; pre &lt;&lt; endl;
76         for (int i = 0;i&lt;n;i++)
77         {
78             pre2_i = 0;
79             createBiTree(t2); // 新建一个树
80             preOrder(t,pre2,pre2_i);
81             pre2[pre2_i] = &#39;\0&#39;;
82             cout &lt;&lt; pre2 &lt;&lt; endl;
83             if (strcmp(pre,pre2) == 0)
84                 cout &lt;&lt; &quot;YES&quot; &lt;&lt;endl;
85             else
86                 cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
87         }
88     }
89     return 0;
90 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（六）——哈夫曼树" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（六）——哈夫曼树/">计算机考研机试指南（六）——哈夫曼树</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（六）——哈夫曼树/" class="article-date">
  <time datetime="2018-08-20T17:42:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试指南-cha3-哈夫曼"><a href="#机试指南-cha3-哈夫曼" class="headerlink" title="机试指南 cha3 哈夫曼"></a>机试指南 cha3 哈夫曼</h3><h4 id="自己写了一版代码-数据结构书上的标准代码"><a href="#自己写了一版代码-数据结构书上的标准代码" class="headerlink" title="自己写了一版代码+数据结构书上的标准代码"></a>自己写了一版代码+数据结构书上的标准代码</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 
  6 
  7 using namespace std;
  8 /*
  9 1. 哈夫曼编码-顺序存储方式
 10 2. 优先队列存储----堆存储
 11 */
 12 
 13 void huffmanTree(int huffman[][5],int n)
 14 {
 15 
 16     for (int i=0;i&lt;n;i++)
 17     {
 18         huffman[i][0] = i;
 19         cin &gt;&gt; huffman[i][1];
 20         huffman[i][2] = -1;
 21         huffman[i][3] = -1;
 22         huffman[i][4] = -1;
 23     }
 24     int num1 = 0,num2 = 0;
 25     float min1 = 9999,min2 = 9999;
 26 
 27     for (int i=0;i&lt;n-1;i++)
 28     {
 29         num1 = 0;
 30         num2 = 0;
 31         min1 = 9999;
 32         min2 = 9999;
 33         for (int j=0;j&lt;n+i;j++)
 34         {
 35             // 找到一组数中未被排序（没有父节点）的的最小值和次小值，最小值优先判断，判断完最小值后判断次小值
 36             if (huffman[j][2] == -1 &amp;&amp; huffman[j][1] &lt; min1 )
 37             {
 38                     if (min1 &lt; min2)
 39                 {
 40                     min2 = min1;
 41                     num2 = num1;
 42                 }
 43                 min1 = huffman[j][1];
 44                 num1 = j;
 45             }
 46             else if (huffman[j][2] == -1 &amp;&amp; huffman[j][1] &lt; min2)
 47             {
 48                 min2 = huffman[j][1];
 49                 num2 = j;
 50             }
 51         }
 52         huffman[n+i][0] = n+i;
 53         huffman[n+i][1] = huffman[num1][1]+huffman[num2][1];
 54         huffman[n+i][2] = -1;
 55         huffman[n+i][3] = num1;
 56         huffman[n+i][4] = num2;
 57         huffman[num1][2] = n+i;
 58         huffman[num2][2] = n+i;
 59 
 60     }
 61 }
 62 void printTree(int huffman[][5],int n)
 63 {
 64     for (int i=0;i&lt;2*n-1;i++)
 65     {
 66         for (int j=0;j&lt;5;j++)
 67             cout &lt;&lt; huffman[i][j] &lt;&lt; &#39; &#39;;
 68         cout &lt;&lt; endl;
 69     }
 70 }
 71 void huffmanCode(int huffman[][5],int n)
 72 {
 73     // 自顶向下法：找到根到所有孩子的路径，每条路径均对应一个孩子
 74     // 自底向上法：遍历每个叶子结点，往上寻找直到找到根为止
 75     char code[20];
 76     int q,parent;
 77     int j = 0;
 78     for (int i=0;i&lt;n;i++)
 79     {
 80         q = i;
 81         parent = huffman[q][2];
 82         j = 0;
 83         while (parent!=-1)
 84         {
 85             if (huffman[parent][3] == q)
 86             {
 87                 // q是parent的左孩子
 88                 code[j] = &#39;0&#39;;
 89             }
 90             if (huffman[parent][4] == q)
 91             {
 92                 code[j] = &#39;1&#39;;
 93             }
 94             j++;
 95             q = parent;
 96             parent = huffman[q][2];
 97         }
 98         code[j]  = &#39;\0&#39;;
 99         cout &lt;&lt; huffman[i][1] &lt;&lt; &quot; : &quot; &lt;&lt; code &lt;&lt; endl;
100     }
101 }
102 char code[10];
103 void printPath(int huffman[][5],int n,int root,int level)
104 {
105     // 打印从根节点到所有叶子结点的路径
106     level ++;
107     if (huffman[root][3] != -1 &amp;&amp; huffman[root][4]!=-1)
108     {
109         // 如果root不为根节点时
110         code[level] = &#39;0&#39;;
111         printPath(huffman,n,huffman[root][3],level);
112         code[level] = &#39;1&#39;;
113         printPath(huffman,n,huffman[root][4],level);
114     }
115     else {
116         code[level] = &#39;\0&#39;;
117         for (int i=1;i&lt;=level;i++)
118             cout &lt;&lt; code[i];
119         cout &lt;&lt; &#39; &#39; &lt;&lt; huffman[root][1] &lt;&lt;endl;
120     }
121 
122 }
123 
124 // 课本上的代码方法，结构体数组封装一个结点而不是二维数组
125 typedef struct HuffmanNode
126 {
127     int weight;
128     int parent,lchild,rchild;
129 }HuffmanNode,**HuffmanTree;
130 
131 typedef char ** HuffmanCode ; // 动态分配数组存储哈夫曼编码表
132 
133 
134 void select_2(HuffmanTree t,int n,int &amp;s1,int &amp;s2)
135 {
136     int min1 = 9999,min2 = 9999;
137     int num1=1,num2 = 1;
138     for (int i=1;i&lt;=n;i++)
139     {
140         if (t[i]-&gt;weight &lt; min1)
141         {
142             if ( min2 &gt; min1 )
143             { // 在替换min1之前判断min1舍弃的值是不是比min2小，如果是的话min2就占着大便宜!
144                 min2 = min1;
145                 num2 = num1;
146             }
147             num1 = i;
148             min1 = t[i]-&gt;weight;
149         }else if (t[i]-&gt;weight)
150         {
151             min2 = t[i]-&gt;weight;
152             num2 = i;
153         }
154     }
155     s1 = num1;
156     s2 = num2;
157 }
158 void HuffmanCoding(HuffmanTree &amp;t,HuffmanCode &amp;c,int *w,int n)
159 {
160    if (n&lt;=1)
161     return;
162 
163    int m = 2*n-1;
164    t = (HuffmanTree)malloc(sizeof(HuffmanNode)*(m+1)); // m+1是因为0号单元未用
165    for (int i=1;i&lt;=n;i++)
166    {
167        t[i]-&gt;weight = w[i];
168        t[i]-&gt;parent = 0;
169        t[i]-&gt;lchild = 0;
170        t[i]-&gt;rchild = 0;
171    }
172    // 下面的循环可省略，因为遍历过程中一定会重新写一遍
173    for (int i=n+1;i&lt;=m;i++)
174    {
175        t[i]-&gt;weight = 0 ;
176        t[i]-&gt;parent = 0 ;
177        t[i]-&gt;lchild = 0 ;
178        t[i]-&gt;rchild = 0 ;
179    }
180     int s1,s2;
181    // 建立哈夫曼树的循环
182    for (int i = n+1;i&lt;=m;i++)
183    {
184        //找到1-i-1中的最小值和次小值
185        select_2(t,i-1,s1,s2);
186        t[s1]-&gt;parent = i;
187        t[s2]-&gt;parent = i;
188        t[i]-&gt;weight = t[s1]-&gt;weight+t[s2]-&gt;weight;
189        t[i]-&gt;lchild = s1;
190        t[i]-&gt;rchild = s2;
191    }
192 
193    // 计算哈弗曼编码值，从叶子到根逆向求
194    c = (char **)malloc(sizeof(char*)*(n+1));//n个字符的头指针向量，从1开始
195    char *cd = (char *)malloc(n*sizeof(char));// 哈弗曼树的高度不会超过n
196    cd[n-1] = &#39;\0&#39;;
197    for (int i=1;i&lt;=n;i++)
198    {
199        int start = n-1;//倒着存储编码
200        for (int c = i,f = t[i]-&gt;parent;f!=0;c=f,f = t[f]-&gt;parent)
201         if (t[f]-&gt;lchild == c)
202         cd[--start] = &#39;0&#39;;
203        else
204         cd[--start] = &#39;1&#39;;
205 
206        c[i] = (char *)malloc(sizeof(char)*(n-start));
207        strcpy(c[i],&amp;cd[start]); // 复制编码
208        /*
209         char *p = (char *)malloc(sizeof(char)*10);
210     p = &quot;helloworld&quot;;
211     cout &lt;&lt; p &lt;&lt; endl;
212     char *q = (char *)malloc(sizeof(char)*5);
213     strcpy(q,&amp;p[5]);//两个参数都是地址，从起始地址到\0终止符之间的内容复制过去
214     cout &lt;&lt; q;
215     */
216    }
217 
218    // // 无栈非递归遍历哈夫曼树，求哈夫曼编码
219 
220     c = (HuffmanCode)malloc((n+1)*sizeof(char *));
221     int p = m;
222     int cdlen = 0;
223     for (int i=1;i&lt;=m;i++)
224         t[i]-&gt;weight = 0; // 遍历哈夫曼树时用作结点状态标志
225     while (p){
226         if (t[p]-&gt;weight == 0 )
227         {
228             t[p]-&gt;weight = 1;
229             if (t[p]-&gt;lchild!=0)
230             { // 左右孩子均不为0的状况
231                 p = t[p]-&gt;lchild;
232                 cd[cdlen++] = &quot;0&quot;;
233             }
234             else if (t[p]-&gt;rchild == 0 )
235             {
236                 // 左右孩子均为0,P结点为叶节点，登记字符编码
237                 c[p] = (char *)malloc((cdlen+1)*sizeof(char));
238                 cd[cdlen] = &#39;\0&#39;;
239                 strcpy(hc[p],cd);
240             }
241         }
242         else if (t[p]-&gt;weight == 1){
243             t[p]-&gt;weight = 2;
244             if (t[p]-&gt;rchild != 0)
245             {
246                 p = t[p]-&gt;rchild;
247                 cd[cdlen++] = &#39;1&#39;;
248             }else 
249             {
250                 t[p]-&gt;weight = 0;
251                 p = t[p]-&gt;parent;
252                 --cdlen; //退回父节点，编码长度减一
253             }
254         }
255     }
256 }
257 
258 
259 int main()
260 {
261     int n;
262     cout &lt;&lt; &quot;n:&quot; &lt;&lt;endl;
263     cin &gt;&gt; n;
264 //    int huffman[2*n-1][5];
265 //    huffmanTree(huffman,n);
266 //    printTree(huffman,n);
267 //    huffmanCode(huffman,n);
268 //    int level = 0;
269 //    printPath(huffman,n,2*n-2,level);
270     HuffmanTree t;
271     HuffmanCode c;
272     int *w;
273     for (int i=0;i&lt;n;i++)
274         cin &gt;&gt; w[i];
275     HuffmanCoding(t,c,w,n);
276     return 0;
277 }
</code></pre><h4 id="机试指南的题，优先队列哈夫曼树"><a href="#机试指南的题，优先队列哈夫曼树" class="headerlink" title="机试指南的题，优先队列哈夫曼树"></a>机试指南的题，优先队列哈夫曼树</h4><p>优先队列的用法：<br>（1）priority_queue 默认设置大顶堆<br>（2）priority_queue</p>
<pre><code>struct node  
{  
    friend bool operator&lt; (node n1, node n2)  
    {  
        return n1.priority &lt; n2.priority;  
    }  
    int priority;  
    int value;  
};
</code></pre><ol>
<li>比较运算符外置</li>
</ol>
<p>运算符重载：<br>用于对对象的运算符操作</p>
<pre><code>box operator+(const box a,const box b) 
{ 
box c; 
c.weight = a.weight+b.weight; 
return c; 
}
</code></pre><p>友元函数：<br>1)C++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;<br>2)这个友元函数他不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。<br>3）友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。</p>
<p>// 输出哈夫曼树树顶元素</p>
<pre><code> 1 int main()
 2 {
 3     int n;
 4     priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
 5     while (cin &gt;&gt; n)
 6     {
 7         while (!q.empty())
 8             q.pop(); // 清空小顶堆元素
 9 
10         for (int i=1;i&lt;=n;i++)
11         {
12             int d;
13             cin &gt;&gt; d;
14             q.push(d);
15         }
16         int ans = 0;
17         while (q.size() &gt; 1 )
18         {
19             int a = q.top();
20             q.pop();
21             int b = q.top();
22             q.pop();
23             q.push(a+b);
24 
25         }
26         ans = q.top();
27         cout &lt;&lt; ans &lt;&lt; endl;
28     }
29 
30     return 0;
31 }
</code></pre><h4 id="搬水果-改版上面的代码，只需要把ans加起来"><a href="#搬水果-改版上面的代码，只需要把ans加起来" class="headerlink" title="搬水果 改版上面的代码，只需要把ans加起来"></a>搬水果 改版上面的代码，只需要把ans加起来</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;string.h&gt;
 3 #include &lt;stdio.h&gt;
 4 #include &lt;stdlib.h&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;vector&gt;
 7 
 8 using namespace std;
 9 /*
10 搬水果
11 */
12 
13 
14 int main()
15 {
16     int n;
17     priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;
18     while (cin &gt;&gt; n)
19     {
20         while (!q.empty())
21             q.pop(); // 清空小顶堆元素
22 
23         for (int i=1;i&lt;=n;i++)
24         {
25             int d;
26             cin &gt;&gt; d;
27             q.push(d);
28         }
29         int ans = 0;
30         int sum = 0;
31         while (q.size() &gt; 1 )
32         {
33             int a = q.top();
34             q.pop();
35             int b = q.top();
36             q.pop();
37             ans = a+b;
38             q.push(ans);
39             sum += ans;
40 
41         }
42         cout &lt;&lt; sum &lt;&lt; endl;
43     }
44 
45 
46     return 0;
47 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（六） ——栈" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（六） ——栈/">计算机考研机试指南（六） ——栈</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（六） ——栈/" class="article-date">
  <time datetime="2018-08-20T17:40:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试指南-cha-3-栈的应用"><a href="#机试指南-cha-3-栈的应用" class="headerlink" title="机试指南 cha 3 栈的应用"></a>机试指南 cha 3 栈的应用</h3><h4 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;queue&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;math.h&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;stdlib.h&gt;
10 #include &lt;stack&gt;
11 using namespace std;
12 
13 /*
14   问题：cha 3 栈的应用 括号匹配问题
15   思路：如果直接在压栈的时候输出，则连续出现多个((((的$不能及时输出，
16   必须要等到输入串遍历结束后，站内剩余(((才能将其对应输出串位置修改为$
17 
18   2 压栈的内容是字符还是字符在字符串中的索引位置？如果是字符则无法找到并修改ans中的字符
19 */
20 
21 char ans[101];
22 void match(char c[101])
23 {
24     stack&lt;int&gt; s;
25     int i = 0;
26     while (c[i] !=&#39;\0&#39;)
27     {
28         // 如果为）且为栈底则输出？，如果为（且为栈底则输出$,如果为其他字符则不压栈输出空格
29         // 如果为左括号则压栈，右括号则判断栈顶，如果为（则弹栈
30         if (c[i] == &#39;)&#39;&amp;&amp; s.empty())
31             ans[i] = &#39;?&#39;;
32         else if (c[i] == &#39;(&#39;)
33           {
34               s.push(i);
35               ans[i] =  &#39; &#39;;
36           }
37           else if (c[i] == &#39;)&#39; &amp;&amp; c[s.top()] == &#39;(&#39;)
38           {
39               s.pop();
40               ans[i] = &#39; &#39;;
41           }
42           else
43             ans[i] =&#39; &#39;;
44     i++;
45     }
46     while (!s.empty())
47     {
48         ans[s.top()] = &#39;$&#39;;
49         s.pop();
50     }
51     ans[i] = &#39;\0&#39;;
52 }
53 int main()
54 {
55     char c[101];
56     cin &gt;&gt; c;
57     cout &lt;&lt; c &lt;&lt; endl;
58     match(c); // 输出匹配的符号
59     cout &lt;&lt; ans &lt;&lt; endl;
60 
61     return 0;
62 }
</code></pre><h4 id="表达式求值（课本）"><a href="#表达式求值（课本）" class="headerlink" title="表达式求值（课本）"></a>表达式求值（课本）</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;queue&gt;
  5 #include &lt;stack&gt;
  6 #include &lt;math.h&gt;
  7 #include &lt;string&gt;
  8 #include &lt;string.h&gt;
  9 #include &lt;stdlib.h&gt;
 10 #include &lt;stack&gt;
 11 using namespace std;
 12 
 13 /*
 14 问题 ： 简单计算器（表达式求值）
 15 
 16 */
 17 
 18 bool isNum(char c)
 19 {
 20     int num = c-&#39;0&#39;;
 21     if (num &gt;= 0 &amp;&amp; num &lt;= 9)
 22         return true;
 23     else
 24         return false;
 25 }
 26 
 27 char op[8][8] =
 28 {
 29     &#39;0&#39;,&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;(&#39;,&#39;)&#39;,&#39;#&#39;,
 30     &#39;+&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 31     &#39;-&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 32     &#39;*&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 33     &#39;/&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 34     &#39;(&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;=&#39;,&#39;&gt;&#39;,
 35     &#39;)&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;0&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 36     &#39;#&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;0&#39;,&#39;=&#39;,
 37 };
 38 char compare(char a,char b)
 39 {
 40     int x,y;
 41     for (int i = 1;i &lt; 8;i++)
 42         if (op[i][0] == a)
 43         x = i;
 44     for (int i = 1;i &lt; 8;i++)
 45         if (op[0][i] == b)
 46         y = i;
 47     return op[x][y];
 48 }
 49 int cal(int a,char op,int b)
 50 {
 51     switch (op)
 52     {
 53         case &#39;+&#39;:return a+b;break;
 54         case &#39;-&#39;:return b-a;break;
 55         case &#39;*&#39;:return a*b;break;
 56         case &#39;/&#39;:return b/a;
 57     }
 58 }
 59 int main()
 60 {
 61     char c[201];
 62     stack&lt;char&gt; oper;
 63     stack&lt;int&gt; number;
 64     oper.push(&#39;#&#39;);
 65     while (cin&gt;&gt;c)
 66     {
 67         if (c[0] ==&#39;0&#39;)
 68             break;
 69         int i = 0;
 70         while (c[i] != &#39;#&#39; || oper.top()!= &#39;#&#39;)
 71         {
 72             if (isNum(c[i]))
 73             {
 74                 number.push(c[i]-&#39;0&#39;);
 75                 i = i+1;
 76                 continue;
 77             }
 78             switch(compare(oper.top(),c[i]))
 79             {
 80             case &#39;&lt;&#39;:
 81                 // 继续压栈
 82                 oper.push(c[i]);
 83                 i = i+1;
 84                 break;
 85             case &#39;=&#39;:
 86                 // 弹栈
 87                 oper.pop();
 88                 i = i+1;
 89                 break;
 90             case &#39;&gt;&#39;:
 91                 // 栈顶为优先级高的运算符，进行计算后压栈
 92                 char oper1 = oper.top();
 93                 oper.pop();
 94                 int num1 = number.top();
 95                 number.pop();
 96                 int num2 = number.top();
 97                 number.pop();
 98                 int ans = cal(num1,oper1,num2);
 99                 number.push(ans);
100                 // 此时c[i]符号并没有压入栈中，所以不用i+2
101 
102             }
103         }
104         cout &lt;&lt; number.top()&lt;&lt;endl;
105     }
106 
107     return 0;
108 }
</code></pre><p>局限性：输入的表达式中数字不能是大于9的整数</p>
<h4 id="改进的表达式求值（计算大于9的整数）"><a href="#改进的表达式求值（计算大于9的整数）" class="headerlink" title="改进的表达式求值（计算大于9的整数）"></a>改进的表达式求值（计算大于9的整数）</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;queue&gt;
  5 #include &lt;stack&gt;
  6 #include &lt;math.h&gt;
  7 #include &lt;string&gt;
  8 #include &lt;string.h&gt;
  9 #include &lt;stdlib.h&gt;
 10 #include &lt;stack&gt;
 11 using namespace std;
 12 
 13 /*
 14 问题 ： 简单计算器（表达式求值）
 15 
 16 */
 17 
 18 bool isNum(char c[])
 19 {
 20     int num = c[0]-&#39;0&#39;;
 21     if (num &gt;= 0 &amp;&amp; num &lt;= 9)
 22         return true;
 23     else
 24         return false;
 25 }
 26 int Num(char c[])
 27 {
 28     // 计算数字的值
 29     int sum=0;
 30     int i=0;
 31     while (c[i]!=&#39;\0&#39;)
 32     {
 33         int a = c[i]-&#39;0&#39;;
 34        // cout &lt;&lt; c[i];
 35         sum = sum*10+a;
 36         i++;
 37     }
 38     return sum;
 39 }
 40 char op[8][8] =
 41 {
 42     &#39;0&#39;,&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;(&#39;,&#39;)&#39;,&#39;#&#39;,
 43     &#39;+&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 44     &#39;-&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 45     &#39;*&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 46     &#39;/&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 47     &#39;(&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;=&#39;,&#39;&gt;&#39;,
 48     &#39;)&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;0&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 49     &#39;#&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;0&#39;,&#39;=&#39;,
 50 };
 51 char compare(char a,char b)
 52 {
 53     int x,y;
 54     for (int i = 1;i &lt; 8;i++)
 55         if (op[i][0] == a)
 56         x = i;
 57     for (int i = 1;i &lt; 8;i++)
 58         if (op[0][i] == b)
 59         y = i;
 60     return op[x][y];
 61 }
 62 int cal(int a,char op,int b)
 63 {
 64     switch (op)
 65     {
 66         case &#39;+&#39;:return a+b;break;
 67         case &#39;-&#39;:return b-a;break;
 68         case &#39;*&#39;:return a*b;break;
 69         case &#39;/&#39;:return b/a;
 70     }
 71 }
 72 int main()
 73 {
 74     char c[10];
 75     stack&lt;char&gt; oper;
 76     stack&lt;int&gt; number;
 77     oper.push(&#39;#&#39;);
 78 
 79     while (cin&gt;&gt;c){// 每次仅输入一个单词，如果是运算符则c[0],数字则需要计算一下
 80     int i = 0;
 81     if (c[0] == &#39;0&#39;)
 82         break;
 83     while (c[i] != &#39;#&#39; || oper.top()!= &#39;#&#39;)
 84     {
 85         if (isNum(c))
 86         {
 87             number.push(Num(c));
 88            // cout &lt;&lt; Num(c) &lt;&lt; endl;
 89             cin &gt;&gt; c;
 90             continue;
 91         }
 92         switch(compare(oper.top(),c[i]))
 93         {
 94         case &#39;&lt;&#39;:
 95             // 继续压栈
 96             oper.push(c[i]);
 97             cin &gt;&gt; c;
 98             break;
 99         case &#39;=&#39;:
100             // 弹栈
101             oper.pop();
102             cin &gt;&gt; c;
103             break;
104         case &#39;&gt;&#39;:
105             // 栈顶为优先级高的运算符，进行计算后压栈
106             char oper1 = oper.top();
107             oper.pop();
108             int num1 = number.top();
109             number.pop();
110             int num2 = number.top();
111             number.pop();
112             int ans = cal(num1,oper1,num2);
113             number.push(ans);
114             // 此时c[i]符号并没有压入栈中，所以不用i+2
115 
116         }
117     }
118     cout &lt;&lt; number.top()&lt;&lt;endl;
119     }
120 
121     return 0;
122 }
</code></pre><p>测试用例：<br>10 + 2 * 3 - 8 / ( 3 + 1 ) #<br>0</p>
<h4 id="简单计算器-2006年浙江大学计算机及软件工程研究生机试真题"><a href="#简单计算器-2006年浙江大学计算机及软件工程研究生机试真题" class="headerlink" title="简单计算器 2006年浙江大学计算机及软件工程研究生机试真题"></a>简单计算器 2006年浙江大学计算机及软件工程研究生机试真题</h4><p>这个题第一天重新写了一下课本上的实现方法，第二天改进成可以计算大于9的的算术表达式，第三天修改成符合这道机试题格式要求的题目。</p>
<p>自己还差的很远。</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;queue&gt;
  5 #include &lt;stack&gt;
  6 #include &lt;math.h&gt;
  7 #include &lt;string&gt;
  8 #include &lt;string.h&gt;
  9 #include &lt;stdlib.h&gt;
 10 #include &lt;stack&gt;
 11 using namespace std;
 12 
 13 /*
 14 问题 ： 简单计算器（表达式求值）
 15 改进版3：输入串末尾没有#如何控制，用字符后面有没有空格来控制
 16 
 17 */
 18 
 19 bool isNum(char c[],int i)
 20 {
 21     int num = c[i]-&#39;0&#39;;
 22     if (num &gt;= 0 &amp;&amp; num &lt;= 9)
 23         return true;
 24     else
 25         return false;
 26 }
 27 int Num(char c[],int &amp;i)
 28 {
 29     // 计算数字的值
 30     int sum=0;
 31     while (c[i]!=&#39; &#39; &amp;&amp; c[i]!=&#39;\0&#39;)
 32     {
 33         int a = c[i]-&#39;0&#39;;
 34        // cout &lt;&lt; c[i];
 35         sum = sum*10+a;
 36         i++;
 37     }
 38     return sum;
 39 }
 40 char op[8][8] =
 41 {
 42     &#39;0&#39;,&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;(&#39;,&#39;)&#39;,&#39;\0&#39;,
 43     &#39;+&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 44     &#39;-&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 45     &#39;*&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 46     &#39;/&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 47     &#39;(&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;=&#39;,&#39;&gt;&#39;,
 48     &#39;)&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;0&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,
 49     &#39;\0&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;0&#39;,&#39;=&#39;,
 50 };
 51 char compare(char a,char b)
 52 {
 53     int x,y;
 54     for (int i = 1;i &lt; 8;i++)
 55         if (op[i][0] == a)
 56         x = i;
 57     for (int i = 1;i &lt; 8;i++)
 58         if (op[0][i] == b)
 59         y = i;
 60     return op[x][y];
 61 }
 62 float cal(float a,char op,float b)
 63 {
 64     switch (op)
 65     {
 66         case &#39;+&#39;:return a+b;break;
 67         case &#39;-&#39;:return b-a;break;
 68         case &#39;*&#39;:return a*b;break;
 69         case &#39;/&#39;:return b/a;
 70     }
 71     return 0;
 72 }
 73 int main()
 74 {
 75     char c[50];
 76     stack&lt;char&gt; oper;
 77     stack&lt;float&gt; number;
 78     oper.push(&#39;\0&#39;);
 79 
 80     while (cin.getline(c,1000)){// 输入一行字符
 81     int i = 0;
 82     if (c[0] == &#39;0&#39;)
 83         break;
 84     while (c[i] != &#39;\0&#39; || oper.top()!= &#39;\0&#39;)
 85     {
 86         if (isNum(c,i))
 87         {
 88             float sum = Num(c,i);
 89             number.push(sum);
 90         //    cout &lt;&lt; sum &lt;&lt; endl;
 91             if (c[i]!=&#39;\0&#39;)
 92                 i++; // i自增前指向空格或者字符串终止符
 93             continue;
 94         }
 95         switch(compare(oper.top(),c[i]))
 96         {
 97         case &#39;&lt;&#39;:
 98             // 继续压栈
 99             oper.push(c[i]);
100             i = i+1;
101             if (c[i]!=&#39;\0&#39;) i++;
102             break;
103         case &#39;=&#39;:
104             // 弹栈
105             oper.pop();
106             i = i+1;
107             if (c[i]!=&#39;\0&#39;) i++;
108             break;
109         case &#39;&gt;&#39;:
110             // 栈顶为优先级高的运算符，进行计算后压栈
111             char oper1 = oper.top();
112             oper.pop();
113             float num1 = number.top();
114             number.pop();
115             float num2 = number.top();
116             number.pop();
117             float ans = cal(num1,oper1,num2);
118             number.push(ans);
119             // 此时c[i]符号并没有压入栈中，所以不用i+2
120 
121         }
122     }
123     printf(&quot;%.2f\n&quot;,number.top());
124     }
125 
126     return 0;
127 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构（严版）课本代码重敲——第二章" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构（严版）课本代码重敲——第二章/">数据结构（严版）课本代码重敲——第二章</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构（严版）课本代码重敲——第二章/" class="article-date">
  <time datetime="2018-08-20T17:37:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="复习笔记-数据结构-第二章-线性表"><a href="#复习笔记-数据结构-第二章-线性表" class="headerlink" title="复习笔记 数据结构 第二章 线性表"></a>复习笔记 数据结构 第二章 线性表</h4><p>说明：数据结构高分笔记上的经典编程题</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #define dataSize 20
  6 #define ERROR -1
  7 using namespace std;
  8 /*
  9     题目：数据结构 cha2 线性表
 10     内容：1. 顺序表的操作
 11     日期：2018/3/9
 12     时间：tomato * 2
 13     笔记：1. 线性表包括顺序表和链表
 14     2. 顺序表是逻辑和存储结构均为线性连续的数组形式，一般用数组表示
 15     3.链表分为单链表和双链表，包括带头结点和不带头结点两种类型，也包括循环和非循环两种类型
 16     还有一种特殊的&quot;静态链表&quot;
 17 */
 18 /* 顺序表的定义方式
 19     注意：typedef的含义是给这个结构体起的名字叫做Sqlist,是一种用户自定义的数据类型
 20     而平时编程中struct student {}stu[20];则是C++中的简略写法，stu[20]即为创建的
 21     数据类型为Student的数组变量
 22 */
 23 typedef struct
 24 {
 25     int data[dataSize];
 26     int length;
 27 }Sqlist;
 28 
 29 
 30 typedef int Elemtype;
 31 
 32 
 33 /* (1)以下为顺序表的基本操作
 34     1. 初始化
 35     2. 按元素值的查找
 36     3. 求指定位置元素
 37     4. 插入元素
 38     5. 删除元素
 39     笔记：1.是否用&amp;取决于改结构体的内容
 40 */
 41 void initSqlist(Sqlist &amp;l)
 42 {
 43     l.length = 0;
 44 }
 45 int findElem(Sqlist l,Elemtype x)
 46 {
 47     for (int i=0;i&lt;l.length;i++)
 48     {
 49         if (l.data[i] == x)
 50             return i;
 51     }
 52     return ERROR;
 53 }
 54 Elemtype getElem(Sqlist l, int loc)
 55 {
 56     if (loc &lt; 0 || loc &gt; l.length-1)
 57         return ERROR;
 58     return l.data[loc];
 59 }
 60 void insertSqlist(Sqlist &amp;l,Elemtype x,int loc)
 61 {
 62     if (loc &lt; 0 || loc &gt;l.length-1)
 63         cout&lt;&lt;&quot;error&quot;;
 64     for (int i=l.length-1 ; i &gt;= loc ; i--  )
 65     {
 66         l.data[i+1] = l.data[i];
 67     }
 68     l.data[loc] = x;
 69     l.length++; // ★★★ 勿忘！
 70 }
 71 Elemtype deleteSqlist(Sqlist &amp;l,int loc,Elemtype &amp;x)
 72 {
 73     if (loc&lt;0||loc&gt;l.length-1)
 74         {cout &lt;&lt; &quot;error&quot;;return 0;}
 75     x = l.data[loc];
 76     for (int i=loc;i&lt;l.length-1;i++)
 77     {
 78         l.data[i] = l.data[i+1];
 79     }
 80     l.length -- ;
 81     return x;
 82 }
 83 // 单链表结点定义
 84 typedef int Elemtype;
 85 typedef struct LNode
 86 {
 87     Elemtype data;
 88     struct LNode *next;
 89 }LNode;
 90 
 91 /*
 92     (2)单链表的操作
 93     1. 创建单链表 尾插法和头插法
 94     2. 归并单链表 递增和递减（头插法）
 95     3. 查找单链表
 96     4. 插入单链表
 97     5. 删除
 98     6. 打印链表内容
 99     7. 查找x并删除
100 */
101 // 头插法
102 void createLNode(LNode *&amp;h,int n)
103 {
104     // 1. 创建头结点
105     h = (LNode *)malloc(sizeof(LNode));
106     h-&gt;next = NULL;
107     Elemtype x;
108     cout&lt;&lt;&quot;输入线性表数据&quot;&lt;&lt;endl;
109     LNode *q;
110     q = h;
111     for(int i=0;i&lt;n;i++)
112     {
113         cin &gt;&gt; x;
114         q = (LNode *)malloc(sizeof(LNode));
115         q-&gt;data = x;
116         q-&gt;next = h-&gt;next;
117         h-&gt;next = q;
118     }
119 
120 }
121 // 尾插法
122 void createLNodeH(LNode *&amp;h,int n)
123 {
124     h = (LNode *)malloc(sizeof(LNode));
125     h-&gt;next = NULL;
126     LNode *p,*q;
127     q = h;
128     int x;
129     cout &lt;&lt;&quot;数据：&quot;&lt;&lt;endl;
130     for (int i=0;i&lt;n;i++)
131     {
132         cin &gt;&gt; x;
133         p = (LNode *) malloc(sizeof(LNode));
134         p-&gt;data = x;
135         q-&gt;next = p;
136         q = p;
137     }
138     p-&gt;next = NULL; // 最后赋值即可
139 
140 }
141 void print(LNode *h)
142 {
143     LNode *t = h;
144     while (t-&gt;next!=NULL)
145     {
146         t = t-&gt;next;
147         cout&lt;&lt;t-&gt;data&lt;&lt;&#39; &#39;;
148     }
149     cout &lt;&lt; endl;
150 }
151 void mergeLNode(LNode *&amp;a,LNode *&amp;b,LNode *&amp;c)
152 {
153     LNode *pa,*pb,*pc;
154     pa = a-&gt;next;pb=b-&gt;next;
155     pc = (LNode *)malloc(sizeof(LNode));
156     c = pc ;
157     while (pa!=NULL &amp;&amp; pb!=NULL)
158     {
159         cout &lt;&lt;&quot;test&quot;&lt;&lt;endl;
160         if (pa-&gt;data &gt;= pb-&gt;data)
161         {
162             pc-&gt;next = pb;
163             pb = pb-&gt;next;
164             pc = pc-&gt;next;
165         }
166         else
167         {
168             pc-&gt;next = pa;
169             pa = pa-&gt;next;
170             pc = pc-&gt;next;
171         }
172     }
173     pc-&gt;next = NULL;
174     if (pa!=NULL)
175     {
176         pc-&gt;next = pa;
177     }
178     if (pb!=NULL)
179     {
180         pc-&gt;next = pb;
181     }
182 
183 }
184 void merge_2(LNode *&amp;a,LNode *&amp;b,LNode *&amp;c)
185 {
186     LNode *pa,*pb,*pc;
187     pa = a-&gt;next; pb = b-&gt;next;
188     c = (LNode *)malloc(sizeof(LNode));
189     pc = c;
190 
191     while (pa!=NULL &amp;&amp; pb!=NULL)
192     {
193         if (pa-&gt;data &gt;= pb-&gt;data)
194         {
195             pc = pb;
196             pb = pb-&gt;next;
197             pc -&gt; next = c-&gt;next;
198             c-&gt;next = pc;
199         }
200         else
201         {
202             pc = pa;
203             pa = pa-&gt;next;
204             pc -&gt; next = c-&gt;next;
205             c-&gt;next = pc;
206         }
207     }
208     while (pa!=NULL)
209     {
210         pc = pa;
211         pa = pa-&gt;next;
212         pc -&gt; next = c-&gt;next;
213         c-&gt;next = pc;
214     }
215     while (pb!=NULL)
216     {
217         pc = pb;
218         pb = pb-&gt;next;
219         pc -&gt; next = c-&gt;next;
220         c-&gt;next = pc;
221     }
222 }
223 
224 int findAndDelete(LNode *l,Elemtype x)
225 {
226     LNode *p = l,*q;
227 
228     while (p-&gt;next!=NULL)
229     {
230        if (p-&gt;next-&gt;data == x)
231        {
232            q = p-&gt;next ;
233            p-&gt;next = q-&gt;next;
234            return 1;
235        }
236        p = p-&gt;next;
237     }
238     return 0;
239 }
240 // 双链表结点定义
241 typedef struct DLNode
242 {
243     Elemtype data;
244     struct DLNode *prior;
245     struct DLNode *next;
246 }DLNode;
247 
248 /*
249     1.双链表的建立
250     2. 查找结点
251     3. 插入结点，在p之后
252 */
253 void createDLNode(DLNode *&amp;dl,int n)
254 {
255     dl = (DLNode *)malloc(sizeof(DLNode));
256     dl -&gt;prior = NULL;
257     DLNode *p,*q;
258     p = dl;
259     cout&lt;&lt;&quot;data:&quot;&lt;&lt;endl;
260     int x;
261     for (int i=0;i&lt;n;i++)
262     {
263         q = (DLNode *)malloc(sizeof(DLNode));
264         cin &gt;&gt; x;
265         q-&gt;data = x;
266         p-&gt;next = q;
267         q-&gt;prior = p;
268         p = q;
269     }
270     p-&gt;next = NULL;
271 
272 }
273 
274 int main()
275 {
276     DLNode *dl;
277     int n;
278     cout&lt;&lt;&quot;数据个数n：&quot;&lt;&lt;endl;
279     cin&gt;&gt;n;
280     createDLNode(dl,n);
281     print(dl);
282     return 0;
283 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构（严版）课本代码重敲——第三章" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构（严版）课本代码重敲——第三章/">数据结构（严版）课本代码重敲——第三章</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构（严版）课本代码重敲——第三章/" class="article-date">
  <time datetime="2018-08-20T17:37:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="复习笔记-数据结构-第三章-栈和队列"><a href="#复习笔记-数据结构-第三章-栈和队列" class="headerlink" title="复习笔记 数据结构 第三章 栈和队列"></a>复习笔记 数据结构 第三章 栈和队列</h3><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #define maxSize 20
  6 #define ERROR -1
  7 using namespace std;
  8 /*
  9     题目：数据结构 cha3  栈和队列
 10     内容：1. 顺序栈、链栈、顺序队列、链队列
 11     日期：2018/3/10
 12     时间：tomato * 
 13 
 14 */
 15 typedef struct 
 16 {
 17     Elemtype data[maxSize];
 18     int top;
 19 }Sqstack;
 20 void initStack(Sqstack *&amp;sq)
 21 {
 22     sq.top = -1;
 23 }
 24 int push_Sqstack(Sqstack *&amp;sq,Elemtype x)
 25 {
 26    if (sq.top == maxSize-1)
 27         return ERROR;
 28    sq.top++;
 29    sq.data[sq.top] = x;
 30    return 1;
 31 } 
 32 int pop_Sqstack(Sqstack *&amp;sq,Elemtype &amp;x)
 33 {
 34     if (sq.top == -1)
 35         return ERROR;
 36     x = sq.data[sq.top];
 37     sq.top--;
 38     return 1;
 39 }
 40 
 41 typedef struct LNode
 42 {
 43     Elemtype data;
 44     struct LNode *next;
 45 }LNode;
 46 // 链栈为空的标志是ls-&gt;next == NULL 
 47 // 头插法建立链栈
 48 int init_LNode(LNode *&amp;lst)
 49 {
 50     (LNode *)malloc(sizeof(LNode));
 51 }
 52 int push_LNode(LNode *&amp;lst,Elemtype x)
 53 {
 54     LNode *p = (LNode *)malloc(sizeof(LNode));
 55     p-&gt;data = x;
 56     p-&gt;next = lst-&gt;next;
 57     lst-&gt;next = p;
 58 }
 59 
 60 int pop_LNode(LNode *&amp;lst,Elemtype &amp;x)
 61 {
 62     // 头摘 出栈首先要判断是否栈空
 63     if (lst-&gt;next == NULL)
 64         return -1;
 65     x = lst-&gt;next-&gt;data;
 66     LNode *p = lst-&gt;next;
 67     lst-&gt;next = p-&gt;next;
 68     free(p);
 69     return 1;
 70 }
 71 typedef struct 
 72 {
 73     Elemtype data[maxSize];
 74     int rear;
 75     int front;
 76 }Squeue;
 77 void init_Squeue(Squeue *&amp;sq)
 78 {
 79     sq-&gt;rear = sq-&gt;front = 0; // front = rear时为空队列
 80 }
 81 int enqueue (Squeue *&amp;sq,Elemtype x)
 82 {
 83     if (sq-&gt;front == (sq-&gt;rear+1)%maxSize)
 84         return -1;
 85     sq-&gt;data[++sq-&gt;rear%maxSize] = x;
 86     return 1;
 87 }
 88 int dequeue(Squeue *&amp;sq,Elemtype &amp;x)
 89 {
 90     if (sq-&gt;front == sq-&gt;rear)
 91         return -1;
 92     x = sq-&gt;data[++sq-&gt;front%maxSize];
 93     return 1;
 94 }
 95 // 链队列比较特殊，头结点中有两个指针，指向普通的数据节点
 96 typedef struct 
 97 {
 98     struct QLNode *rear;
 99     struct QLNode *front;
100 }Liqueue;
101 typedef struct QLNode
102 {
103     Elemtype data;
104     struct QLNode *next;
105 }QLNode;
106 int init_Liqueue(Liqueue *&amp;lq)
107 {
108     lq = (Liqueue *)malloc(sizeof(Liqueue));
109     lq-&gt;front = lq-&gt; rear = NULL;
110     return 1;
111 }
112 void enQueue(Liqueue *&amp;lq,Elemtype x)
113 {
114     QLNode *p = (QLNode *)malloc(sizeof(QLNode));
115     p-&gt;data = x;
116     // 从rear后插入结点元素
117     if (lq-&gt;front == NULL)
118     {
119         // 第一个元素，既是队尾也是队头
120         lq-&gt;front = lq-&gt;rear = p;
121     }
122     else 
123     {
124         lq-&gt;rear-&gt;next = p;
125         lq-&gt;rear = p;
126     }
127     free(p);
128 
129 }
130 int  deQueue(Liqueue *&amp;lq,Elemtype &amp;x)
131 {
132     // 判断队列是否为空
133     if (lq-&gt;front == NULL || lq-&gt;rear == NULL)
134         return -1;
135     // 判断是否是只有一个结点的特殊情况
136     p = lq-&gt;front;
137     if (lq-&gt;front == lq-&gt;rear)
138     {
139         lq-&gt;front = lq-&gt;rear = NULL;
140     }
141     else 
142     {
143         lq-&gt;front = lq-&gt;front-&gt;next;
144     }
145     x = p-&gt;data;
146     free(p);    
147     return 1;
148 }
149 
150 // 括号匹配问题
151 
152 int match(char exp[],int n)
153 {
154     Sqstack *sq;
155     initStack(sq);
156     char c;
157     for (int i = 0;i &lt; strlen(exp) ; i++)
158     {
159         // 遍历该字符数组，如果是左括号则push进去
160         // 如果是右括号：栈空则不匹配，否则弹栈
161         if (exp[i] == &#39;(&#39;)
162         {
163             push_Sqstack(sq,exp[i]);
164         }
165         else
166         {
167             if (exp[i] == &#39;)&#39;)
168             {
169                 if (sq-&gt;top == -1)
170                     return -1;
171                 else
172                     pop_Sqstack(sq,c;
173             }
174         }
175     }
176     return 1;
177 }
178 // 后缀式求值
179 int op(int a,char op,int b)
180 {
181     // 完成a op b 的运算
182     switch (op)
183     {
184     case &#39;+&#39;:return a+b;
185     case &#39;-&#39;:return a-b;
186     case &#39;*&#39;:return a*b;
187     case &#39;\&#39;:return a/b; // 需要判断被除数b是否为0
188     default:return 0;
189     }
190 }
191 int com(char exp[])
192 {
193     // exp 数组中存放后缀表达式，最后一个字符为\0 
194     // 栈用来起到一个存储暂时不用的数据的作用
195     Sqstack *sq;
196     initStack(sq);
197 
198     int i=0;
199     while (exp[i]!=&#39;\0&#39;)
200     {
201         if (exp[i]&gt;&#39;0&#39; &amp;&amp; exp[i]&lt;=9)
202         {
203          // 如果是数字则push，如果是操作符则弹栈两次运算
204          push(sq,exp[i]-&#39;0&#39;);
205         }
206         else 
207         {
208             int a,b;
209             pop_Sqstack(sq,a);
210             pop_Sqstack(sq,b);
211             int result = match(a,exp[i],b);
212             push_Sqstack(sq,result);
213         }
214 
215     }
216     return sq-&gt;data[sq-&gt;top]; // 最终栈中只保留一个结果
217 }
218 int main()
219 {
220 
221     return 0;
222 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构（严版）课本代码重敲——第四章" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构（严版）课本代码重敲——第四章/">数据结构（严版）课本代码重敲——第四章</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构（严版）课本代码重敲——第四章/" class="article-date">
  <time datetime="2018-08-20T17:36:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="复习笔记-数据结构-第四章-串"><a href="#复习笔记-数据结构-第四章-串" class="headerlink" title="复习笔记 数据结构 第四章 串"></a>复习笔记 数据结构 第四章 串</h3><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #define maxSize 20
  6 #define ERROR -1
  7 using namespace std;
  8 /*
  9     题目：数据结构 cha4 串
 10     内容：1. 赋值、取串长度、串比较、串连接、求子串
 11     日期：2018/3/11
 12     时间：tomato *
 13 
 14 */
 15 // 定长顺序存储
 16 typedef struct
 17 {
 18     char data[maxSize];
 19     int length;
 20 }str1;
 21 
 22 typedef struct
 23 {
 24     char *ch;
 25     int length;
 26 }Str;
 27 
 28 // 串比较
 29 int cmp(Str s1,Str s2)
 30 {
 31     for (int i=0; i&lt;s1.length &amp;&amp; i&lt;s2.length ;i++)
 32     {
 33         if (s1.ch[i] != s2.ch[i])
 34             return s1.ch[i] - s2.ch[i];
 35     }
 36     return s1.length - s2.length;
 37 }
 38 // 串赋值
 39 int strassign(Str &amp;str,char *ch)
 40 {
 41     if (str.ch)
 42         free(ch);// 如果str中存储着一个字符串则释放
 43     // 1. 判断ch的长度，若为0则不用赋值，否则赋值
 44     int i = 1;
 45     int len_ch=0;
 46     while (ch[i]!=&#39;\0&#39;)
 47     {
 48         len_ch ++;
 49         i++;
 50     }
 51     if (len_ch == 0) // 空字符串，返回空串
 52     {
 53         str.length = 0;
 54         str.ch = NULL;
 55         return 1;
 56     }
 57     // 否则创建str的结点
 58     str.ch = (char *)malloc((len_ch+1)*sizeof(char));
 59     if (str.ch == NULL)
 60         return 0; // malloc 失败！经常被忽略★★★
 61     for (int i=0;i&lt;=len_ch;i++)
 62     {
 63         str.ch[i] = ch[i]; // 记得最后的\0终止符也要赋值
 64          // 除了用数组的方式获取ch中的值外，还可以 
 65          // char *c = ch ; 
 66          // c++ *c即为ch[i]的值
 67     }
 68     str.length = len_ch ; // ★★★ 长度的赋值经常忘！
 69     return 1;
 70 }
 71 // 串连接
 72 int strconcat(Str &amp;str,Str str1,Str str2)
 73 {
 74 
 75     int len = str1.length + str2.length ;
 76     if (str.ch)
 77         free(str1.ch);
 78     str.ch  = (char *)malloc(sizeof(char)*(len+1));
 79     int i=0;
 80     while (str1.length -- )
 81     {
 82         str.ch[i] = str1.ch[i];i++;
 83     }
 84     int j=0;
 85     while (str2.length --)
 86     {
 87         str.ch[i+j] = str2.ch[j];j++;
 88     }
 89     str.ch[i+j+1] = &#39;\0&#39;;
 90     str.length = str1.length + str2.length;
 91     return 1;
 92 }
 93 // 求子串
 94 int substring(Str &amp;substr,Str str,int pos,int len)
 95 {
 96     if (pos &lt; 0 || pos &gt;str.length || len &lt;0 || len &gt; str.length-pos)
 97         return 0;
 98     if (substr.ch)
 99         free(substr.ch);
100     if (len == 0)
101     {
102         substr.ch = NULL;
103         substr.length = 0;
104         return 1;
105     }
106     substr.ch = (char *)malloc(sizeof(char)*len);
107     int i=0;
108     while (len--)
109     {
110         substr.ch[i] = str.ch[pos];
111         i++;pos++;
112     }
113     substr.ch[i] = &#39;\0&#39;;
114     substr.length = len;
115     return 1;
116 }
117 int main()
118 {
119 
120     return 0;
121 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构（严版）课本代码重敲——第六章" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构（严版）课本代码重敲——第六章/">数据结构（严版）课本代码重敲——第六章</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构（严版）课本代码重敲——第六章/" class="article-date">
  <time datetime="2018-08-20T17:35:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编程笔记-数据结构-第六章-树与二叉树"><a href="#编程笔记-数据结构-第六章-树与二叉树" class="headerlink" title="编程笔记 数据结构 第六章 树与二叉树"></a>编程笔记 数据结构 第六章 树与二叉树</h3><blockquote>
<p>以后有什么知识盲点就记录一下， 经常拿出来复习才能彻底消化吸收，一个劲儿地往前学是不可行的方法。</p>
</blockquote>
<h4 id="typedef-struct-和struct"><a href="#typedef-struct-和struct" class="headerlink" title="typedef struct 和struct"></a>typedef struct 和struct</h4><p>1 首先：//注意在C和C++里不同<br>在C中定义一个结构体类型要用typedef:  </p>
<pre><code>1 typedef struct Student
2 　　　　{
3 　　　　int a;
4 　　　　}Stu;
</code></pre><p>于是在声明变量的时候就可：Stu stu1;(如果没有typedef就必须用struct Student stu1;来声明)<br>这里的Stu实际上就是struct Student的别名。Stu==struct Student<br>另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;）  </p>
<pre><code>1 typedef struct
2 　　　　{
3 　　　　int a;
4 　　　　}Stu;
</code></pre><p>但在c++里很简单，直接  </p>
<pre><code>1 struct Student
2 　　　　{
3 　　　　int a;
4 　　　　};　　
</code></pre><p>于是就定义了结构体类型Student，声明变量时直接Student stu2；</p>
<p>2.其次：<br>在c++中如果用typedef的话，又会造成区别：  </p>
<pre><code>1 struct   Student   
2 　　　　{   
3 　　　　int   a;   
4 　　　　}stu1;//stu1是一个变量  
5 typedef   struct   Student2   
6 　　　　{   
7 　　　　int   a;   
8 　　　　}stu2;//stu2是一个结构体类型=struct Student  
</code></pre><p>使用时可以直接访问stu1.a<br>但是stu2则必须先 stu2 s2;<br>然后 s2.a=10;</p>
<h4 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h4><p>一、引用的定义</p>
<p>引用是给另外一个变量起别名，所以引用不会分配内存空间。</p>
<p>引用的声明方法：类型标识符 &amp;引用名=目标变量名;（如int &amp;ptr = num;）</p>
<p>二、引用与指针的区别</p>
<p>1、指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。</p>
<p>2、引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）</p>
<p>3、有多级指针，但是没有多级引用，只能有一级引用。</p>
<p>4、指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）</p>
<p>5、sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。</p>
<p>6、引用访问一个变量是直接访问，而指针访问一个变量是间接访问。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 
 3 using namespace std;
 4 
 5 void swap(int &amp;a, int &amp;b)
 6 {
 7     int tmp;
 8 
 9     tmp = a;
10     a   = b;
11     b   = tmp;
12 }
13 
14 int main()
15 {
16     int a = 3;
17     int b = 5;
18 
19     cout &lt;&lt; &quot;before swap, a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; endl;
20 
21     swap(a, b);
22 
23     cout &lt;&lt; &quot;after swap, a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; endl;
24 
25     return 0;
26 }






#### 3/24 二叉树练习
</code></pre><blockquote>
<p>引用是给变量了另一个名字，调用时为直接调用变量而指针是分配了一个内存空间并存下变量的地址，属于间接引用。</p>
</blockquote>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;queue&gt;
  5 using namespace std;
  6 
  7 /*
  8     题目：二叉树
  9     1. 二叉树的创建
 10     2. 四种遍历方法
 11     3. 三种非递归遍历方法
 12 */
 13 typedef char Elemtype;
 14 typedef struct node
 15 {
 16     struct node *lchild;
 17     struct node *rchild;
 18     Elemtype data;
 19 }BiNode, *BiTree;
 20 // 给结构体node起别名：BiNode,以及结构体的指针的别名：BiTree
 21 
 22 void create(BiTree &amp;t)
 23 {
 24     Elemtype x;
 25     cin &gt;&gt; x;
 26     if (x == &#39;#&#39;)
 27     {
 28         t = NULL;
 29     }
 30     else
 31     {
 32         t = (BiTree)malloc(sizeof(BiTree));
 33         t-&gt;data = x;
 34         create(t-&gt;lchild);
 35         create(t-&gt;rchild);
 36     }
 37 }
 38 
 39 void print(BiTree &amp;t)
 40 {
 41     if (t != NULL)
 42     {
 43         cout &lt;&lt; t-&gt;data ;
 44         print(t-&gt;lchild);
 45         print(t-&gt;rchild);
 46     }
 47 }
 48 // 1. 表达式求值 输入一个表达式创建二叉树
 49 
 50 void createBD(BiTree &amp;t)
 51 {
 52     Elemtype x;
 53     cin &gt;&gt; x;
 54     if (x != &#39;#&#39;)
 55     {
 56         t = (BiTree )malloc(sizeof(BiTree));
 57         t-&gt;data = x;
 58         createBD(t-&gt;lchild);
 59         createBD(t-&gt;rchild);
 60     }else
 61     {
 62         t = NULL;
 63     }
 64 }
 65 
 66 int cmp(int a,char op,int b)
 67 {
 68     switch (op)
 69     {
 70         case &#39;+&#39;:return a+b;
 71         case &#39;-&#39;:return a-b;
 72         case &#39;*&#39;:return a*b;
 73         case &#39;/&#39;:
 74             if (b!=0)
 75                 return a/b;
 76     }
 77     return 0;
 78 }
 79 // 后序遍历计算值
 80 int countV(BiTree &amp;t)
 81 {
 82     int a,b;
 83 
 84     if (t!=NULL)
 85     {
 86         if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)
 87         {
 88             return t-&gt;data - &#39;0&#39;;
 89         }
 90         else
 91         {
 92             a = countV(t-&gt;lchild);
 93             b = countV(t-&gt;rchild);
 94             int c = cmp(a,t-&gt;data,b);
 95             return c;
 96         }
 97     }
 98     else
 99         return 0;
100 }
101 
102 int depth(BiTree &amp;t)
103 {
104     if (t == NULL)
105         return 0;
106     else
107     {
108         int l = depth(t-&gt;lchild);
109         int r = depth(t-&gt;rchild);
110         return l&gt;=r?l+1:r+1;
111     }
112 
113 }
114 // 层次遍历
115 void level(BiTree &amp;t)
116 {
117     queue&lt;BiTree&gt; q;
118     BiTree p;
119     if (t) // 空树没有必要遍历了
120     {
121         q.push(t); // 根节点入队
122         while (!q.empty())
123         {
124            p =  q.front(); // 弹栈一个元素
125            q.pop();
126             cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;;
127 
128             if (p-&gt;lchild)
129             {
130                 q.push(p-&gt;lchild);
131             }
132             if (p-&gt;rchild)
133             {
134                 q.push(p-&gt;rchild);
135             }
136         }
137     }
138 }
139 // 计算二叉树的宽度
140 struct Node{
141 BiTree t;
142 int num; // 结点所在的层次号
143 };
144 const int maxSize = 100;
145 int width(BiTree &amp;t)
146 {
147     Node q[maxSize];
148     int front , rear ;
149     front = rear = 0;
150     int mm;
151 
152     BiTree p;
153     Node n;
154     if (t) // 空树没有必要遍历了
155     {
156         n.t = t;
157         n.num = 1;
158         rear = (rear+1)%maxSize;
159         q[rear] = n;
160         while (front != rear)
161         {
162            front = (front +1)%maxSize;
163            p = q[front].t;
164           // cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;;
165             int lno = q[front].num;
166             if (p-&gt;lchild)
167             {
168                 n.num = lno +1;
169                 n.t = p-&gt;lchild;
170                 rear = (rear +1)%maxSize;
171                 q[rear] = n;
172             }
173             if (p-&gt;rchild)
174             {
175                 n.num = lno + 1;
176                 n.t = p-&gt;rchild;
177                 rear = (rear +1)%maxSize;
178                 q[rear] = n;
179             }
180         }
181 
182 
183         mm = 0;
184 
185         for (int i=1;i&lt;=n.num;i++)
186         {
187             int nn = 0 ;
188             for (int j=1;j&lt;=rear;j++)
189                 if (q[j].num == i)
190                     ++nn;
191 
192             if (nn &gt; mm)
193                 mm = nn;
194         }
195         return mm;
196         }
197         else return 0;
198     }
199 
200 // 非递归遍历算法
201 // 先序遍历
202 void preOrderNon(BiTree &amp;t)
203 {
204     BiTree s[maxSize];
205     BiTree p;
206     int top = -1;
207     if (t)
208     {
209         s[++top] = t;
210         //cout &lt;&lt; t-&gt;data &lt;&lt; endl;
211         while (top != -1)
212         {
213             p = s[top--];
214             cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;;
215             if (p-&gt;lchild)
216             {
217                 s[++top] = p-&gt;lchild;
218             }
219             if (p-&gt;rchild)
220             {
221                 s[++top] = p-&gt;rchild;
222             }
223         }
224     }
225 }
226 
227 // 中序遍历
228 void inOrderNon(BiTree &amp;t)
229 {
230     BiTree s[maxSize];
231     int top = -1;
232     BiTree p;
233     p = t;
234     if (t){
235     while (p!=NULL || top != -1)
236     {
237         while (p)
238         {
239             s[++top] = p;
240             p = p-&gt;lchild;
241         }
242         if (top!=-1)
243         {
244             p = s[top--];
245             cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;;
246             p = p-&gt;rchild;
247         }
248     }
249     }
250 }
251 // 后序遍历
252 
253 
254 int main()
255 {
256     BiTree t;
257     //create(t);
258     createBD(t);
259    // width(t);
260     //int c = countV(t);
261     //cout &lt;&lt; c &lt;&lt; endl;
262    // print(t);
263    // cout &lt;&lt; width(t)&lt;&lt;endl;
264     inOrderNon(t);
265     return 0;
266 }
</code></pre><h4 id="二叉树练习-2018-3-26"><a href="#二叉树练习-2018-3-26" class="headerlink" title="二叉树练习 2018/3/26"></a>二叉树练习 2018/3/26</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;queue&gt;
  5 #include &lt;stack&gt;
  6 using namespace std;
  7 
  8 /*
  9     题目：二叉树
 10 1. 创建二叉树 √
 11 2. 三种递归遍历方法+层次遍历法 √
 12 3. 三种非递归遍历方法
 13 4. 求二叉树的深度
 14 6. 求叶子结点的个数
 15 8. 求先序遍历中第K个结点的值
 16 9. 左右子树互换
 17 10.复制二叉树
 18 7. 表达式求值
 19 5. 求二叉树的宽度
 20 */
 21 typedef char Elemtype;
 22 typedef struct BiNode
 23 {
 24     Elemtype data;
 25     struct BiNode *lchild,*rchild;
 26 }BiNode,*BiTree;
 27 
 28 // 1. 先序创建二叉树
 29 void createBiTree(BiTree &amp;t)
 30 {
 31     // 输入一个字符串序列，为NULL的指针表示为#
 32     Elemtype x;
 33     cin &gt;&gt; x;
 34     if ( x == &#39;#&#39;)
 35     {
 36         t = NULL;
 37     }
 38     else
 39     {
 40         t = (BiTree )malloc(sizeof(BiTree));
 41         t-&gt;data = x;
 42         createBiTree(t-&gt;lchild);
 43         createBiTree(t-&gt;rchild);
 44     }
 45 }
 46 
 47 // 2. 先序递归遍历
 48 
 49 // 访问函数
 50 void visited(BiTree p)
 51 {
 52     cout &lt;&lt;p -&gt;data &lt;&lt;&#39; &#39;;
 53 }
 54 void preOrderTraverse(BiTree &amp;t)
 55 {
 56     if (t)
 57     {
 58         visited(t);
 59         preOrderTraverse(t-&gt;lchild);
 60         preOrderTraverse(t-&gt;rchild);
 61     }
 62 }
 63 
 64 // 2. 层次遍历需要队列的辅助，没有递归遍历方法
 65 /*
 66 1. 初始化队列
 67 2. 压入根之前判断根是否为空
 68 3. 取队头 -&gt; 访问结点 -&gt; 压入非空的左孩子和右孩子
 69 4. 队列为空时循环结束
 70 */
 71 void levelOrder(BiTree &amp;t)
 72 {
 73     queue&lt;BiTree&gt; que ;
 74     BiTree p = t; // p : 遍历指针
 75     if (t) // 根节点不能为空
 76     {
 77         que.push(t);
 78         while (!que.empty())
 79         {
 80              p = que.front();
 81              que.pop();
 82              visited(p);
 83              if (p-&gt;lchild)
 84              {
 85                  que.push(p-&gt;lchild);
 86              }
 87              if (p-&gt;rchild)
 88              {
 89                  que.push(p-&gt;rchild);
 90              }
 91         }
 92     }
 93 }
 94 
 95 // 3. 非递归三种遍历方法
 96 
 97 // 先序非递归
 98 /*
 99 1. 遇到一个结点首先访问该结点，如果有左子树则继续往左走
100 2. 到了最左边时弹栈，访问右子树
101 3. 如果右子树为空则继续弹栈，否则向右子树的左边继续前进
102 */
103 void preOrderUn(BiTree &amp;t)
104 {
105     stack&lt;BiTree&gt; st;
106     BiTree p = t;
107     while (p!= NULL || !st.empty()) // 当且仅当栈和指针都为空时循环结束
108     {
109         while (p)
110         {
111             visited(p);
112             st.push(p);
113             p = p-&gt;lchild;
114         }
115         if (!st.empty())
116         {
117             p = st.top();
118             st.pop();
119             p = p-&gt;rchild;
120         }
121     }
122 }
123 // 中序非递归
124 void midOrderUn(BiTree t)
125 {
126     stack&lt;BiTree&gt; st;
127     BiTree p = t;
128     while (p != NULL || !st.empty())
129     {
130         while(p)
131         {
132             st.push(p);
133             p = p-&gt;lchild;
134         }
135         if (!st.empty())
136         {
137             p  = st.top();
138             st.pop();
139             visited(p);
140             p = p-&gt;rchild;
141         }
142     }
143 }
144 // 后序非递归遍历
145 /*
146 1. 第一次访问结点：入栈，isFirst = 1
147 2. 弹栈如果isFirst == 1,修改isFirst,压栈，往右走
148 3. 第三次访问如果isFirst = 0,访问结点数据
149 */
150 typedef struct lBiTree
151 {
152     BiTree t;
153     int isFirst;
154 }lBiTree;
155 void lastOrderUn(BiTree t)
156 {
157     stack&lt;lBiTree&gt; st;
158     BiTree p = t;
159     lBiTree l;
160     while ( p!=NULL || !st.empty())
161     {
162         while (p)
163         {
164             l.isFirst = 1;
165             l.t = p;
166             st.push(l);
167             p = p-&gt;lchild;
168         }
169         if (!st.empty())
170         {
171             l = st.top();
172             st.pop();
173 
174             if (l.isFirst == 1)
175             {
176                 l.isFirst = 0;
177                 p = l.t-&gt;rchild;
178                 st.push(l);
179             }
180             else
181             {
182                 visited(l.t);
183                 p = NULL;
184             }
185         }
186     }
187 }
188 // 4. 深度
189 int depth(BiTree t)
190 {
191     if (t == NULL)
192         return 0;
193     else
194     {
195         int l = depth(t-&gt;lchild);
196         int r = depth(t-&gt;rchild);
197         return l &gt;= r?l+1:r+1;
198     }
199 }
200 
201 // 求叶子结点个数
202 int leaf(BiTree t)
203 {
204     if (t)
205     {
206         if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)
207         {
208             return 1;
209         }
210         else
211         {
212             return leaf(t-&gt;lchild)+leaf(t-&gt;rchild);
213         }
214     }
215     else
216         return 0;
217 }
218 
219 // 求树的结点个数
220 int number(BiTree t)
221 {
222     if (t)
223         return 0; //空树没有结点
224     else{
225         return 1+number(t-&gt;lchild)+number(t-&gt;rchild);
226     }
227 }
228 // 左右子树互换
229 void exchange(BiTree &amp;t)
230 {
231     BiTree s;
232     if (t)
233     {
234         s = t-&gt;lchild;
235         t-&gt;lchild = t-&gt;rchild;
236         t-&gt;rchild = s;
237         exchange(t-&gt;lchild);
238         exchange(t-&gt;rchild);
239     }
240 
241 }
242 // 复制二叉树
243 BiTree copyBiTree(BiTree &amp;t)
244 {
245     BiTree p;
246     if (t)
247     {
248         p = (BiTree)malloc(sizeof(BiTree));
249         p-&gt;data = t-&gt;data;
250         p-&gt;lchild = copyBiTree(t-&gt;lchild);
251         p-&gt;rchild = copyBiTree(t-&gt;rchild);
252         return p;
253     }
254 
255 }
256 
257 // 表达式求值
258 int countValue(BiTree t)
259 {
260     if (t)
261     {
262         if (t-&gt;lchild == NULL &amp;&amp;t-&gt;rchild == NULL)
263         {
264             return t-&gt;data-&#39;0&#39;;
265         }
266         else{
267             int a = countValue(t-&gt;lchild);
268             int b = countValue(t-&gt;rchild);
269             int c = cmp(a,t-&gt;data,b);
270             return c;
271         }
272     }
273 }
274 
275 
276 int main()
277 {
278     BiTree t;
279     createBiTree(t);
280    // preOrderTraverse(t);
281    // levelOrder(t);
282   // preOrderUn(t);
283   //midOrderUn(t);
284  // lastOrderUn(t);
285  //cout &lt;&lt; depth(t)&lt;&lt;endl;
286  cout &lt;&lt; leaf(t)&lt;&lt;endl;
287     return 0;
288 }
</code></pre><h4 id="3-29-日练习"><a href="#3-29-日练习" class="headerlink" title="3/29 日练习"></a>3/29 日练习</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;queue&gt;
  5 #include &lt;stack&gt;
  6 using namespace std;
  7 
  8 /*
  9     时间：2018/3/26
 10     题目：二叉树
 11 1. 创建二叉树 √
 12 2. 三种递归遍历方法+层次遍历法 √
 13 3. 三种非递归遍历方法 √
 14 4. 求二叉树的深度 √
 15 5. 求叶子结点的个数 √
 16 6. 求先序遍历中第K个结点的值 √
 17 7. 左右子树互换 √
 18 8.复制二叉树 √
 19 9. 表达式求值 √
 20 10. 求二叉树的宽度 √
 21 11.线索二叉树的中序线索化
 22 12.线索二叉树的中序遍历
 23 13.线索二叉树的先序、后序线索化以及遍历方法
 24 */
 25 typedef char Elemtype;
 26 typedef struct BiNode
 27 {
 28     Elemtype data;
 29     struct BiNode *lchild,*rchild;
 30 }BiNode,*BiTree;
 31 void createBiTree(BiTree &amp;t)
 32 {
 33     Elemtype x;
 34     cin &gt;&gt; x;
 35     if (x!=&#39;#&#39;)
 36     {
 37         t = (BiTree )malloc(sizeof(BiTree));
 38         t-&gt;data = x;
 39         createBiTree(t-&gt;lchild);
 40         createBiTree(t-&gt;rchild);
 41     }
 42     else
 43     {
 44         t = NULL;
 45     }
 46 }
 47 void visit(BiTree p)
 48 {
 49     cout &lt;&lt; p-&gt;data &lt;&lt;&#39; &#39;;
 50 }
 51 void preOrder(BiTree &amp;t)
 52 {
 53     if (t)
 54     {
 55         visit(t);
 56         preOrder(t-&gt;lchild);
 57         preOrder(t-&gt;rchild);
 58     }
 59 }
 60 void levelOrder(BiTree &amp;t)
 61 {
 62     queue&lt;BiTree&gt; que;
 63     BiTree p = t;
 64     if (t)
 65     {
 66         que.push(p);
 67         while (!que.empty()) // 注意这里队空时结束，而不是队和P指针都为空，到最后的时候P不为空
 68         {
 69             p = que.front();
 70             que.pop();
 71             visit(p);
 72             if (p-&gt;lchild!=NULL)
 73                 que.push(p-&gt;lchild);
 74             if (p-&gt;rchild!=NULL)
 75                 que.push(p-&gt;rchild);
 76         }
 77     }
 78 }
 79 void preOrderUn(BiTree &amp;t)
 80 {
 81     stack&lt;BiTree&gt; st;
 82     BiTree p = t;
 83     if (t)
 84     {
 85         while (p || !st.empty())
 86         {
 87             while (p)
 88             {
 89                 visit(p);
 90                 st.push(p);
 91                 p = p-&gt;lchild;
 92             }
 93             if (!st.empty())
 94             {
 95                 p = st.top();
 96                 st.pop();
 97                 p = p-&gt;rchild;
 98             }
 99         }
100     }
101 }
102 typedef struct
103 {
104     BiTree k;
105     int isFirst;
106 }PBiTree;
107 void postOrderUn(BiTree &amp;t)
108 {
109     stack&lt;PBiTree&gt; st;
110     BiTree p  = t;
111     PBiTree tmp;
112     if (t)
113     {
114         while (p || !st.empty())
115         {
116             while (p)
117             {
118                 tmp.isFirst = 1;
119                 tmp.k = p;
120                 st.push(tmp);
121                 p = p-&gt;lchild;
122             }
123             if (!st.empty())
124             {
125                 tmp = st.top();
126                 st.pop();
127                 if (tmp.isFirst == 1)
128                 {
129                     tmp.isFirst = 0;
130                     st.push(tmp);
131                     p = tmp.k-&gt;rchild;
132                 }else
133                 {
134                     visit(tmp.k);
135                     p = NULL;
136                 }
137             }
138         }
139     }
140 }
141 int depth(BiTree &amp;t)
142 {
143     if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)
144     {
145         return 1;
146     }
147     if (t)
148     {
149         int l = depth(t-&gt;lchild);
150         int r = depth(t-&gt;rchild);
151         return l&gt;r?l+1:r+1;
152     }
153 }
154 int leaf(BiTree &amp;t)
155 {
156     if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)
157         return 1;
158     if (t)
159     {
160         return leaf(t-&gt;lchild)+leaf(t-&gt;rchild);
161     }
162 }
163 void exchange(BiTree &amp;t)
164 {
165     BiTree p;
166     if (t)
167     {
168         p = t-&gt;lchild;
169         t-&gt;lchild = t-&gt;rchild;
170         t-&gt;rchild = p;
171         exchange(t-&gt;lchild);
172         exchange(t-&gt;rchild);
173     }
174 }
175 int count(int a,char c,int b)
176 {
177     return 1;
178 }
179 int value(BiTree &amp;t)
180 {
181     if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)
182     {
183             return t-&gt;data -&#39;0&#39;;
184     }
185     if (t)
186     {
187         int a = value(t-&gt;lchild);
188         int b = value(t-&gt;rchild);
189         int c = count(a,t-&gt;data,b);
190         return c;
191     }
192 }
193 typedef struct
194 {
195     BiTree k;
196     int level;
197 }WBiTree;
198 const int MAXSIZE  = 20;
199 int width(BiTree &amp;t)
200 {
201     WBiTree que[MAXSIZE];
202     BiTree p = t;
203     WBiTree tmp,tmp2;
204     int front=0,rear = 0;
205     int level = 1;
206     if (t)
207     {
208         rear = (rear+1)%MAXSIZE;
209         tmp.k = p;
210         tmp.level = level;
211         que[rear] = tmp;
212         while (front != rear)
213         {
214             front = (front+1)%MAXSIZE;
215             tmp = que[front];
216             if (tmp.k-&gt;lchild)
217             {
218                 rear = (rear+1)%MAXSIZE;
219                 tmp2.k = tmp.k-&gt;lchild;
220                 tmp2.level = tmp.level+1;
221                 que[rear] = tmp2; // 等于根节点+1
222             }
223             if (tmp.k-&gt;rchild)
224             {
225                 rear = (rear+1)%MAXSIZE;
226                 tmp2.k = tmp.k-&gt;rchild;
227                 tmp2.level = tmp.level+1;
228                 que[rear] = tmp2; // 等于根节点+1
229             }
230         }
231         // 遍历一下que数组，从0-rear,统计每层的结点个数，求最大值
232         int maxNum = 0;
233         int num = 1;
234         int j = 1;
235         for (int i = 1;i&lt;=rear;i++)
236         {
237 
238             if (que[i+1].level == que[i].level)
239             {
240                 num++;
241             }
242             else
243             {
244                 num = 1;
245             }
246             if (num &gt; maxNum)
247             {
248                 maxNum = num;
249             }
250         }
251         return maxNum;
252     }
253     return 0;
254 }
255 int main()
256 {
257     BiTree t;
258     createBiTree(t);
259 //    preOrder(t);
260 //    levelOrder(t);
261 //    preOrderUn(t);
262 //postOrderUn(t);
263 //cout &lt;&lt; depth(t) &lt;&lt; endl;
264 //cout &lt;&lt; leaf(t) &lt;&lt; endl;
265 cout &lt;&lt; width(t) &lt;&lt; endl;
266 
267     return 0;
268 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构（严版）课本代码重敲——第七章" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构（严版）课本代码重敲——第七章/">数据结构（严版）课本代码重敲——第七章</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构（严版）课本代码重敲——第七章/" class="article-date">
  <time datetime="2018-08-20T17:33:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据结构-第七章-图"><a href="#数据结构-第七章-图" class="headerlink" title="数据结构 第七章 图"></a>数据结构 第七章 图</h3><h4 id="四种基本存储结构之邻接矩阵表示法"><a href="#四种基本存储结构之邻接矩阵表示法" class="headerlink" title="四种基本存储结构之邻接矩阵表示法"></a>四种基本存储结构之邻接矩阵表示法</h4><pre><code>  1 /*
  2 * 范围：第七章 图
  3 * 日期：2018/4/1
  4 */
  5 
  6 /*
  7 笔记：
  8 enum &lt; 枚举类型名&gt; {&lt; 枚举表&gt;};
  9 enum day {Sun,Mon,Tue,Wed,Thu,Fri,Sat};
 10 day d1,d2,d3;
 11 d1 = Thu; d2 = Sat; d3 = Tue;
 12 定义为枚举类型的变量，只能取枚举表中的值,枚举的本质是整型类型。
 13 */
 14 #include &lt;iostream&gt;
 15 #define INFINITY INT_MAX
 16 
 17 
 18 using namespace std;
 19 // 数组表示法/邻接矩阵表示法
 20 const int MAXSIZE = 20;
 21 typedef char vertexType;
 22 typedef int vrType;
 23 typedef char infoType;
 24 typedef enum{DG,DN,UDG,UDN} graphKind;
 25 
 26 typedef struct arcCell
 27 {
 28     vrType adj;
 29     infoType *info;
 30 }arcCell,adjMatrix[MAXSIZE][MAXSIZE];
 31 
 32 typedef struct
 33 {
 34     vertexType vex[MAXSIZE];
 35     adjMatrix arc;
 36     int vexnum,arcnum;
 37     graphKind kind;
 38 }MGraph;
 39 
 40 int locate(MGraph &amp;g,vertexType v)
 41 {
 42     for (int i=0;i&lt;g.vexnum;i++)
 43     {
 44         if( g.vex[i] == v)
 45             return i;
 46     }
 47     return -1;
 48 }
 49 void createUDN(MGraph &amp;g)
 50 {
 51     int hasInfo;
 52     cout &lt;&lt; &quot;顶点数、边数、是否有信息&quot;&lt;&lt;endl;
 53     cin &gt;&gt; g.vexnum &gt;&gt;g.arcnum &gt;&gt; hasInfo;
 54     int i,j;
 55     for (i=0;i&lt;g.vexnum;i++)
 56     {
 57         cin &gt;&gt;g.vex[i];
 58     }
 59     for (i=0;i&lt;g.vexnum;i++)
 60         for (j=0;j&lt;g.vexnum;j++)
 61     {
 62         g.arc[i][j].adj = INFINITY;
 63         g.arc[i][j].info = NULL;
 64     }
 65     vertexType v1,v2;
 66     vrType w;
 67     cout &lt;&lt; &quot;边：&quot; &lt;&lt;endl;
 68     for (int k=0;k&lt;g.arcnum;k++)
 69     {
 70         cin &gt;&gt;v1 &gt;&gt;v2&gt;&gt;w;
 71         i = locate(g,v1);
 72         j = locate(g,v2);
 73         g.arc[i][j].adj = w;
 74         if (hasInfo)
 75             cin &gt;&gt; g.arc[i][j].info;
 76         g.arc[j][i] = g.arc[i][j];
 77     }
 78 }
 79 void createGraph(MGraph &amp;g)
 80 {
 81     graphKind kind;
 82     cout &lt;&lt; &quot;graphkind&quot;&lt;&lt;endl ;
 83     cin &gt;&gt; (int &amp;)kind;
 84     switch(kind)
 85     {
 86         case UDN:createUDN(g);
 87     }
 88 }
 89 void printMatrix(MGraph &amp;g)
 90 {
 91     int i,j;
 92     for (i=0;i&lt; g.vexnum ; i++)
 93     {
 94          for (j = 0 ;j&lt;g.arcnum;j++)
 95     {
 96         if (g.arc[i][j].adj == INFINITY)
 97             cout &lt;&lt; &#39;#&#39; &lt;&lt; &#39; &#39;;
 98         else
 99             cout &lt;&lt; g.arc[i][j].adj &lt;&lt;&#39; &#39;;
100     }
101     cout &lt;&lt;endl;
102     }
103 
104 }
105 // 深度优先搜索
106 bool visited[MAXSIZE];
107 
108 int firstAdjVex(MGraph &amp;g,int v)
109 {
110     // 邻接矩阵表示法中，点v的第一个邻接点，在矩阵中横着找不为无穷大的点
111     int j;
112     for (j = 0; j &lt; g.vexnum ; j++)
113     {
114       if (g.arc[v][j].adj!=INFINITY)
115         return j;
116     }
117     return -1;
118 }
119 int nextAdjVex(MGraph &amp;g,int v,int w)
120 {
121     // v的邻接点中在w之后的第一个邻接点
122     int j;
123     for (j = w+1;j&lt;g.vexnum;j++)
124     {
125         if (g.arc[v][j].adj!=INFINITY)
126             return j;
127     }
128     return -1;
129 }
130 void DFS(MGraph &amp;g,int v)
131 {
132     visited[v] = true; // 从V结点开始深度搜索
133     cout &lt;&lt; g.vex[v] &lt;&lt; &#39; &#39;;
134     for (int w = firstAdjVex(g,v); w &gt;= 0 ;w = nextAdjVex(g,v,w))
135     {
136         if (!visited[w])
137             DFS(g,w);// 对未被访问过的邻接点递归调用DFS
138     }
139 }
140 void DFSTraverse(MGraph &amp;g)
141 {
142     int i;
143     for (i=0;i&lt;g.vexnum;i++)
144         visited[i] = false; // 初始化visited,均未被访问
145     for (i=0;i&lt;g.vexnum;i++) // 一次寻找后可能有仍旧未被访问的点
146     {
147         if (!visited[i])
148             DFS(g,i);
149     }
150 
151 }
152 int main()
153 {
154     MGraph g;
155     createGraph(g);
156    // printMatrix(g);
157    DFSTraverse(g);
158 
159     return 0;
160 }
</code></pre><h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><pre><code>  1 /*
  2 * 范围：第七章 图
  3 * 日期：2018/4/1
  4 */
  5 
  6 /*
  7 笔记：
  8 enum &lt; 枚举类型名&gt; {&lt; 枚举表&gt;};
  9 enum day {Sun,Mon,Tue,Wed,Thu,Fri,Sat};
 10 day d1,d2,d3;
 11 d1 = Thu; d2 = Sat; d3 = Tue;
 12 定义为枚举类型的变量，只能取枚举表中的值,枚举的本质是整型类型。
 13 */
 14 #include &lt;iostream&gt;
 15 #include &lt;string&gt;
 16 #include &lt;stdlib.h&gt;
 17 #define INFINITY INT_MAX
 18 
 19 
 20 using namespace std;
 21 
 22 // 邻接表
 23 
 24 const int MAXSIZE = 20;
 25 
 26 typedef char vertexType;
 27 typedef char infoType;
 28 typedef enum{DG,UDG} graphKind;
 29 
 30 typedef struct arcNode
 31 {
 32     int adjvex;
 33     infoType *info;
 34     struct arcNode *nextarc;
 35 }arcNode;
 36 
 37 typedef struct
 38 {
 39     vertexType data;
 40     struct arcNode *firstarc;
 41 }VNode;
 42 
 43 typedef struct
 44 {
 45     VNode adjList[MAXSIZE];
 46     int vexnum,arcnum;
 47     graphKind kind;
 48 }ALGraph;
 49 
 50 int locate(ALGraph &amp;g,vertexType v)
 51 {
 52     int i;
 53     for (i = 0;i&lt;g.vexnum;i++)
 54     {
 55         if ( g.adjList[i].data == v )
 56             return i;
 57     }
 58     return -1;
 59 }
 60 
 61 void createUDG(ALGraph &amp;g)
 62 {
 63     int hasInfo;
 64     cout &lt;&lt; &quot;顶点数、边数、是否有信息&quot;&lt;&lt;endl;
 65     cin &gt;&gt; g.vexnum &gt;&gt; g.arcnum&gt;&gt;hasInfo;
 66     int i,j,k;
 67     cout &lt;&lt; &quot;头结点&quot; &lt;&lt;endl;
 68     for (i=0;i&lt;g.vexnum;i++)
 69     {
 70         cin &gt;&gt; g.adjList[i].data ;
 71         g.adjList[i].firstarc = NULL;
 72     }
 73     vertexType v1,v2;
 74     arcNode *p,*q;
 75     cout &lt;&lt; &quot;边：&quot; &lt;&lt;endl;
 76     for (k = 0; k &lt; g.arcnum;k++)
 77     { // 头插法建立链表
 78         cin &gt;&gt; v1 &gt;&gt; v2;
 79         i = locate(g,v1);
 80         j = locate(g,v2);
 81         p = (arcNode*)malloc(sizeof(arcNode));
 82         if (hasInfo)
 83             cin &gt;&gt; p-&gt;info;
 84         p-&gt;adjvex = j;
 85         p-&gt;nextarc = g.adjList[i].firstarc;
 86         g.adjList[i].firstarc = p;
 87 
 88         // 无向图一条边建立两个节点
 89         q = (arcNode*)malloc(sizeof(arcNode));
 90         if (hasInfo)
 91             q-&gt;info = p-&gt;info;
 92         q-&gt;adjvex = i;
 93         q-&gt;nextarc = g.adjList[j].firstarc;
 94         g.adjList[j].firstarc = q;
 95     }
 96 }
 97 
 98 void createDG(ALGraph &amp;g)
 99 {
100     int hasInfo;
101     cout &lt;&lt; &quot;顶点数、弧数、有无信息&quot;&lt;&lt;endl;
102     cin &gt;&gt;g.vexnum &gt;&gt;g.arcnum &gt;&gt; hasInfo;
103 
104     int i,j,k;
105     cout &lt;&lt; &quot;顶点&quot; &lt;&lt;endl;
106     for (i=0;i&lt;g.vexnum;i++)
107     {
108         cin &gt;&gt; g.adjList[i].data;
109         g.adjList[i].firstarc = NULL;
110     }
111     arcNode *p;
112     vertexType v1,v2;
113     cout &lt;&lt; &quot;弧&quot; &lt;&lt;endl ;
114     for (k = 0;k&lt;g.arcnum;k++)
115     {
116         cin &gt;&gt;v1&gt;&gt;v2;
117         i = locate(g,v1);
118         j = locate(g,v2);
119         p = (arcNode*)malloc(sizeof(arcNode));
120         p-&gt;adjvex = j;
121         p-&gt;nextarc = g.adjList[i].firstarc;
122         if (hasInfo)
123             cin &gt;&gt; p-&gt;info;
124         g.adjList[i].firstarc = p;
125     }
126 
127 
128 }
129 
130 void buildNALG(ALGraph &amp;g,ALGraph &amp;ng)
131 {
132     ng.vexnum = g.vexnum;
133     ng.arcnum  = g.arcnum;
134 
135     int i,j;
136     for (i=0;i&lt;ng.vexnum;i++)
137     {
138         ng.adjList[i].data = g.adjList[i].data;
139         ng.adjList[i].firstarc = NULL;
140     }
141     arcNode *p,*q;
142     for (i = 0;i&lt;g.vexnum;i++)
143     {
144         for (j = 0;j&lt;g.vexnum;j++)
145         {
146             if (i==j)
147                 continue;
148             p = g.adjList[j].firstarc;
149             while (p)
150             {
151                 if (p-&gt;adjvex == i)
152                 {
153                     q = (arcNode *)malloc(sizeof(arcNode));
154                     q-&gt;adjvex = j;
155                     q-&gt;info = p-&gt;info;
156                     q-&gt;nextarc = ng.adjList[i].firstarc;
157                     ng.adjList[i].firstarc = q;
158                 }
159                 p = p-&gt;nextarc;
160             }
161 
162         }
163     }
164 }
165 
166 void createGraph(ALGraph &amp;g)
167 {
168     graphKind kind;
169     cout &lt;&lt; &quot;kind:&quot;&lt;&lt;endl;
170     cin &gt;&gt; (int &amp;)kind;
171     switch(kind)
172     {
173         case UDG:createUDG(g);break;
174         case DG:createDG(g);
175     }
176 }
177 void printGraph(ALGraph &amp;g)
178 {
179     int i;
180     arcNode *p;
181     for (i=0;i&lt;g.vexnum;i++)
182     {
183         if (!g.adjList[i].firstarc)
184             cout &lt;&lt;g.adjList[i].data &lt;&lt; &quot;-&gt;NULL&quot;;
185         else
186             cout &lt;&lt; g.adjList[i].data &lt;&lt;&quot;-&gt;&quot;;
187         p = g.adjList[i].firstarc;
188         while (p)
189         {
190             if (!p-&gt;nextarc)
191                 cout &lt;&lt;p-&gt;adjvex;
192             else
193                 cout &lt;&lt;p-&gt;adjvex &lt;&lt; &quot;-&gt;&quot;;
194             p = p-&gt;nextarc;
195         }
196         cout &lt;&lt;endl;
197     }
198 
199 }
200 // 深度优先搜索
201 bool visited[MAXSIZE];
202 
203 int firstAdjVex(ALGraph &amp;g,int v)
204 {
205     if (g.adjList[v].firstarc)
206         return g.adjList[v].firstarc-&gt;adjvex;
207     else
208         return -1;
209 }
210 int nextAdjVex(ALGraph &amp;g,int v,int w)
211 {
212     arcNode *p;
213     p = g.adjList[v].firstarc;
214     for (p ; p ; p = p -&gt;nextarc)
215     {
216         if (p-&gt;adjvex == w)
217         {
218             if (p-&gt;nextarc)
219             {
220                 return p-&gt;nextarc-&gt;adjvex;
221             }
222             else
223                 return -1;
224         }
225     }
226 }
227 void DFS(ALGraph &amp;g,int v)
228 {
229     visited[v] = true;
230     cout &lt;&lt; g.adjList[v].data&lt;&lt;&#39; &#39;;
231     for (int w = firstAdjVex(g,v) ; w&gt;=0 ; w = nextAdjVex(g,v,w)) // 注意这里不能写w,因为我的return值是-1！所以条件亦成立
232     {
233         if (!visited[w])
234             DFS(g,w);
235     }
236 }
237 void DFSTraverse(ALGraph &amp;g)
238 {
239     int i;
240     for (i=0;i&lt;g.vexnum;i++)
241     {
242         visited[i] = false;
243     }
244     for (i = 0;i&lt;g.vexnum;i++)
245     {
246         if (!visited[i])
247             DFS(g,i);
248     }
249 }
250 
251 // 广度优先搜索
252 void BFSTraverse(ALGraph &amp;g)
253 {
254     for (int i = 0;i&lt;g.vexnum;i++)
255         visited[i] = false;
256     queue&lt;int&gt; que;
257     for (int i = 0;i&lt;g.vexnum;i++)
258     {
259         if (!visited[i])
260         {
261             visited[i] = true;
262             cout &lt;&lt; g.adjList[i].data&lt;&lt;&#39; &#39;;
263             que.push(i);
264             while (!que.empty())
265             {
266                 int u = que.front();
267                 que.pop();
268                 for (int w = firstAdjVex(g,u) ; w &gt;=0 ;w= nextAdjVex(g,u,w))
269                 {
270                     if (!visited[w])
271                     {
272                         visited[w] = true;
273                         cout &lt;&lt; g.adjList[w].data &lt;&lt;&#39; &#39;;
274                         que.push(w);
275                     }
276                 }
277             }
278         }
279     }
280 }
281 int main()
282 {
283    ALGraph g,ng;
284    createGraph(g);
285    //buildNALG(g,ng);
286    printGraph(g);
287    DFSTraverse(g);
288 
289 
290     return 0;
291 }
</code></pre><h4 id="十字链表表示法"><a href="#十字链表表示法" class="headerlink" title="十字链表表示法"></a>十字链表表示法</h4><pre><code> 1 /*
 2 * 范围：第七章 图
 3 * 日期：2018/4/1
 4 */
 5 
 6 /*
 7 笔记：
 8 enum &lt; 枚举类型名&gt; {&lt; 枚举表&gt;};
 9 enum day {Sun,Mon,Tue,Wed,Thu,Fri,Sat};
10 day d1,d2,d3;
11 d1 = Thu; d2 = Sat; d3 = Tue;
12 定义为枚举类型的变量，只能取枚举表中的值,枚举的本质是整型类型。
13 */
14 #include &lt;iostream&gt;
15 #include &lt;string&gt;
16 #include &lt;stdlib.h&gt;
17 
18 
19 using namespace std;
20 // 十字链表
21 const int MAXSIZE = 20;
22 
23 typedef char vertexType;
24 typedef char infoType;
25 
26 typedef struct arcNode
27 {
28     int tailvex,headvex;//尾部邻接点和头部邻接点
29     struct arcNode *hlink,*tlink;//hlink指向弧头相同的下一条弧
30     infoType *info;
31 }arcNode;
32 
33 typedef struct
34 {
35     vertexType data;
36     struct arcNode *firstin,*firstout;
37 }VNode;
38 
39 typedef struct
40 {
41     int vexnum,arcnum;
42     VNode olist[MAXSIZE];
43 }OLGraph;
44 
45 int locate(OLGraph &amp;g,vertexType v)
46 {
47     int i;
48     for (i=0;i&lt;g.vexnum;i++)
49     {
50         if ( g.olist[i].data == v )
51             return i;
52     }return -1;
53 }
54 void createDG(OLGraph &amp;g)
55 {
56     cout &lt;&lt; &quot;顶点数、弧数、有无信息&quot; &lt;&lt; endl;
57     int hasInfo;
58     cin &gt;&gt; g.vexnum &gt;&gt;g.arcnum &gt;&gt; hasInfo;
59     int i,j,k;
60     cout &lt;&lt; &quot;顶点:&quot; &lt;&lt; endl;
61     for (i=0;i&lt;g.vexnum;i++)
62     {
63         cin &gt;&gt; g.olist[i].data;
64         g.olist[i].firstin = NULL;
65         g.olist[i].firstout = NULL;
66     }
67     cout &lt;&lt; &quot;弧：&quot;&lt;&lt;endl;
68     vertexType v1,v2;
69     arcNode *p;
70     for (k = 0;k&lt;g.arcnum;k++)
71     {
72         cin &gt;&gt; v1 &gt;&gt; v2;a
73         i = locate(g,v1);
74         j = locate(g,v2);
75         p-&gt;tailvex = i;
76         p-&gt;headvex = j;
77         if (hasInfo)
78             cin &gt;&gt; p-&gt;info;
79         p-&gt;tlink = g.olist[i].firstout;
80         g.olist[i].firstout = p;
81         // 至此完成邻接表的工作，十字链表即为邻接表+逆邻接表的结合体
82         p-&gt;hlink = g.olist[j].firstin;
83         g.olist[j].firstin = p;
84     }
85 }
86 int main()
87 {
88 
89 
90 
91     return 0;
92 }
</code></pre><h4 id="邻接多重表表示法"><a href="#邻接多重表表示法" class="headerlink" title="邻接多重表表示法"></a>邻接多重表表示法</h4><pre><code> 1 /*
 2 * 范围：第七章 图
 3 * 日期：2018/4/1
 4 */
 5 
 6 /*
 7 笔记：
 8 enum &lt; 枚举类型名&gt; {&lt; 枚举表&gt;};
 9 enum day {Sun,Mon,Tue,Wed,Thu,Fri,Sat};
10 day d1,d2,d3;
11 d1 = Thu; d2 = Sat; d3 = Tue;
12 定义为枚举类型的变量，只能取枚举表中的值,枚举的本质是整型类型。
13 */
14 #include &lt;iostream&gt;
15 #include &lt;string&gt;
16 #include &lt;stdlib.h&gt;
17 
18 
19 using namespace std;
20 // 邻接多重表 无向图的存储形式
21 const int MAXSIZE = 20;
22 typedef char vertexType;
23 
24 typedef struct eNode
25 {
26     bool mark;
27     int ivex,jvex;
28     struct eNode *ilink,*jlink; // ilink 指向依附于ivex的边
29 }eNode;
30 
31 typedef struct VNode
32 {
33     vertexType data;
34     struct eNode *firstedge;
35 }VNode;
36 
37 typedef struct
38 {
39     VNode adjmulist[MAXSIZE];
40     int vexnum,edgenum;
41 }AMLGraph;
42 
43 void createAMLGraph(AMLGraph &amp;g)
44 {
45     cout &lt;&lt; &quot;顶点数、边数、有无信息&quot;&lt;&lt;endl;
46     int hasInfo;
47     cin &gt;&gt; g.vexnum &gt;&gt; g.edgenum &gt;&gt; hasInfo;
48 
49     int i,j,k;
50     for (i=0;i&lt;g.vexnum;i++)
51     {
52         cin &gt;&gt; g.adjmulist[i].data;
53         g.adjmulist[i].firstedge = NULL;
54     }
55 
56     eNode *p;
57     vertexType v1,v2;
58     for (k=0;k&lt;g.edgenum;k++)
59     {
60         cin &gt;&gt; v1 &gt;&gt; v2;
61         i = locate(g,v1);
62         j = locate(g,v2);
63         p = (eNode *)malloc(sizeof(eNode));
64         p-&gt;ivex = i;
65         p-&gt;jvex = j;
66         p-&gt;ilink = g.adjmulist[i].firstedge;
67         p-&gt;jlink = g.adjmulist[j].firstedge;
68         g.adjmulist[i].firstedge = p;
69         g.adjmulist[j].firstedge = p;
70     }
71 }
72 int main()
73 {
74 
75 
76 
77     return 0;
78 }
</code></pre><h4 id="无向图的连通分量和生成树"><a href="#无向图的连通分量和生成树" class="headerlink" title="无向图的连通分量和生成树"></a>无向图的连通分量和生成树</h4><pre><code>  1 /*
  2 * 7.4 知识点
  3 * 1. 遍历无向图时，对于连通图，从任一顶点出发进行深度或广度优先搜索即可；对于非联通图则需要从
  4 * 多个顶点出发进行搜索，每次获得的顶点序列则为各个连通分量的顶点集。
  5 * 2. 连通图有深度优先生成树和广度优先生成树，即搜索的路径形成的树。
  6 * 3. 非连通图每个连通分量均可形成一个生成树，即一个生成森林。
  7 * 4. 除了二叉树外的没有叉数限制的树一般用孩子-兄弟表示法表示成方便遍历的二叉树形式。
  8 * 5. 森林的树的根节点其实亦为兄弟，也可以用孩子-兄弟表示法来表示。
  9 */
 10 // 无向图的深度优先生成森林（非连通图）
 11 
 12 typedef char Elemtype;
 13 typedef struct CSNode
 14 {
 15     Elemtype data;
 16     struct CSNode *child,*sibling;
 17 }CSNode,*CSTree;
 18 
 19 
 20 void DFSTree(ALGraph &amp;g,CSTree &amp;t,int v)
 21 {
 22     // 从v顶点开始深度搜索生成树
 23     visited[v] = true;
 24     cout &lt;&lt;g.adjList[v].data &lt;&lt; &#39; &#39;;
 25     CSTree p,q;
 26     bool isfirst = true;
 27     for (int w = firstAdjVex(g,v) ; w&gt;=0 ; w = nextAdjVex(g,v,w))
 28     {
 29         if (!visited[w])
 30         {
 31          p = (CSTree)malloc(sizeof(CSNode));
 32          p-&gt;data = g.adjList[w].data;
 33          p-&gt;child = NULL;
 34          p-&gt;sibling = NULL;
 35          // 创建新节点P作为根节点T的邻接点，但必须确定是第一个邻接点还是其他
 36          if (isfirst)
 37          {
 38              t-&gt;child = p;
 39              isfirst = false;
 40          }else
 41          {
 42              q-&gt;sibling = p;
 43          }
 44          q = p;
 45          DFSTree(g,p,w); // 递归寻找p的邻接点们！
 46 
 47         }
 48     }
 49 }
 50 void DFSForest(ALGraph &amp;g,CSTree &amp;t)
 51 {
 52     for (int i=0;i&lt;g.vexnum;i++)
 53         visited[i] = false;
 54     CSTree p,q;
 55     for (int i=0;i&lt;g.vexnum;i++)
 56     {
 57         if (!visited[i])
 58         {
 59             p = (CSTree)malloc(sizeof(CSNode));
 60             p-&gt;data = g.adjList[i].data;
 61             p-&gt;child = NULL;
 62             p-&gt;sibling = NULL;
 63             if (!t)
 64             {
 65                 t = p; // 第一棵生成树
 66             }else
 67             {
 68                 q-&gt;sibling = p; // 非第一棵生成树，则为上一棵生成树根节点的兄弟
 69             }
 70             q = p;
 71             DFSTree(g,p,i);// 从i顶点出发建立以p为根节点的生成子树
 72         }
 73     }
 74 
 75 
 76 }
 77 void level(CSTree &amp;t)
 78 {
 79     queue&lt;CSTree&gt; q;
 80     CSTree p;
 81     if (t) // 空树没有必要遍历了
 82     {
 83         q.push(t); // 根节点入队
 84         while (!q.empty())
 85         {
 86            p =  q.front(); // 弹栈一个元素
 87            q.pop();
 88             cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;;
 89 
 90             if (p-&gt;child)
 91             {
 92                 q.push(p-&gt;child);
 93             }
 94             if (p-&gt;sibling)
 95             {
 96                 q.push(p-&gt;sibling);
 97             }
 98         }
 99     }
100 }
</code></pre><h5 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h5><p>3<br>13 13 0<br>ABCDEFGHIJKLM<br>A C<br>A F<br>A L<br>A B<br>B M<br>D E<br>G H<br>G K<br>G I<br>H K<br>J L<br>J M<br>M L</p>
<h4 id="最小生成树-之-普利姆算法"><a href="#最小生成树-之-普利姆算法" class="headerlink" title="最小生成树 之 普利姆算法"></a>最小生成树 之 普利姆算法</h4><pre><code> 1 struct
 2 {
 3     vertexType adjvex;
 4     vrType lowcost;
 5 }closedge[MAXSIZE];
 6 // 辅助数组的意义：记录从U到V-U中具有最小代价的边
 7 
 8 int locateVex(MGraph &amp;g,vertexType v)
 9 {
10     int k = -1;
11     for (int i = 0 ;i&lt;g.vexnum;i++)
12     {
13         if (g.vex[i] == v)
14             k = i;
15             return k;
16     }
17     return k;
18 }
19 
20 int minimum(MGraph &amp;g)
21 {
22     int min1 = INFINITY;
23     int k = -1;
24 
25     for (int i = 0;i&lt;g.vexnum;i++)
26     {
27         if ( closedge[i].lowcost != 0  )
28         {
29             if ( closedge[i].lowcost &lt; min1 )
30             {
31                 min1 = closedge[i].lowcost;
32                 k = i;
33             }
34         }
35     }
36     return k;
37 }
38 
39 void miniSpanTree_prim(MGraph &amp;g,vertexType u)
40 {
41 
42     int k = locate(g,u);
43     for (int i=0;i&lt;g.vexnum;i++)
44     { // closedge 一开始并不包含K
45         if (i != k )
46         {
47             closedge[i].adjvex = u;
48             closedge[i].lowcost = g.arc[k][i].adj;  //不与u邻接的点的lowcost是INFINITY
49         }
50     }
51     closedge[k].lowcost = 0; // 被选入U的顶点的权值均为0
52 
53     for (int i = 1;i&lt;g.vexnum ;i++) // 选择g.vexnum -1此V-U中的顶点，直到U = V为止
54     {
55         // 选择最小的权值，把顶点加入到U中
56         k = minimum(g); // 求出下一个结点K
57         cout &lt;&lt;&quot;( &quot; &lt;&lt;closedge[k].adjvex&lt;&lt;&quot; , &quot;&lt;&lt;g.vex[k]&lt;&lt;&quot; )&quot; &lt;&lt; endl;  // 打印找到的边
58         closedge[k].lowcost = 0; // 把K划入U集合中
59         // 更新closedge
60         for (int j =  0;j&lt;g.vexnum;j++)
61         {
62             if (g.arc[k][j].adj &lt; closedge[j].lowcost)
63             {
64                 closedge[j].adjvex = g.vex[k];
65                 closedge[j].lowcost = g.arc[k][j].adj;
66             }
67         }
68 
69     }
70 }
</code></pre><h5 id="测试数据："><a href="#测试数据：" class="headerlink" title="测试数据："></a>测试数据：</h5><p>3<br>6 10 0<br>ABCDEF<br>A B 6<br>A D 5<br>A C 1<br>B C 5<br>B E 3<br>C D 5<br>C E 6<br>C F 4<br>D F 2<br>E F 6</p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><pre><code> 1 /*
 2 有向无环图的介绍：
 3 1. 有向无环图：描述含有公共子式的工具，实现对相同子式地共享，从而节省存储空间
 4 2. 检查一个有向图是否存在环比无向图复杂。无向图：深度优先遍历过程中遇到已访问过的顶点的边则必定存在环；
 5 有向图：这条回边有可能是指向深度优先生成森林中另一棵生成树顶点的弧。
 6 解决：从某个顶点V出发的遍历，在DFS（V）结束之前出现一条从顶点U到顶点V的回边，有向图上必定存在环。
 7 3. 有向无环图是描述一项工程或系统的进行过程的有效工具。工程可分为若干个活动，活动之间存在条件的约束。
 8 人们关心：1）工程能否顺利完成 2）工程完成所必须的最短时间
 9 
10 拓扑排序：
11 1. 由某个集合上的一个偏序得到该集合的一个全序的过程
12 2. 解释：偏序是指集合中仅有部分成员之间可比较，而全序为集合中全体成员之间均可比较，全序即为拓扑有序
13 3. 由偏序定义得到拓扑有序的操作便是拓扑排序
14 4. 顶点表示活动，弧表示活动之间优先关系的有向图称为顶点表示活动的网AOV网，直接前驱和直接后继
15 5. 在AOV网中不应该出现有向环，因此检测有向网中是否存在环的方法是：构造顶点的拓扑排序序列，若网中的所有顶点都在拓扑有序序列中则必定不存在环。
16 6. 如何进行拓扑排序？在有向图中选择一个没有前驱的顶点且输出，删除该顶点和所有以它为尾的弧
17 
18 */
19 int indegree[MAXSIZE];
20 void findInDegree(ALGraph &amp;g)
21 {
22     ALGraph ng;
23     buildNALG(g,ng);
24     arcNode *p;
25     int d = 0;
26     for (int i=0;i&lt;ng.vexnum;i++)
27     {
28         d = 0;
29         p = ng.adjList[i].firstarc;
30         while (p)
31         {
32             d ++ ;
33             p = p-&gt;nextarc;
34         }
35         indegree[i] = d;
36     }
37 //    for (int i=0;i&lt;g.vexnum;i++)
38 //        cout &lt;&lt;indegree[i] &lt;&lt;  &#39; &#39;;
39 }
40 int  topoLogicalSort(ALGraph &amp;g)
41 {
42     findInDegree(g); // 找到各定点的入度
43     stack&lt;int&gt; st;
44     // 把所有入度为0的顶点入栈
45     for (int i  =0;i&lt;g.vexnum;i++)
46     {
47         if (!indegree[i])
48             st.push(i);
49     }
50     int i;
51     arcNode *p;
52     int count = 0 ; // 对输出顶点计数
53     while (!st.empty())
54     {
55         i = st.top();
56         st.pop();
57         cout &lt;&lt; g.adjList[i].data &lt;&lt; &#39; &#39;;
58         count ++;
59         for (p = g.adjList[i].firstarc ; p ; p=p-&gt;nextarc)
60         {
61             // 对I号顶点的每个邻接点的入度都减1
62             int k = p-&gt;adjvex;
63             if (!(--indegree[k]))
64                 st.push(k); // 若减1后变为入度为0，入栈
65         }
66     }
67     if (count &lt; g.vexnum)
68         return -1;
69     else
70         return 1;
71 }
</code></pre><h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><pre><code> 1 int ve[MAXSIZE]; // 各顶点的最早开始时间
 2 int vl[MAXSIZE]; // 各顶点的最迟开始时间
 3 
 4 /* 
 5 1. 计算各顶点的最早开始时间ve
 6 2. T为拓扑序列顶点栈
 7 3. S为零入度顶点栈
 8 4. 若G无回路，则用栈T返回G的一个拓扑序列
 9 */
10 int topoLogicalOrder(ALGraph &amp;g,stack&lt;int&gt; &amp;t)
11 {
12     findInDegree(g,indegree);
13     stack&lt;int&gt; s;
14     for (int i = 0;i&lt;g.vexnum;i++)
15     {
16         if (!indegree[i])
17             s.push(i);
18     }
19     int count =  0;
20     for (int i=0;i&lt;g.vexnum;i++)
21         ve[i] = 0;
22     while (!s.empty())
23     {
24         int j = s.top();
25         s.pop();
26         t.push(j);
27         count ++ ;
28         for (arcNode *p = g-&gt;adjList[j].firstarc ; p ; p = p-&gt;nextarc)
29         {
30             int k = p-&gt;adjvex;
31             if (!(--indegree[k]))
32                 s.push(k);
33             if (ve[j]+*(p-&gt;info) &gt; ve[k])
34                 ve[k] = ve[j] + *(p-&gt;info);
35         }
36     }
37     if (count &lt;g.vexnum)
38         return -1;
39     else return 1;
40 }
41 
42 // 关键路径
43 int criticalPath(ALGraph &amp;g)
44 {
45     // 目的：输出G的各项关键活动
46     stack&lt;int&gt; t;
47     arcNode *p;
48     if (!topoLogicalOrder(g,t))
49         return -1;
50     for (int i=0;i&lt;g.vexnum;i++)
51         vl[i] = ve[g.vexnum-1] ; // 初始化均为最大值
52     while (!t.empty())
53     {
54         int j = t.top();
55         t.pop();
56         for (p = g.adjList[j].firstarc ; p ; p= p-&gt;nextarc)
57         {
58             int k = p-&gt;adjvex;
59             dut = *(p-&gt;info);
60             if (vl[k]-dut &lt; vl[j])
61                 vl[j] = vl[k] - dut;
62         }
63     }
64     for (j = 0;j&lt;g.vexnum;j++)
65     {
66         for (p = g.adjList[i].firstarc ; p;p=p-&gt;nextarc)
67         {
68             int k = p-&gt;adjvex;
69             dut = *(p-&gt;info);
70             int ee = ve[j];
71             el = vl[k] - dut;
72             tag = (ee == el) &gt; 
73 
74         }
75     }
76 
77 
78 
79 }
</code></pre><h4 id="最短路径-迪杰斯特拉"><a href="#最短路径-迪杰斯特拉" class="headerlink" title="最短路径-迪杰斯特拉"></a>最短路径-迪杰斯特拉</h4><pre><code> 1 /* 最短路径
 2 1. 交通路网上从原点A到达目的地B的所含边的数目最少的路径，只需要广度优先搜索，遇到B点时停止
 3 2. 源点到其余各个顶点的最短路径--迪杰斯特拉算法--按照路径长度递增的次序产生最短路径的算法
 4 3. 求从源点v0到其余各点v的最短路径P[v]和带权长度d[v]
 5 4. p[v][w] == true, 则w是v0 - v 上最短路径的一个顶点，该路径显然经过v0 和 v\
 6 5. final[v]为已经归入点集合的点
 7 */
 8 bool p[MAXSIZE][MAXSIZE];
 9 int d[MAXSIZE];
10 bool final[MAXSIZE];
11 
12 void shortestPath(MGraph &amp;g,int v0)
13 {
14 
15     for (int i=0;i&lt;g.vexnum;i++)
16     {
17         final[i] = false;
18         d[i] = g.arc[v0][i].adj;
19         for (int j = 0;j&lt;g.vexnum;j++)
20             p[i][j] = false;
21 
22         if (d[i]!=INFINITY)
23         {
24             p[i][i] = true;
25             p[i][v0] = true;
26         }
27     }
28     final[v0] = true;
29     d[v0] = 0;
30     int v;
31     int min = INFINITY;
32     for (int i=1;i &lt; g.vexnum;i++)
33     { // 对其余的g.vexnum - 1个顶点，每次选择最短的一条路径的顶点加入final集合
34         min = INFINITY;
35         for (int j=0;j&lt;g.vexnum;j++)
36             if (!final[j])
37             if (d[j] &lt; min)
38         {
39             min = d[j];
40             v = j; // v是此次选出的顶点
41         }
42         final[v] = true;
43         // 更新最短路径及距离
44         for (int j = 0;j&lt;g.vexnum;j++)
45         {
46             if (!final[j] &amp;&amp; d[j] &gt; (g.arc[v][j].adj + min)) //此处注意INFINIT + INT 不会小于 INFINIT，因为已经到了能存储的最大数
47             {
48                 d[j] = min + g.arc[v][j].adj;
49                 for (int k = 0;k&lt;g.vexnum;k++)
50                     p[j][k] = p[v][k];
51                 p[j][j] = true;
52             }
53         }
54     }
55 }
56 
57 void printShortestPath(MGraph &amp;g)
58 {
59     int i;
60     for (i = 1;i&lt;g.vexnum;i++)
61     {
62         cout &lt;&lt; g.vex[i] &lt;&lt; &quot;\t&quot;&lt;&lt;&#39;(&#39;;
63         for (int j = 0;j&lt;g.vexnum;j++)
64             if (p[i][j])
65             cout &lt;&lt; g.vex[j] &lt;&lt;&#39; &#39; ;
66         cout &lt;&lt; &#39;)&#39;&lt;&lt;&quot;\t&quot; ;
67         cout &lt;&lt; d[i] &lt;&lt;endl;
68     }
69 }
</code></pre><h5 id="测试数据-1"><a href="#测试数据-1" class="headerlink" title="测试数据"></a>测试数据</h5><p>// 迪杰特斯拉<br>1<br>6 8 0<br>ABCDEF<br>A C 10<br>A E 30<br>A F 100<br>B C 5<br>C D 50<br>E D 20<br>E F 60<br>D F 10</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构（严版）课本代码重敲——第九十章" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构（严版）课本代码重敲——第九十章/">数据结构（严版）课本代码重敲——第九十章</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构（严版）课本代码重敲——第九十章/" class="article-date">
  <time datetime="2018-08-20T17:31:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编程笔记-数据结构-第九十章"><a href="#编程笔记-数据结构-第九十章" class="headerlink" title="编程笔记 数据结构 第九十章"></a>编程笔记 数据结构 第九十章</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #include &lt;stack&gt;
  6 using namespace std;
  7 /*
  8     日期：2018/4/17
  9     题目：二叉搜索树
 10 */
 11 typedef int Elemtype;
 12 typedef struct BSTNode
 13 {
 14     int key;
 15     Elemtype data;
 16     struct BSTNode *lchild,*rchild;
 17 }BSTNode,*BSTree;
 18 
 19 // 1 创建时插入建立二叉搜索树
 20 void insertBSTree(BSTree &amp;t,BSTree &amp;p)
 21 {
 22 
 23     if (t == NULL)
 24     {
 25         t = p; // 根节点为空
 26     }
 27     else {
 28         if (p-&gt;data &gt;= t-&gt;data)
 29             insertBSTree(t-&gt;rchild,p);
 30         else
 31             insertBSTree(t-&gt;lchild,p);
 32     }
 33 
 34 
 35 }
 36 void createBSTree(BSTree &amp;t)
 37 {
 38     Elemtype x;
 39     BSTree p;
 40     int n ;
 41     cout&lt;&lt; &quot;请输入N和待排序的数据&quot;&lt;&lt; endl;
 42     cin &gt;&gt; n;
 43     for (int i = 0;i&lt;n;i++)
 44     {
 45         cin &gt;&gt; x;
 46         p = (BSTree)malloc(sizeof(BSTNode));
 47         p-&gt;data = x;
 48         p-&gt;key = i+1;
 49         p-&gt;lchild = NULL;
 50         p-&gt;rchild = NULL;
 51         insertBSTree(t,p);
 52     }
 53 
 54 }
 55 // 中序遍历
 56 void inOrder(BSTree t)
 57 {
 58     if (t)
 59     {
 60        inOrder(t-&gt;lchild);
 61        cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;;
 62        inOrder(t-&gt;rchild);
 63     }
 64 }
 65 
 66 // 查找
 67 int searchBSTree(BSTree &amp;t,Elemtype data)
 68 {
 69     if (t)
 70     {
 71         if (data == t-&gt;data)
 72             return t-&gt;key;
 73         else if (data &gt; t-&gt;data)
 74             searchBSTree(t-&gt;rchild,data);
 75         else
 76             searchBSTree(t-&gt;lchild,data);
 77     }else
 78     return 0;
 79 }
 80 // 动态树表：树结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于
 81 // 给定值得结点时再进行插入，新插入的结点一定是叶子结点。
 82 
 83 int searchBSTree_dynamic(BSTree t,Elemtype data,BSTree &amp;p,BSTree &amp;f)
 84 {
 85     if (t)
 86     {
 87         if (t-&gt;data == data)
 88         {
 89             p = t;
 90             return 1;
 91         }
 92         else
 93         {
 94             if (t-&gt;data &gt; data)
 95                 searchBSTree_dynamic(t-&gt;lchild,data,p,t);
 96             else
 97                 searchBSTree_dynamic(t-&gt;rchild,data,p,t);
 98         }
 99 
100     }
101     else
102     {
103         p = f;
104         return 0;
105     }
106 
107 }
108 void insertBSTree_dynamic(BSTree &amp;t,Elemtype data)
109 {
110     BSTree p=NULL,f = NULL; // p指向查找到的结点，f为未找到是时的父节点
111     BSTree s;
112     if (!searchBSTree_dynamic(t,data,p,f))
113     {
114         s = (BSTree)malloc(sizeof(BSTNode));
115         s-&gt;data = data;
116         s-&gt;lchild = NULL;
117         s-&gt;rchild = NULL;
118         // 在树中没找到时即要插入结点
119         if (p == NULL)
120         {
121             t = s; // t为空二叉树，插入的叶子结点即为根节点的特殊情况
122         }
123         else
124         {
125             if (data &gt; p-&gt;data )
126                 p-&gt;rchild = s;
127             else
128                 p-&gt;lchild = s; // 插入新的叶子结点
129         }
130 
131     }
132 }
133 
134 /*
135 删除节点分为三种情况：
136 1 p的左右子树均空，直接修改父节点指针
137 2 p有一个子树，让该子树成为父节点的左子树
138 3 p的两个子树均不为空
139 递归找到该结点，然后删除
140 
141 */
142 
143 void deleteBST(BSTree &amp;t,Elemtype data)
144 {
145     void deleteB(BSTree&amp;);
146     if (t)
147     {
148         if (t-&gt;data == data)
149         {
150             deleteB(t);
151         }
152         else if (t-&gt;data &gt; data)
153             deleteBST(t-&gt;lchild,data);
154         else
155             deleteBST(t-&gt;rchild,data);
156     }
157 }
158 int deleteB(BSTree &amp;p)
159 {
160     BSTree q,s;
161     if (p-&gt;lchild == NULL &amp;&amp;p-&gt;rchild == NULL)
162     {
163         q = p;
164         p = NULL;
165         free(q);
166     }
167     else
168         if (p-&gt;lchild == NULL)
169         { // 只有左子树空
170             q = p;
171             p = p-&gt;rchild;
172             free(q);
173         }
174         else  // 只有右子树空
175         if (p-&gt;rchild == NULL)
176         {
177             q = p;
178             p = p-&gt;lchild;
179             free(q);
180         }
181         else // 均不空
182         {
183            s = p-&gt;lchild;
184            while (s-&gt;rchild!=NULL)
185                 s = s-&gt;rchild;
186            s -&gt;rchild = p-&gt;rchild;
187            q = p;
188            p = p-&gt;lchild;
189            free(q);
190         }
191 }
192 // delete 和 free 的的区别？
193 int main()
194 {
195     BSTree t = NULL;
196     //createBSTree(t);
197     int n;
198     Elemtype x;
199     cout &lt;&lt; &quot;n&quot; &lt;&lt; endl;
200     cin &gt;&gt; n ;
201     for (int i=0;i&lt;n;i++)
202     {
203         cin &gt;&gt; x;
204         insertBSTree_dynamic(t,x);
205     }
206     inOrder(t);
207     cout &lt;&lt; &quot;请输入要删除的数据&quot; &lt;&lt;endl;
208     cin &gt;&gt; x;
209     deleteBST(t,x);
210     inOrder(t);
211 
212 
213     return 0;
214 }
</code></pre><h4 id="二叉搜索树的复习"><a href="#二叉搜索树的复习" class="headerlink" title="二叉搜索树的复习"></a>二叉搜索树的复习</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #include &lt;stack&gt;
  6 using namespace std;
  7 /* 二叉搜索树 复习
  8 1. 创建+插入
  9 2. 搜索
 10 3. 删除
 11 4. 遍历
 12 */
 13 
 14 typedef struct BSTNode
 15 {
 16     int key;
 17     struct BSTNode *lchild,*rchild;
 18 }BSTNode,*BSTree;
 19 
 20 int insertBSTree(BSTree &amp;t,BSTree &amp;p)
 21 {
 22     // 如果找到则返回指向关键字的指针，否则插入到树中
 23     if (t== NULL)
 24     {
 25         t = p;
 26         return 1;
 27     }else
 28     {
 29         if (t-&gt;key == p-&gt;key)
 30         {
 31             return 1;
 32         }else if (t-&gt;key &gt; p-&gt;key)
 33             insertBSTree(t-&gt;lchild,p);
 34         else
 35             insertBSTree(t-&gt;rchild,p);
 36     }
 37 }
 38 void createBSTree(BSTree &amp;t)
 39 {
 40     t = NULL;
 41     int n;
 42     cout &lt;&lt; &quot;请输入N：&quot; &lt;&lt;endl;
 43     cin &gt;&gt; n;
 44     cout &lt;&lt; &quot;请输入N个数&quot; &lt;&lt; endl;
 45     int key;
 46     for (int i=0;i&lt;n;i++)
 47     {
 48         cin &gt;&gt; key;
 49         BSTree p = (BSTree)malloc(sizeof(BSTNode));
 50         p-&gt;key = key;
 51         p-&gt;lchild = NULL;
 52         p-&gt;rchild  = NULL;
 53         insertBSTree(t,p);
 54     }
 55 }
 56 
 57 void preOrder(BSTree T)
 58 {
 59     if (T)
 60     {
 61         preOrder(T-&gt;lchild);
 62         cout &lt;&lt; T-&gt;key &lt;&lt; &quot; &quot;;
 63         preOrder(T-&gt;rchild);
 64     }
 65 }
 66 
 67 void deleteT(BSTree &amp;p)
 68 {
 69     BSTree q;
 70     // 删除P指向的结点
 71     if (p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL )
 72     {
 73         q = p;
 74         p = NULL;
 75         free(q);
 76         return ;
 77     }
 78     if (p-&gt;lchild == NULL)
 79     {
 80         q = p;
 81         p = p-&gt;rchild;
 82         free(q); // free 和 delete 的区别
 83         // malloc - free C new - delete C++
 84     }
 85     else if (p-&gt;rchild == NULL)
 86     {
 87         q = p;
 88         p = p -&gt;lchild;
 89         free(q);
 90     }
 91     else
 92     {
 93         // 左右子树均不为空时，P左子树的最右侧的结点+P的右子树
 94         BSTree s = p-&gt;lchild;
 95         while (s-&gt;rchild != NULL)
 96             s = s-&gt;rchild;
 97         s-&gt;rchild = p-&gt;rchild;
 98         q = p;
 99         p = p-&gt;lchild;
100         free(q);
101 
102     }
103 }
104 void deleteBSTNode(BSTree &amp;t,int key)
105 {
106     if (t)
107     {
108         // t为空时则为未找到
109         if (t-&gt;key == key)
110             deleteT(t);
111         else if (t-&gt;key &gt; key)
112             deleteBSTNode(t-&gt;lchild,key);
113         else
114             deleteBSTNode(t-&gt;rchild,key);
115     }
116 
117 }
118 int main()
119 {
120     BSTree t;
121     createBSTree(t);
122     preOrder(t);
123     cout &lt;&lt; &quot;key:&quot; &lt;&lt; endl;
124     int key;
125     cin &gt;&gt; key;
126     deleteBSTNode(t,key);
127     preOrder(t);
128 
129 
130     return 0;
131 }
</code></pre><h4 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;string.h&gt;
 3 #include &lt;stdio.h&gt;
 4 #include &lt;stdlib.h&gt;
 5 #include &lt;stack&gt;
 6 #define SUCCESS 1
 7 #define UNSUCCESS -1
 8 #define NULLkey -65519
 9 
10 
11 using namespace std;
12 /*
13 哈希表
14 */
15 const int HashLength = 20;
16 typedef int Elemtype;
17 typedef struct
18 {
19     Elemtype *elem;
20     int count; // 当前元素个数
21 }HashTable;
22 
23 void initHashTable(HashTable &amp;h)
24 {
25     h.elem = (Elemtype *)malloc(sizeof(Elemtype)*HashLength);
26     h.count = 0;
27     for (int i = 0;i&lt;HashLength;i++)
28         h.elem[i] = NULLkey;
29 }
30 
31 int hash_f(int key)
32 {
33     return key%HashLength;
34 }
35 void insertHashTable(HashTable &amp;h,int key)
36 {
37     int addr = hash_f(key);
38     while (h.elem[addr]!= NULLkey)
39     {
40         addr = (addr+1)%HashLength;
41     }
42     h.elem[addr] = key;
43     h.count++;
44 }
45 int searchHashTable(HashTable h,int key)
46 {
47     // 查找成功返回存储位置否则返回UNSUCCESS
48     int addr = hash_f(key);
49     while (h.elem[addr]!=key)
50     {
51         addr = (addr+1)%HashLength;
52         if (h.elem[addr] == NULLkey || addr == hash_f(key))
53             return UNSUCCESS;
54         // 如果线性探测再散列到NULLKEY或者转了一圈重新回到起点则没找到
55     }
56 
57     return addr;
58 }
59 int main()
60 {
61     int a[] = {14,1,68,27,55,19,20,84,79,23,11,10};
62     HashTable h;
63     initHashTable(h);
64     for (int i = 0;i&lt;12;i++ )
65         insertHashTable(h,a[i]);
66     for (int i=0;i&lt;12;i++)
67     {
68         int addr = searchHashTable(h,a[i]);
69         cout &lt;&lt; a[i] &lt;&lt; &quot; : &quot; &lt;&lt; addr &lt;&lt; endl;
70     }
71 
72 
73     return 0;
74 }
</code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>分类：<br>1 插入类<br>- 直接插入<br>- 折半插入<br>- 希尔排序<br>2 交换类<br>- 冒泡排序<br>- 快速排序<br>3 选择排序<br>- 简单选择排序<br>- 堆排序<br>4 归并类<br>- 归并排序<br>5 基数排序</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #include &lt;stack&gt;
  6 #define SUCCESS 1
  7 #define UNSUCCESS -1
  8 #define NULLkey = -65519
  9 
 10 
 11 using namespace std;
 12 /*
 13 排序
 14 */
 15 // 直接插入排序:每次都是在一个有序的序列中插入一个新的关键字
 16 void insertSort(int r[],int n) // 待排序关键字存储在1-n的位置
 17 {
 18     /*
 19     时间复杂度：
 20     1 最好情况：仅有外层循环 O(n)
 21     2 最坏情况：n*(n-1)/2 O(n^2)
 22     空间复杂度：
 23     辅助存储空间仅有temp，故为O(1)
 24     */
 25     int temp;
 26     for (int i=1;i&lt;=n;i++)
 27     {
 28         temp = r[i];// 存放待插入关键字
 29         int j = i-1;
 30         while (r[j] &gt; temp &amp;&amp; j &gt; 0)
 31         {
 32             r[j+1] = r[j];
 33             j--;
 34         }
 35         r[j+1] = temp;
 36 
 37     }
 38 }
 39 
 40 void binsertSort(int r[],int n)
 41 {
 42     /*
 43     和直接插入排序的区别是：查找插入位置所花的时间大大减小
 44     */
 45     for (int i=1;i&lt;=n;i++) // i = 1 时已经为有序数列
 46     {
 47         r[0] = r[i] ; // r[0] 空余空间中存放当前待插入关键字
 48         int low = 1,high = i-1; // 当前的有序序列为1-i-1;
 49         while (low &lt;= high)
 50         {
 51             int mid = (low + high)/2;
 52             if (r[mid] &gt;= r[0])
 53             {
 54                 high = mid-1;
 55             }
 56             else
 57                 low = mid+1;
 58         }
 59         // 之所以让low = high时再进入循环：比较当前关键字和high/low指向关键字的大小
 60         // 离开循环时low = high+1，low指向位置即为待移动的位置
 61         for (int j=i-1;j&gt;=low;j--)
 62             r[j+1] = r[j];
 63         r[low] = r[0];
 64 
 65     }
 66 }
 67 // 希尔排序
 68 void shellInsert(int r[],int n,int dlta)
 69 {
 70     int j;
 71     for (int i = 1+dlta; i&lt;=n ; i++)
 72     { // 循环 n - 1 - dlta 次 = 子序列的个数
 73         if (r[i] &lt; r[i-dlta])
 74         {
 75             r[0] = r[i];
 76             for (j = i-dlta ; j&gt;0 &amp;&amp; r[j] &gt; r[0] ; j = j-dlta )
 77                 r[j+dlta] = r[j];
 78             r[j+dlta] = r[0];
 79         }
 80     }
 81 }
 82 void shellSort(int r[],int dlta[],int n,int t )
 83 {
 84     /*
 85     缩小增量排序：对r[n]进行增量为dlta[t]的排序过程
 86     思想：直接插入排序适合基本有序的序列，希尔排序的每趟排序都会使整个序列变得更加有序，
 87     等整个序列基本有序后，最后进行一趟直接插入排序，效率会更高。
 88     注意：1.希尔排序是不稳定的。
 89     2.增量序列的最后一个值一定取1，增量序列中的值尽量没有除1之外的公因子
 90     */
 91     for (int i = 0;i&lt;t;i++)
 92     {
 93         shellInsert(r,n,dlta[i]);
 94     }
 95 }
 96 void bubbleSort(int r[],int n)
 97 {
 98     /*
 99     外层比较n-1次，内层比较n-i次
100     时间复杂度：O(N^2)
101     空间复杂度：O(1)
102     */
103     int flag;
104     for (int i = 1;i&lt;n;i++)
105     {
106         flag = true;
107         for (int j = 1;j&lt;=n-i;j++)
108         {
109             if (r[j] &gt; r[j+1])
110             {
111                 int temp = r[j];
112                 r[j] = r[j+1];
113                 r[j+1] = temp;
114                 flag = false;
115             }
116         }
117         if (flag) // 没发生交换说明有序
118             break;
119     }
120 }
121 // 快速排序之合并版
122 /*
123 通常，快速排序是同量级O(nlogn)的排序方法中，平均性能最好。
124 但若初始记录序列按关键字有序或基本有序时，快速排序将退化为起泡排序。
125 空间复杂度：栈
126 */
127 void quickSort(int r[],int low,int high)
128 {
129     int i = low,j = high;
130     if (low &lt; high)
131     {
132         while (i&lt;j)
133         {
134             r[0] = r[low];//枢纽
135             while (r[j]&gt;r[0] &amp;&amp; i &lt; j)
136                 j -- ;
137             if (i &lt; j)
138             {
139                 // 此时r[j] &lt; r[0] 交换
140                 r[i] = r[j];
141                 i++;
142             }
143             while (i &lt; j &amp;&amp; r[i] &lt; r[0] )
144                 i++;
145             if (i&lt;j)
146             {
147                 r[j] = r[i];
148                 j--;
149             }
150         }
151         r[i] = r[0];// 将枢纽定在最终位置
152         quickSort(r,low,i-1);
153         quickSort(r,j+1,high);
154     }
155 }
156 
157 // 快速排序之分离版
158 int Partition(int r[],int low,int high)
159 {
160     while (low&lt;high)
161     {
162         r[0] = r[low];
163         while (low &lt; high &amp;&amp; r[high] &gt; r[0]  )
164             high -- ;
165         if (low &lt; high)
166         {
167             r[low] = r[high];
168             low++;
169         }
170         while (low&lt;high &amp;&amp; r[low] &lt; r[0])
171             low++;
172         if (low &lt;high)
173         {
174             r[high] = r[low];
175             high--;
176         }
177     }
178     r[low] = r[0];
179     return r[0];
180 }
181 void qsort(int r[],int low,int high)
182 {
183     if (low &lt; high)
184     {
185         int flag = Partition(r,low,high); // 一分为二并得到枢纽
186         qsort(r,low,flag -1);
187         qsort(r,flag+1,high);
188     }
189 }
190 void print(int r[],int n)
191 {
192     for (int i=1;i&lt;=n;i++)
193         cout &lt;&lt; r[i] &lt;&lt;&#39; &#39;;
194     cout &lt;&lt; endl;
195 }
196 // 简单选择排序
197 void selectSort(int r[],int n)
198 {
199     int i,j,k;
200     for (i=1;i&lt;=n-1;i++)
201     {
202         k = i;
203         for (j=i;j&lt;=n;j++)
204         {
205             if (r[j]&lt;r[k])
206             {
207                 k = j;
208             }
209         }
210         if (k!=i)
211         {
212             r[0] = r[i];
213             r[i] = r[k];
214             r[k] = r[0];
215         }
216     }
217 }
218 /*
219 堆排序：定义：非叶子结点的值都不大于（或不小于）其左右孩子结点的值。
220 将无序序列调整为完全二叉树形式的堆，根节点为最大值或最小值。
221 通过堆找到最大最小值后放在队列的尾部，将无序队列调整为有序队列。
222 
223 执行过程：
224 1 层次遍历法建立初始堆，找到第一个非叶子结点，按照从右往左，从下往上的顺序，
225 依次判断是否满足堆定义（假设为大顶堆，即孩子结点的数值是否都小于根节点）。
226 如不满足则选择孩子中较大的结点和根节点交换，同时判断下移的根节点的值是否满足定义。
227 2 将当前无序序列的第一个值和最后一个值交换，有序序列中增加一个值。判断和根节点交换的
228 新节点是否满足堆定义并进行调整。
229 
230 时间复杂度：
231 */
232 void shift(int r[],int low,int high)
233 {
234     int temp = r[low];
235     int i = low,j = 2*i;
236     while (j&lt;=high)
237     {
238         if (j&lt;high &amp;&amp; r[j] &lt; r[j+1])
239         {
240             j = j+1; // 选择I节点的孩子中较大的一个
241         }
242         if (temp &lt; r[j])
243         {
244             r[i] = r[j];
245             i = j;
246             j = j*2;
247         }
248         else
249             break;
250     }
251     r[i] = temp;
252 }
253 void heapSort(int r[],int n)
254 {
255     // 1. 找到最后一个非终端节点，从右向左，从下向上进行调整,建立初始堆
256     int i;
257     for (i = n/2; i &gt;=1 ;i--)
258     {
259         shift(r,i,n);
260     }
261     // 2. 将一次调整后的最大值和无序序列的最后一个值交换
262     for (i = n;i&gt;=2;i--) // 进行n-1次排序
263     {
264         r[0] = r[1];
265         r[1] = r[i];// r[i]为最后一个
266         r[i] = r[0];
267         shift(r,1,i-1);//在减小了一个关键字的无序序列中进行调整
268     }
269 
270 }
271 int main()
272 {
273     int n ;
274     cin &gt;&gt; n;
275     int r[n];
276     for (int i=1;i&lt;=n;i++)
277         cin &gt;&gt;r[i];
278     //insertSort(r,n);
279     //binsertSort(r,n);
280 //    bubbleSort(r,n);
281     //quickSort(r,1,n);
282 //    selectSort(r,n);
283 heapSort(r,n);
284     print(r,n);
285 
286 
287 
288 
289     return 0;
290 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构题集(C语言版 清华大学出版社)" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数据结构题集(C语言版 清华大学出版社)/">数据结构题集(C语言版 清华大学出版社)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数据结构题集(C语言版 清华大学出版社)/" class="article-date">
  <time datetime="2018-08-20T17:29:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据结构-第六章-树"><a href="#数据结构-第六章-树" class="headerlink" title="数据结构 第六章 树"></a>数据结构 第六章 树</h3><blockquote>
<p>清华大学出版社数据结构习题集 第六章 树 整理</p>
</blockquote>
<p><img src="https://img-
blog.csdn.net/20180329205953437?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<blockquote>
<p>输入数据<br> 13<br> 1 2 3 0 0 1 0 0 0 0 0 0 1<br> 6</p>
</blockquote>
<pre><code> 1 // 35 顺序存储结构
 2 const int MAXSIZE = 20;
 3 typedef struct
 4 {
 5     Elemtype data[MAXSIZE+1]; // data[0]不存储元素，因为顺序存储结构二叉树的根节点从1开始层次遍历+1
 6     int length;
 7 }SqBiTree;
 8 void createSqBiTree(SqBiTree &amp;st)
 9 {
10     Elemtype x;
11     int n;
12     cout &lt;&lt; &quot;n:&quot;;
13     cin &gt;&gt; n;
14     for  (int i = 0;i&lt;n;i++)
15     {
16         cin&gt;&gt;x;
17         st.data[i+1] = x;
18     }
19     st.length = n;
20 }
21 void print(SqBiTree &amp;st)
22 {
23     for (int i=1;i&lt;=st.length;i++)
24         cout &lt;&lt; st.data[i]&lt;&lt;&#39; &#39;;
25 }
26 // 求出下标志为I的结点对应的十进制整数
27 // 思路：parent = i/2,如果为偶数则为0，奇数则为1
28 int thirty_five(SqBiTree &amp;st,int i)
29 {
30     int sum  =0;
31     int j = 0;
32     while (i)
33     {
34         if (i%2!=0)
35         {
36             sum += pow(2,j);
37         }
38         j++;
39         i = i/2;
40     }
41     return sum;
42 }
43 int main()
44 {
45     SqBiTree st ;
46     createSqBiTree(st);
47     cout &lt;&lt; &quot;i:&quot;;
48     int i;cin&gt;&gt;i;
49     cout &lt;&lt; &quot;十进制整数：&quot;&lt;&lt;thirty_five(st,i)&lt;&lt;endl;
50     return 0;
51 }
</code></pre><p><img src="https://img-
blog.csdn.net/20180329211146926?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code> 1 // 36 判定两棵二叉树是否相似
 2 int similar(BiTree &amp;t1,BiTree &amp;t2)
 3 {
 4     if (t1==NULL &amp;&amp; t2==NULL)
 5         return 1;
 6     if (t1!=NULL &amp;&amp; t2!=NULL)
 7     {
 8         int l = similar(t1-&gt;lchild,t2-&gt;lchild);
 9         int r = similar(t1-&gt;rchild,t2-&gt;rchild);
10         return l&amp;r;
11     }else
12     return 0;
13 }
14 int main()
15 {
16     BiTree t1,t2;
17     createBiTree(t1);
18     createBiTree(t2);
19     if (similar(t1,t2))
20         cout &lt;&lt;&quot;similar!&quot;&lt;&lt;endl;
21     else
22         cout &lt;&lt;&quot;not similar!&quot;&lt;&lt;endl;
23     return 0;
24 }
</code></pre><p><img src="https://img-
blog.csdn.net/20180330122922857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code> 1 // 39 增设双亲域和标志域时不用栈进行后序遍历的递推形式
 2 typedef struct NBiNode
 3 {
 4     Elemtype data;
 5     struct NBiNode *lchild,*rchild,*parent;
 6     int mark;// 0 1 2
 7 }NBiNode,*NBiTree;
 8 void createNBiTree(NBiTree &amp;nt,NBiTree &amp;parent)
 9 {
10     Elemtype x;
11     cin &gt;&gt; x;
12     if (x!=&#39;#&#39;)
13     {
14         nt = (NBiTree)malloc(sizeof(NBiTree));
15         nt-&gt;data = x;
16         nt-&gt;mark = 0;
17         nt-&gt;parent = parent;
18         createNBiTree(nt-&gt;lchild,nt);
19         createNBiTree(nt-&gt;rchild,nt);
20     }
21     else
22     {
23         nt = NULL;
24     }
25 }
26 /*
27 思路：
28 1. 从parent走到当前子树根节点，Mark为0，转为1
29 2. Mark为1时：转到左子树，设Mark为2
30 3. Mark为2时转到右子树，设Mark为0哦，访问结点
31 */
32 void postOrderUnWithPM(NBiTree &amp;t)
33 {
34     NBiTree p = t;
35     while (p){
36        switch(p-&gt;mark)
37     {
38     case 0:
39         // 第一次访问P结点
40         p-&gt;mark  =1;
41         if (p-&gt;lchild)
42             p = p-&gt;lchild;
43         break;
44     case 1:
45         // 第二次访问P结点
46         p-&gt;mark = 2;
47         if (p-&gt;rchild)
48             p = p-&gt;rchild;
49         break;
50     case 2:
51         // 访问右结点结束后需要打印根节点
52         cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;;
53         p-&gt;mark = 0;
54         p = p-&gt; parent;
55         break;
56     }
57     }
58 
59 }
60 int main()
61 {
62     NBiTree nt;
63     NBiTree p;
64     p =NULL;
65     createNBiTree(nt,p);
66     postOrderUnWithPM(nt);
67 
68     return 0;
69 }
</code></pre><p><img src="https://img-
blog.csdn.net/20180330174103391?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code> 1 // 40 只设双亲域不用栈如何中序遍历
 2 typedef struct NBiNode
 3 {
 4     Elemtype data;
 5     struct NBiNode *lchild,*rchild,*parent;
 6 }NBiNode,*NBiTree;
 7 void createNBiTree(NBiTree &amp;nt,NBiTree &amp;parent)
 8 {
 9     Elemtype x;
10     cin &gt;&gt; x;
11     if (x!=&#39;#&#39;)
12     {
13         nt = (NBiTree)malloc(sizeof(NBiTree));
14         nt-&gt;data = x;
15         nt-&gt;parent = parent;
16         createNBiTree(nt-&gt;lchild,nt);
17         createNBiTree(nt-&gt;rchild,nt);
18     }
19     else
20     {
21         nt = NULL;
22     }
23 }
24 
25 
26 void midOrder(NBiTree &amp;nt)
27 {
28     NBiTree p = nt;
29     while (p)
30     {
31         if (p-&gt;lchild)
32         {
33             p = p-&gt;lchild;
34         }
35         else
36         {
37             cout &lt;&lt; p-&gt;data &lt;&lt;&#39; &#39;; // 从左子树回到根节点，打印根节点；此时根据右子树是否为空进行判断
38             while (!p-&gt;rchild)
39             {//右子树为空，两种情况，1. 双亲的左子树：往上走，打印结点；2 双亲的右子树，不必打印
40                  while (p-&gt;parent &amp;&amp; p-&gt;parent-&gt;rchild == p)
41                  {
42                      p = p-&gt;parent;
43                  }
44                  if (p-&gt;parent)
45                  {
46                      if (p-&gt;parent-&gt;lchild == p)
47                      {
48                          p = p-&gt;parent;
49                          cout &lt;&lt; p-&gt;data &lt;&lt; &#39; &#39;; // 走到根节点又要判断右子树是否为空
50                      }
51                  }else
52                  {
53                      return ;// 右子树的双亲为空，那就是中序遍历完啦！
54                  }
55             }
56             // 右子树不为空，往右走
57             p = p-&gt;rchild;
58 
59         }
60     }
61 }
62 
63 int main()
64 {
65     NBiTree nt;
66     NBiTree p;
67     p =NULL;
68     createNBiTree(nt,p);
69     midOrder(nt);
70     return 0;
71 }
</code></pre><p><img src="https://img-
blog.csdn.net/20180330190728785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code> 1 // 45 
 2 // 递归，对于二叉树中的每一个元素值为X的结点，删去以他为根的子树，并释放相应空间
 3 // 递归清空子树
 4 void delete2(BiTree &amp;t)
 5 {
 6     if (!t) return ;
 7     if (t-&gt;lchild)
 8         delete2(t-&gt;lchild);
 9     if (t-&gt;rchild)
10         delete2(t-&gt;rchild);
11     delete t;
12     t = NULL; // 
13 }
14 void deleteBiTree(BiTree &amp;t,Elemtype x)
15 {
16     if (t)
17     {
18         if (t-&gt;data == x ) // string.h 和 string 这真的是两个头文件！
19             delete2(t);
20         else { // 如果删除了左右孩子就都没有了！★
21         deleteBiTree(t-&gt;lchild,x);
22         deleteBiTree(t-&gt;rchild,x);
23         }
24     }
25 }
26 
27 int main()
28 {
29     BiTree t;
30     createBiTree(t);
31     Elemtype x;
32     cout &lt;&lt; &quot;x:&quot;;
33     cin &gt;&gt; x;
34     deleteBiTree(t,x);
35     preOrder(t);
36     return 0;
37 }
</code></pre><p><img src="https://img-
blog.csdn.net/20180330200735646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code> 1 // 48 求两节点的共同祖先
 2 // 找到root到P的路径存到数组中
 3 // 思路：比较根节点和P指针是否相同，若相同返回1已找到；否则压入根节点，判断左右子树能否找到该结点并返回1
 4 // 如果左右子树均没有找到也就意味着该路径上没有P结点（走错路啦！）弹栈出根节点
 5 int findPath(BiTree &amp;root,Elemtype &amp;p,BiTree a[],int &amp;top)
 6 {
 7     if (root-&gt;data == p )
 8         return 1; // 先比较根节点：相等则返回1，说明找到p,但此时路径数组为空，说明没有祖先
 9     a[++top] = root; // 根节点入栈
10     int has = 0;
11     if (root-&gt;lchild)
12         has = findPath(root-&gt;lchild,p,a,top);
13     if (has == 0 &amp;&amp; root-&gt;rchild)
14         has = findPath(root-&gt;rchild,p,a,top);
15     if (has == 0)
16     {
17         top -- ;
18     }
19     return has;
20 }
21 
22 BiTree findGrandpa(BiTree &amp;root,Elemtype p,Elemtype q)
23 {
24     int top1 = -1,top2 = -1; // TOP 指向a,b的顶层
25     // 存储两节点的路径到数组中，寻找相同的最靠右的部分
26     BiTree a[20]={};
27     BiTree b[20]={};
28     if (findPath(root,p,a,top1)!=0 &amp;&amp; findPath(root,q,b,top2)!=0)
29     {
30         for (int i = top1;i&gt;-1;i--)
31             for (int j = top2;j&gt;-1;j--)
32             if (a[i]== b[j])
33                 return a[i];
34     }
35 }
36 int main()
37 {
38     BiTree t;
39     createBiTree(t);
40     Elemtype p,q;
41     cout &lt;&lt;&quot;p,q:&quot;;
42     cin &gt;&gt; p &gt;&gt; q;
43     BiTree grand = findGrandpa(t,p,q);
44     cout &lt;&lt; &quot;grandpa : &quot; &lt;&lt; grand-&gt;data &lt;&lt;endl;
45     return 0;
46 }
</code></pre><h4 id="判断一棵二叉树是否是完全二叉树"><a href="#判断一棵二叉树是否是完全二叉树" class="headerlink" title="判断一棵二叉树是否是完全二叉树"></a>判断一棵二叉树是否是完全二叉树</h4><p>我们要如何判断一棵二叉树是否是完全二叉树？？？<br>1）如果一个结点有右孩子而没有左孩子，那么这棵树一定不是完全二叉树。<br>2）如果一个结点有左孩子，而没有右孩子，那么按照层序遍历的结果，这个结点之后的所有结点都是叶子结点这棵树才是完全二叉树。<br>3）如果一个结点是叶子结点，那么按照层序遍历的结果，这个结点之后的所有结点都必须是叶子结点这棵树才是完全二叉树。<br>求一棵二叉树的层序遍历，我们借助的是数据结构—-<br>队列。如果一个结点不是叶子结点，我们将当前结点出队，将其孩子入队；如果一个结点是叶子结点，我们直接将其出队即可。这是之前求一棵树层序遍历的结果的思路，我们可以借助这个思路，来完成此题。<br>根据上边分析的2）和3），我们知道，如果一个结点没有左右孩子或者仅有左孩子，它之后的结点必须全部是叶子结点，这棵树才可能是完全二叉树。所以，我们必须定义一个bool变量，来记录是否到了满足2）或者3）的结点，如果满足，我们只需要判断它之后的结点是否是叶子结点即可。</p>
<pre><code> 1 // 49 编写算法判定给定二叉树是否为完全二叉树
 2 /*
 3 1. 层次搜索
 4 2. 设一个布尔数组记录访问过的结点，检查数组中是否有false
 5 3. 递归算法：给出完全二叉树与原定义等价的递归定义，设计一个判别给定的二叉树是满二叉树、不满二叉树还是非完全二叉树的递归函数
 6 
 7 */
 8 const int Maxsize = 20;
 9 // 2. 检查数据中是否有false
10 bool isFull(BiTree &amp;t)
11 {
12     BiTree  que[Maxsize];
13     int front = 0,rear = 0;
14     BiTree p;
15     Elemtype data[Maxsize] = {};
16     int i = 0;
17     if (t)
18     {
19         rear = (rear + 1)%Maxsize;
20         que[rear] = t;
21         data[i] = t-&gt;data;
22         while (front != rear)
23         {
24             front = (front+1)%Maxsize;
25             p = que[front];
26             if (p-&gt;lchild)
27             {
28                 rear = (rear+1)%Maxsize;
29                 que[rear]=p-&gt;lchild;
30                 data[++i] = p-&gt;lchild-&gt;data;
31             } // 有左子树则放入数据否则放入零
32             else
33                 data[++i] = 0;
34             if (p-&gt;rchild)
35             {
36                 rear = (rear+1)%Maxsize;
37                 que[rear]=p-&gt;rchild;
38                 data[++i] = p-&gt;rchild-&gt;data;
39             }
40             else
41                 data[++i] = 0;
42 
43         }
44         for (int j = 1;j&lt;i;j++)
45     { // 检查是否有字母夹着单个0的情况，因为最后也都是0
46         if (data[j-1]!=0 &amp;&amp; data[j+1]!=0 &amp;&amp; data[j] == 0)
47             return false;
48     }
49     }
50     return true;
51 }
52 
53 // 用一个数组记录遍历过得结点序号，看是否连续
54 bool isFull2(BiTree &amp;t)
55 {
56     int i=0,j=0;
57     BiTree que[Maxsize] = {}; // front
58     int order[Maxsize] = {}; // j i
59     BiTree p;
60     int front = 0,rear = 0;
61     if (t)
62     {
63         que[++rear] = t;
64         order[++i] = ++j; // order[1] = 1 根节点序号
65         while (front != rear)
66         {
67             p = que[++front];
68             if (order[i]!= order[i-1]+1) // 结点序号不连续
69                 return false;
70             if (p-&gt;lchild)
71             {
72                 que[++rear] = p-&gt;lchild;
73                 order[++i] = 2*p-&gt;data;
74             }
75             if (p-&gt;rchild)
76             {
77                 que[++rear] = p-&gt;rchild;
78                 order[++i] = 2*p-&gt;data+1;
79             }
80         }
81         return 1 ;
82     }
83 }
84 int main()
85 {
86     BiTree t;
87     createBiTree(t);
88     cout &lt;&lt; isFull2(t)&lt;&lt; endl;
89     return 0;
90 }
</code></pre><p><img src="https://img-
blog.csdn.net/20180331114415955?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODQ2MDU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code>  1 // 50
  2 /*
  3 1. 三元组序列 (F, C, L/R)
  4 2. ^代表根节点的双亲
  5 3. ^^代表输入终点
  6 4. 层次表示输入
  7 */
  8 BiTree three()
  9 {
 10     Elemtype thr[3];
 11     BiTree que[Maxsize];
 12     int front = 0,rear =0;
 13     BiTree t,p,q;
 14     cin &gt;&gt; thr[0] &gt;&gt;thr[1] &gt;&gt; thr[2];
 15     while (thr[0]!=&#39;^&#39; || thr[1]!=&#39;^&#39;)
 16     {
 17         if (thr[0] == &#39;^&#39; )
 18         {
 19             t = (BiTree )malloc(sizeof(BiTree));
 20             t-&gt;data = thr[1];
 21             t-&gt;lchild = NULL;
 22             t-&gt;rchild = NULL;
 23             que[++rear] = t; // 根节点入队
 24             p = t;
 25             front = 1;
 26         }
 27         else
 28         {
 29             if (thr[2] == &#39;L&#39;)
 30             {
 31                 p-&gt;lchild = q;
 32             }
 33             if (thr[2]==&#39;R&#39;)
 34             {
 35                 p-&gt;rchild = q;
 36             }
 37         }
 38 
 39         cin &gt;&gt; thr[0] &gt;&gt; thr[1] &gt;&gt; thr[2];
 40         q = (BiTree)malloc(sizeof(BiTree));
 41         q-&gt;data = thr[1];
 42         q-&gt;lchild  = NULL;
 43         q-&gt;rchild = NULL;
 44         que[++rear] = q;
 45         // 每输入一组，便把数据入队
 46         if (thr[0] != p-&gt;data)
 47         {
 48             // 出队
 49             p = que[++front];
 50         }
 51 
 52     }
 53     return t;
 54 }
 55 int main()
 56 {
 57     BiTree t;
 58     t = three();
 59     preOrder(t);
 60 
 61     return 0;
 62 }
 63 //51 输出以二叉树表示的算数表达式，如果右括号在输出时应添上
 64 bool isOperator(Elemtype c)
 65 {
 66     if (c==&#39;+&#39; || c==&#39;-&#39; || c==&#39;*&#39; || c==&#39;/&#39;)
 67         return true;
 68     else
 69         return false;
 70 }
 71 bool lowPrior(Elemtype a,Elemtype b)
 72 {
 73     if ((a == &#39;+&#39; || a == &#39;-&#39;)&amp;&amp;(b==&#39;*&#39; || b == &#39;/&#39;))
 74         return true;
 75     else
 76         return false;
 77 }
 78 void biao(BiTree &amp;t)
 79 {
 80     if (t)
 81     {
 82         if (t-&gt;lchild)
 83         {
 84             if (isOperator(t-&gt;lchild-&gt;data) &amp;&amp; lowPrior(t-&gt;lchild-&gt;data,t-&gt;data))
 85             {
 86                 // 如果左孩子是操作符并且优先级低于根节点
 87                 cout &lt;&lt; &#39;(&#39; &lt;&lt; &#39; &#39;;
 88                 biao(t-&gt;lchild);
 89                 cout &lt;&lt;&#39;)&#39; &lt;&lt; &#39; &#39;;
 90             }
 91             else
 92                 biao(t-&gt;lchild);
 93         }
 94 
 95         cout &lt;&lt; t-&gt;data &lt;&lt; &#39; &#39;;
 96 
 97         if (t-&gt;rchild)
 98         {
 99             if (isOperator(t-&gt;rchild-&gt;data) &amp;&amp; lowPrior(t-&gt;rchild-&gt;data,t-&gt;data))
100             {
101                 // 如果左孩子是操作符并且优先级低于根节点
102                 cout &lt;&lt; &#39;(&#39; &lt;&lt; &#39; &#39;;
103                 biao(t-&gt;rchild);
104                 cout &lt;&lt;&#39;)&#39; &lt;&lt; &#39; &#39;;
105             }
106             else
107                 biao(t-&gt;rchild);
108         }
109     }
110 }
111 
112 int main()
113 {
114     BiTree t;
115     createBiTree(t);
116     preOrder(t);
117     // biao(t);
118 
119     return 0;
120 }
121 // 52 一棵二叉树的繁茂度定义为各层节点数的最大值与树的高度的乘积
122 
123 int fanmao(BiTree &amp;t)
124 {
125     int level,v,i,j;
126     float f;
127     int maxrow,maxcol ; // 最大行和最大列
128     BiTree que[Maxsize] =  {}; // 队列
129     int order[Maxsize] = {};// 存放各节点序号
130     int count[Maxsize] ={};//下标代表层，数组内容为各层结点个数
131     v = 0;i = 0;j = 0;maxcol = 0;maxrow = 0;
132     if (t)
133     {
134         que[j] = t;
135         order[j] = 1;
136         j ++ ;
137         while (i&lt;j)
138         {
139             f = log(order[i])/log(2) ;
140         // 将 x 的自然对数值除以 n 的自然对数值，就可以对任意底 n 来计算数值 x 的对数值：Logn(x) = Log(x) / Log(n)
141             level = (int)f +1 ;// 当前i节点的层数
142             if (maxrow &lt; level)
143                 maxrow = level;
144             count[level] ++;
145             // 求出每个节点当前层数，使当前层数的数据++
146             if (maxcol &lt;count[level])
147                 maxcol = count[level];
148 
149             if (que[i]-&gt;lchild)
150             {
151                 que[j] = que[i]-&gt;lchild;
152                 order[j] = 2*order[i] ;// i是双亲节点，j是子节点
153                 j++;
154             }
155             if (que[i]-&gt;rchild)
156             {
157                 que[j] = que[i]-&gt;rchild;
158                 order[j] = 2*order[i]+1;
159                 j++;
160             }
161             i++;
162         }
163     }
164     v = maxcol * maxrow;
165     return v;
166 }
167 int main()
168 {
169     BiTree t;
170     createBiTree(t);
171     cout &lt;&lt; fanmao(t);
172 
173 
174     return 0;
175 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 John Doe 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>