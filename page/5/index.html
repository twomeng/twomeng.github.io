<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-数字三角形" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/数字三角形/">数字三角形</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/数字三角形/" class="article-date">
  <time datetime="2018-08-20T17:07:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdlib.h&gt;
  3 using namespace std;
  4 #define MAX 100
  5 // 数字三角形问题 方法一：递归求解
  6 // execution time 13.681s
  7 /*
  8 解题思路：
  9 1. 用二维数组存放数字三角形
 10 2. d[i][j]:第i行第j个数字
 11 3. maxSum(i,j)：从d[i][j]到底边的各条路径中，最佳路径的数字之和
 12 4. 对d[i][j]来说有两条可走路径：
 13     （1）d[i+1][j]
 14     （2）d[i+1][j+1]
 15 5. 递归条件
 16     （1）如果i==num,maxSum(i,j)=d[i][j]
 17     （2）否则，maxSum(i,j)=max{ maxSum(i＋1,j),maxSum(i+1,j+1) } + d[i][j]
 18 */
 19 int d[MAX][MAX];
 20 int num;
 21 int maxSum(int i, int j){
 22     if(i == num)
 23         return d[i][j];
 24     int x = maxSum(i+1, j);
 25     int y = maxSum(i+1, j+1);
 26     return max(x,y) + d[i][j];
 27 }
 28 
 29 int main()
 30 {
 31     int i,j;
 32     cin &gt;&gt; num; //输入数字三角形的行数
 33     for(i = 1; i &lt;= num; i ++)
 34         for(j = 1; j &lt;= i; j ++)
 35             cin &gt;&gt; d[i][j];
 36     // 输入三角形矩阵，注意从（1,1）开始
 37     cout &lt;&lt; maxSum(1,1) &lt;&lt; endl;
 38     // maxSum(i,j)代表从d[i,j]向下的路径中最大的和
 39     return 0;
 40 }
 41 #include &lt;iostream&gt;
 42 #include &lt;stdlib.h&gt;
 43 #include &lt;string.h&gt;
 44 #define MAX 100
 45 using namespace std;
 46 // 数字三角形问题 方法二：记忆递归动态规划求解
 47 // execution time 15.280s
 48 int d[MAX][MAX];
 49 int D[MAX][MAX]; //记忆矩阵
 50 int num;
 51 
 52 int maxSum(int i, int j){
 53     if (D[i][j]!=-1)
 54     return D[i][j];
 55     if(i == num)
 56         D[i][j]=d[i][j];
 57     else
 58     {
 59     int x = maxSum(i+1, j);
 60     int y = maxSum(i+1, j+1);
 61     D[i][j]=max(x,y)+d[i][j];
 62     }
 63 
 64     return D[i][j];
 65 }
 66 
 67 int main()
 68 {
 69     int i,j;
 70     cin &gt;&gt; num; //输入数字三角形的行数
 71     for(i = 1; i &lt;= num; i ++)
 72         for(j = 1; j &lt;= i; j ++)
 73             cin &gt;&gt; d[i][j];
 74     // 输入三角形矩阵，注意从（1,1）开始
 75     memset(D,-1,sizeof(D));
 76     /*
 77     功能：
 78     将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值，
 79     块的大小由第三个参数指定，
 80     这个函数通常为新申请的内存做初始化工作。
 81     用法：void *memset(void *s, char ch, unsigned n);
 82     */
 83     cout &lt;&lt; maxSum(1,1) &lt;&lt; endl;
 84     // maxSum(i,j)代表从d[i,j]向下的路径中最大的和
 85     return 0;
 86 }
 87 
 88 #include &lt;iostream&gt;
 89 #include &lt;stdlib.h&gt;
 90 #include &lt;string.h&gt;
 91 #define MAX 100
 92 using namespace std;
 93 // 数字三角形问题 方法三：递推型动态规划求解
 94 // execution time 18.216s
 95 /*
 96 解题思路：
 97 从底向上递推，出最后一行外，每一行的每个点的最大值等于自身加上下面一行对应左右两个点的最大值。
 98 从下往上递推，最顶部的即所求。
 99 */
100 int d[MAX][MAX];
101 int num;
102 
103 int maxSum(int num){
104     int i, j;
105     for(i = num - 1; i &gt;= 1; i --)
106         for(j = 1; j &lt;= i; j ++){
107             d[i][j] = max(d[i+1][j],d[i+1][j+1]) + d[i][j];
108         }
109     return d[1][1];
110 }
111 
112 int main()
113 {
114     int i,j;
115     cin &gt;&gt; num; //输入数字三角形的行数
116     for(i = 1; i &lt;= num; i ++)
117         for(j = 1; j &lt;= i; j ++)
118             cin &gt;&gt; d[i][j];
119     // 输入三角形矩阵，注意从（1,1）开始
120     cout &lt;&lt; maxSum(num) &lt;&lt; endl;
121     return 0;
122 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-博客搬家记" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/博客搬家记/">博客搬家记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/博客搬家记/" class="article-date">
  <time datetime="2018-08-14T06:33:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>2018-08-14 22:28:57</p>
<p>CSDN的用户体验感觉变差，今天写OJ的时候忽然进入到一个大一ACMer、未来的女程序媛的cnblog，才发现自己所做的那点努力根本算不上什么，我本可以更加拼命的。学习计算机本不是一件枯燥无味的事情，我就应该把更多的精力用在编程和学习计算机知识上面。从现在开始，真正地爱上我的本行，用最大的努力去达到你的目标！</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-台式机+笔记本的扩展模式+远程登录设置" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/台式机+笔记本的扩展模式+远程登录设置/">台式机+笔记本的扩展模式+远程登录设置</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/台式机+笔记本的扩展模式+远程登录设置/" class="article-date">
  <time datetime="2018-08-14T03:11:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设备："><a href="#设备：" class="headerlink" title="设备："></a>设备：</h2><ul>
<li>一个Intel(R) Core(TM) i5-4590 CPU @ 3.30GH 3.30 GHz的台式机（内网连接，win10）</li>
<li>一台Intel(R) Core(TM) i5-7200 CPU @ 2.50GH 2.71 GHz的HP笔记本（无线WIFI，win10）</li>
<li>HMDI转VGA转换器</li>
</ul>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>如果使用两套设备，那就得两个鼠标+两个键盘，我的桌子就要炸炸炸了！ 那么怎么通过一台机器远程另一台机器的方式，在两个显示器上操作自如呢？</p>
<h2 id="连接图："><a href="#连接图：" class="headerlink" title="连接图："></a>连接图：</h2><p><img src="http://img.blog.csdn.net/20171004114626054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="双显示屏扩展模式设置："><a href="#双显示屏扩展模式设置：" class="headerlink" title="双显示屏扩展模式设置："></a>双显示屏扩展模式设置：</h2><ol>
<li>因为笔记本只有HDMI接口，台式机为DVI接口，为了连接两个显示器，购买了HMDI转VGA的转换器，淘宝上也不贵。贴个链接：</li>
</ol>
<p><a href="https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.5.4bffb4c87hlxae&amp;id=544504349885&amp;skuId=3461438095282&amp;areaId=230100&amp;user_id=806855806&amp;cat_id=50926003&amp;is_b=1&amp;rn=262e529ee7d8bc134f5d4699918741d4" target="_blank" rel="noopener">HDMI转VGA转换器</a></p>
<ol>
<li><p>连接好线之后，正常情况下应该与第一台显示器显示内容一样，即为”复制模式”，如果不是，请检查线的连接情况或者排除显卡故障问题。</p>
</li>
<li><p>将”复制模式”更改成”扩展模式”：</p>
</li>
</ol>
<p>桌面右键 -&gt;英特尔显卡设置 -&gt; 显示器 -&gt; 多屏显示 -&gt; 扩展桌面</p>
<p><img src="http://img.blog.csdn.net/20171004115921478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>注意：<br>1. 主显示器为笔记本的内置显示器<br>2. 显示器排列位置应与硬件连接方位相符</p>
<ol>
<li><p>或者 win+p : 点击扩展</p>
</li>
<li><p>这个时候我们就可以在两台显示器之间灵活操作了。本质上相当于扩大了现有笔记本的桌面范围，所以我的第二台显示器上是没有任何图标（除了下方栏）的。我们需要在第一台显示器上打开一个文件，拖拽到第二台显示器上面，然后就可以同时在两个桌面上搞事情啦~ </p>
</li>
</ol>
<h2 id="下方的一台机器怎么办？"><a href="#下方的一台机器怎么办？" class="headerlink" title="下方的一台机器怎么办？"></a>下方的一台机器怎么办？</h2><p>通过笔记本与下方机器的远程连接，可以控制两台机器。这个远程窗口就放在第二台显示器上面，用的时候点开即可。</p>
<ol>
<li>设置远程连接</li>
</ol>
<p>此电脑 -&gt; 属性 -&gt; 远程设置 -&gt; 允许远程连接到此电脑</p>
<p><img src="http://img.blog.csdn.net/20171004121352429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ol>
<li>被远程机器需要设置永不睡眠： </li>
</ol>
<p>设置 -&gt; 系统 -&gt; 电源和睡眠 -&gt; 从不睡眠</p>
<p><img src="http://img.blog.csdn.net/20171004121633533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ol>
<li>远程连接：</li>
</ol>
<pre><code>win+R 
mstsc
</code></pre><p><img src="http://img.blog.csdn.net/20171004121015623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里注意，如果想耳机插在下面的机器上而不是笔记本上，需要设置远程音频，不然你是听不到下面机器的呼唤的啦！ ：</p>
<p><img src="http://img.blog.csdn.net/20171004121057077?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ol>
<li>现在就可以愉快地玩啦~ 左屏看视频，右屏玩游戏！ </li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Hadoop 集群搭建以及脚本撰写" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/Hadoop 集群搭建以及脚本撰写/">Hadoop 集群搭建以及脚本撰写</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/Hadoop 集群搭建以及脚本撰写/" class="article-date">
  <time datetime="2018-08-14T03:07:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>sudo adduser hadoop sudo
</code></pre><h2 id="创建Hadoop用户"><a href="#创建Hadoop用户" class="headerlink" title="创建Hadoop用户"></a>创建Hadoop用户</h2><p>首先按 ctrl+alt+t 打开终端窗口，输入如下命令创建新用户 :</p>
<pre><code>sudo useradd -m hadoop -s /bin/bash





这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。 
</code></pre><p>接着使用如下命令设置密码，可简单设置为 hadoop，按提示输入两次密码：</p>
<pre><code>1 sudo passwd hadoop





可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题：


最后注销当前用户（点击屏幕右上角的齿轮，选择注销），在登陆界面使用刚创建的 hadoop 用户进行登陆。
</code></pre><h2 id="更新apt"><a href="#更新apt" class="headerlink" title="更新apt"></a>更新apt</h2><p>用 hadoop 用户登录后，我们先更新一下 apt，后续我们使用 apt 安装软件，如果没更新可能有一些软件安装不了。按 ctrl+alt+t<br>打开终端窗口，执行如下命令：</p>
<pre><code>sudo apt-get update





然鹅很讨人厌的是，终端提示：


hadoop 不在 sudoers 文件中。此事将被报告。





一通儿百度之后，解释为：sudo命令可以让你以root身份执行命令，来完成一些我们这个帐号完成不了的任务。 
</code></pre><p>其实并非所有用户都能够执行sudo，因为有权限的用户都在/etc/sudoers中。<br>解决方法为：<br>首先，su - 进入root权限<br>然后，我们可以通过编辑器来打开/etc/sudoers，或者直接使用命令visudo来搞定这件事情。<br>打开sudoers后，像如下那样加上自己的帐号保存后就可以了。</p>
<pre><code>User privilege specification  
root        ALL=(ALL:ALL) ALL  
hadoop  ALL=(ALL:ALL) ALL  #此行为添加行
</code></pre><p>然鹅又整出幺蛾子了，在hadoop用户中一旦输入任何与sudo有关的需要root权限的命令，就开始提示我：</p>
<pre><code>hadoop 不在 sudoers 文件中。此事将被报告。





！！这不就变成死循环了么，解决该问题的过程中又出现了该问题。但是其实是我傻，只需要切换到原来的用户中，通过vim编辑器修改sudoers只读文件，再切回到hadoop用户即可。
</code></pre><p>在原用户中：</p>
<pre><code>$ sudo su 
# cd /etc
# cat sudoers //打开文件，发现只有一行root ALL=(ALL:ALL) ALL 于是安装了一下vim
# vim sudoers //修改成上面那样子
</code></pre><p>vim 中的操作：</p>
<pre><code>hadoop  ALL=(ALL:ALL) ALL  //此行为添加行，因为是只读文件，不能通过gedit编辑器来直接修改，还需要root权限才能搞动它。同时会各种提示&quot;确定要修改只读文件么？&quot;哎呀忽略它就好。
按ESC+:wq! //注意这里要+！才能强制修改只读文件的内容，到这里文件就修改好啦！不放心的话可以再cat sudoers查看一下文件权限是否已经修改成功
</code></pre><p>现在我们切回hadoop用户，输入</p>
<pre><code>$ sudo su
</code></pre><p>发现没有问题啦！<br>继续输入：</p>
<pre><code>#　sudo apt-get update 
</code></pre><p>完成apt的更新。</p>
<h2 id="安装SSH、配置SSH无密码登陆"><a href="#安装SSH、配置SSH无密码登陆" class="headerlink" title="安装SSH、配置SSH无密码登陆"></a>安装SSH、配置SSH无密码登陆</h2><p>集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH<br>client，此外还需要安装 SSH server：</p>
<pre><code>$ sudo apt-get install openssh-server





安装后，可以使用如下命令登陆本机：


ssh localhost
</code></pre><p>终端询问：are u sure u want to continue connecting ,输入yes</p>
<p><img src="http://img.blog.csdn.net/20170603141958330?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。</p>
<p>首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：</p>
<pre><code>$ exit                           # 退出刚才的 ssh localhost,提示注销
                                 # Connection to localhost closed.
$ cd ~/.ssh/                     # 若没有该目录，请先执行一次ssh localhost
$ ssh-keygen -t rsa              # 会有提示，都按回车就可以
</code></pre><p><strong>~的含义<br>在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如你的用户名为 hadoop，则 ~ 就代表<br>“/home/hadoop/“。 此外，命令中的 # 后面的文字是注释。</strong><br>显示：<br><img src="http://img.blog.csdn.net/20170603142318772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最后：</p>
<pre><code>$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys  # 加入授权





此时再输入：


ssh localhost





便无需输入密码了： 
</code></pre><p><img src="http://img.blog.csdn.net/20170603142457806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h2><p>安装JDK的过程看似非常简单，但是没有考虑到我是在当前hadoop用户下安装，结果这个用户又跟在上一步骤一样给我整出了若干幺蛾子。。还好最后成功解决了问题，谢天谢地。。</p>
<p><strong>1、解压源码包</strong><br>通过终端在/usr/lib 目录下新建jdk文件夹，命令行：</p>
<pre><code>sudo mkdir /usr/lib/jdk





然后将下载到压缩包拷贝到Java文件夹中，命令行： 
</code></pre><p>进入jdk源码包所在目录</p>
<pre><code>cp jdk-8u131-linux-x64.tar.gz /usr/lib/jdk





然后进入java目录，命令行：


cd /usr/lib/jdk





解压压缩包，命令行：


sudo tar xvf jdk-8u131-linux-x64.tar.gz
</code></pre><p>然后可以把压缩包删除，命令行：</p>
<pre><code>sudo rm jdk-8u131-linux-x64.tar.gz
</code></pre><p><strong>2、设置jdk环境变量</strong></p>
<p>这里采用全局设置方法，它是是所有用户的共用的环境变量。用vim编辑器或者是gedit都可以。</p>
<pre><code>$sudo gedit ~/.bashrc





打开之后在末尾添加


export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_131  #此为jdk在步骤1中安装的路径
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH
</code></pre><p>请记住，在上述添加过程中，等号两侧不要加入空格，不然会出现”不是有效的标识符”，因为source /etc/profile<br>时不能识别多余到空格，会理解为是路径一部分。点击保存，关闭gedit。</p>
<p><strong>3.配置默认JDK版本</strong><br>步骤三须知：如果是在原来的root用户下，不需要这一步直接就出来步骤四的安装结果了。但是我的hadoop用户选手2号实在是不给力，偏偏给出这样子的提示：</p>
<pre><code>程序 &#39;java&#39; 已包含在下列软件包中：


 * default-jre
 * gcj-4.9-jre-headless
 * gcj-5-jre-headless
 * openjdk-8-jre-headless
 * gcj-4.8-jre-headless
 * openjdk-9-jre-headless
</code></pre><p>这让我白白浪费了一两个小时去解决这个问题呀。因为看到有的博客通过如下命令：</p>
<pre><code>$ sudo apt-get install openjdk-9-jre openjdk-9-jdk





安装openjdk,而不是oracle家的jdk。这里请自行百度两者区别，对我来说安装openjdk的命令貌似更简洁，于是我便开始apt-get install openjdk,但很遗憾的是报出乱七八糟的E：无法解析域名错误，于是我就找到了相关解决方法：&lt;http://www.linuxdiyf.com/linux/504.html&gt;。但是朋友们，这错误是越搞越多啊！
</code></pre><p>就在我准备放弃这一阶段时，转机出现了，感谢下面的博客：<br><a href="http://blog.csdn.net/vicky__rain/article/details/53539437" target="_blank" rel="noopener">http://blog.csdn.net/vicky__rain/article/details/53539437</a><br>于是我便转移到了root用户，离开我们的hadoop选手二号，在niumeng用户选手一号中没有任何问题，我便照着博客中写的如下的四行代码：</p>
<pre><code>sudo update-alternatives  --install /usr/bin/java  java  /usr/lib/jdk/jdk1.8.0_131/bin/java 300
sudo update-alternatives  --install /usr/bin/javac  javac  /usr/lib/jdk/jdk1.8.0_131/bin/javac 300
sudo update-alternatives  --install /usr/bin/jar  jar  /usr/lib/jdk/jdk1.8.0_131/bin/jar 300
sudo update-alternatives  --config   java
</code></pre><p>检查：</p>
<pre><code>sudo update-alternatives  --config   java
</code></pre><p>终于！成功了！！！这件事情告诉我们一个道理：一条死胡同走不通的时候，不妨试一试下一条死胡同。</p>
<p><strong>4、检验是否安装成功</strong><br>在终端输入如下命令</p>
<pre><code>java -version





看看是否安装成功 
</code></pre><p><img src="http://img.blog.csdn.net/20170603160614537?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="安装hadoop３-0-0-alpha3"><a href="#安装hadoop３-0-0-alpha3" class="headerlink" title="安装hadoop３.0.0-alpha3"></a>安装hadoop３.0.0-alpha3</h2><p>将压缩包（hadoop-3.0.0-alpha3.tar.gz）放在”下载”目录下，然后输入命令：</p>
<pre><code>cd ~/下载





进入下载目录，然后输入命令：


sudo tar -zxf hadoop-3.0.0-alpha3.tar.gz -C /usr/local





这样就将文件解压到&quot;/usr/local&quot;路径下，进入该路径：


cd /usr/local/





然后将文件夹名改名为&quot;hadoop&quot;：


sudo mv ./hadoop-3.0.0/ ./hadoop





最后修改文件权限：


sudo chown -R hadoop:hadoop ./hadoop





输入命令查看hadoop是否可用：


/hadoop/bin/hadoop version





如果配置正确此时应该出现hadoop 的版本信息，但是很气人地是提示： 
</code></pre><p><strong>Error:JAVA_HOME is not set and could not be found</strong><br>那好吧，我深吸一口气，既然如此，那就继续搞吧。<br>百度了一下解决方案：<br><a href="http://www.cnblogs.com/codeOfLife/p/5940642.html" target="_blank" rel="noopener">http://www.cnblogs.com/codeOfLife/p/5940642.html</a><br>庆幸地发现输入export的时候我的JAVA_HOME环境变量貌似是我第一遍配置时的信息，果然通过：</p>
<pre><code>gedit ~/.bashrc





发现我的环境变量莫名其妙地不好了，吓得我赶紧重新配置了一小下下。再次输入


$ cd /usr/local/hadoop
$ ./bin/hadoop version
</code></pre><p>注意这里因为已经进到了/usr/local/hadoop文件级中， ./bin/hadoop version便是指的相对路径，它的绝对路径是：<br>/usr/local/hadoop /bin/hadoop version</p>
<p>终于成功啦！</p>
<p><img src="http://img.blog.csdn.net/20170603165700184?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>-<br>因为hadoop3的网上教程比较少，所以我们决定安装hadoop2.7.3,故要先删除原来的hadoop文件夹，然后如法炮制地安装即可。</p>
<pre><code>$ cd /usr/local
$ sudo rm -rf hadoop
$ ls 
</code></pre><p>即成功删除。</p>
<p>补充知识：</p>
<p>Hadoop的集群主要由 NameNode,DataNode,Secondary<br>NameNode,JobTracker,TaskTracker组成.如下图所示:<br><img src="http://img.blog.csdn.net/20170604111236815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>NameNode中记录了文件是如何被拆分成block以及这些block都存储到了那些DateNode节点.NameNode同时保存了文件系统运行的状态信息.<br>DataNode中存储的是被拆分的blocks.Secondary<br>NameNode帮助NameNode收集文件系统运行的状态信息.JobTracker当有任务提交到Hadoop集群的时候负责Job的运行,负责调度多个TaskTracker.TaskTracker负责某一个map或者reduce任务.</p>
<p>创建目录<br>hadoop dfs -mkdir /home<br>上传文件或目录到hdfs<br>hadoop dfs -put hello /<br>hadoop dfs -put hellodir/ /<br>查看目录<br>hadoop dfs -ls /<br>创建一个空文件<br>hadoop dfs -touchz /361way<br>删除一个文件<br>hadoop dfs -rm /361way<br>删除一个目录<br>hadoop dfs -rmr /home<br>重命名<br>hadoop dfs -mv /hello1 /hello2<br>查看文件<br>hadoop dfs -cat /hello<br>将制定目录下的所有内容merge成一个文件，下载到本地<br>hadoop dfs -getmerge /hellodir wa<br>使用du文件和目录大小<br>hadoop dfs -du /<br>将目录拷贝到本地<br>hadoop dfs -copyToLocal /home localdir<br>查看dfs的情况<br>hadoop dfsadmin -report<br>查看正在跑的Java程序<br>jps<br>上面就是Linux使用hadoop dfs命令的方法介绍了，hadoop dfs命令组合各种参数能够实现多种操作，你可以选择一条命令只需看看。</p>
<p>到此，单机集群安装已经完成，经过单机实例测试和伪分布式的实例测试之后（在此省略，请看 <a href="http://www.powerxing.com/install-
hadoop/" target="_blank" rel="noopener">http://www.powerxing.com/install-
hadoop/</a>），我们要尝试着搭建集群了。</p>
<h2 id="硬件环境："><a href="#硬件环境：" class="headerlink" title="硬件环境："></a>硬件环境：</h2><p>五台机器，连接电源线，连接网线到交换机，一台显示器，一个kvm。通过启动盘安装Ubuntu-16.04.02，删除硬盘内所有内容安装。</p>
<p>_tips_ :(学长教的！)<br>安装时如若想节约安装时间，不至于浪费一个下午来安装。可以制作两个启动盘，流水式操作安装。安装一个的时候，点击完所有需要点击的步骤之后，拔掉显示器接头，同时插到另一台机器上，插另一个U盘。过一会回来检查一下刚才那台机器是否安装成功。</p>
<p>注意：<br>在安装时有两个需要特别注意，用户名和机器名，这里统一：<br>用户名：hadoop<br>机器名：依次为master0 ，master1， slave0， slave1， slave2<br>密码：hadoop<br>如果手速太快搞错了，没关系，安装成功之后通过</p>
<pre><code>vim /etc/hostsname





也可以修改主机名 
</code></pre><p>通过创建新用户可以修改用户名。</p>
<h2 id="我们的脚本工作步骤"><a href="#我们的脚本工作步骤" class="headerlink" title="我们的脚本工作步骤"></a>我们的脚本工作步骤</h2><p>因为这里有五台机器，一台一台手动配置总是不太显示的哈。所以这个时候便需要脚本来替我们干活啦！</p>
<p><strong>脚本是什么？</strong></p>
<p>linux shell 编程是什么：<br>shell是一个命令处理器（command<br>processor）——是一个读入并解释你输入的命令的程序。除了是一个命令中断器以外，shell还是一个程序设计语言。你可以编写shell可以解释的程序（被称为源程序），这些源程序可以包含shell程序设计命令等等。shell除了解释命令以外，还有其他工作，它也可以配置和编程。shell拥有自己的语言允许用户编写程序并以一种复杂方式运行。shell编程语言具有许多常用的编程语言的特征，例如：循环和控制结构等。用户可以生成像其他应用程序一样复杂的shell程序。<br>补充说明：简单的说 ： shell<br>是一个交互性命令解释器。shell独立于操作系统，这种设计让用户可以灵活选择适合自己的shell。shell让你在命令行键入命令，经过shell解释后传送给操作系统（内核）执行。</p>
<p><strong>脚本学习阶段</strong></p>
<p>视频信息：<br><a href="https://ke.qq.com/teacher/407021204" target="_blank" rel="noopener">https://ke.qq.com/teacher/407021204</a><br>中的linux下shell编程从入门到精通（完整版）</p>
<p>下面罗列一下用得比较多的东西：<br>概念：<br>1）<br>_shell是什么:_<br>shell是操作系统的最外层（所以叫shell嘛），是一门用C语言编写的程序。shell可以合并编程语言以控制进程和文件，以及启动和控制其他的程序。shell通过提示您输入，向操作系统解释该输入，然后处理来自操作系统的结果。简单来说，shell就是一个用户和操作系统之间的一个命令解释器。shell是用户和linux操作系统之间沟通的桥梁。用户可以输入命令执行，又可以利用shell脚本编程去运行。</p>
<p>_关系：_<br>kernel （内核）- shell（夹在中间的命令解释器） - utilities (使用者-用户)</p>
<p>_常见的shell语言：_<br>sh bash ksh csh ,最常见的是bash(Bourne again shell)，linux系统中集成了bash。</p>
<p>_tip:_<br>chmod +x filename.sh 改变文件的属性（读写权限）<br>./ filename.sh 表示当前目录下的文件</p>
<p>_例子：_<br>下面我们从经典的”hello world”入手，看一看最简单的Shell脚本的模样。</p>
<pre><code>#!/bin/sh
#print hello world in the console window
a = &quot;hello world&quot; #赋值
echo $a # $为取值符号  
</code></pre><p>如果出现混淆的情况，可以使用花括号来区分。</p>
<p>_echo命令介绍：_<br>功能说明：显示文字。<br>语 法：echo [-ne][字符串] / echo [-help][-version]<br>补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。</p>
<p>_tip:_<br>Shell Script是一种弱类型语言，使用变量的时候无需首先声明其类型。新的变量会在本地数据区分配内存进行存储，这个变量归当前的Shell所有，任何子进<br>程都不能访问本地变量。这些变量与环境变量不同，环境变量被存储在另一内存区，叫做用户环境区，这块内存中的变量可以被子进程访问。</p>
<ol>
<li>本地数据区：变量 set :显示本地数据区和用户环境区的变量和取值 unset:删除指定变量当前取值，该值被认为NULL</li>
<li>用户环境区：环境变量 env:显示用户环境区中的变量和取值<br>export :用于将本地数据区中的变量转移到用户环境区</li>
</ol>
<p>_流程控制语句：_<br>if …;then<br>…<br>elif …;then<br>…<br>else<br>…<br>fi<br>fi 为if语句块的结束，是一个特殊的命令，称为空命令，不做任何事。</p>
<p>_条件判断语句：_<br>第三行中的[]表示条件测试，常用的条件测试有下面几种：<br>[ -f “file”]判断file”]判断 file是否是一个文件<br>[ a−lt3]判断a−lt3]判断 a的值是否小于3，同样-gt和-le分别表示大于或小于等于<br>[ -x “file”]判断file”]判断 file是否存在且有可执行权限，同样-r测试文件可读性<br>[ -n “a”]判断变量a”]判断变量 a是否有值，测试空串用-z<br>[ “a”=”a”=” b” ] 判断a和a和 b的取值是否相等<br>[ cond1 -a cond2 ] 判断cond1和cond2是否同时成立，-o表示cond1和cond2有一成立</p>
<p>要注意条件测试部分中的空格。在方括号的两侧都有空格，在-f、-lt、=等符号两侧同样也有空格。如果没有这些空格，Shell解释脚本的时候就会出错。</p>
<p>_参数：_</p>
<pre><code>$ # 表示包括$0在内的命令行参数的个数。在Shell中，脚本名称本身是$0，剩下的依次是$0、$1、$2…、${10}、${11}，等等。$*表示整个参数列表，不包括$0，也就是说不包括文件名的参数列表。





_here 文档：_
</code></pre><p>Shell Script编程中被称为Here文档，Here文档用于将多行文本传递给某一命令<br>Here文档的格式是以&lt;&lt;开始，后跟一个字符串，在 Here文档结束的时候，这个字符串同样也要出现，表示文档结束</p>
<p>_while 语句：_<br>while [ cond1 ] &amp;&amp; { || } [ cond2 ] …; do<br>…<br>done<br>for var in …; do<br>…<br>done<br>for (( cond1; cond2; cond3 )) do<br>…<br>done<br>until [ cond1 ] &amp;&amp; { || } [ cond2 ] …; do<br>…<br>done</p>
<p><strong>脚本实战阶段</strong></p>
<p>脚本功能：<br>1. 实现master机器ssh免密登录到其他机器<br>2. 实现master机器的jdk+hadoop安装以及环境变量的配置<br>3. master发送jdk+hadoop给slave机器并协助他们环境配置<br>4. 测试hadoop是否安装成功</p>
<p>脚本1：auto_2.sh + slave_use.sh<br>实现思路：<br>我们的客户机通过xshell等远程登录工具来登录一台master机器，运行auto_2.sh脚本，根据相应提示输入欲远程连接的机器的IP地址和登录密码，然后master开始产生公钥并加入授权文件，至此，master可以无密码登录到本机；master节点给slave节点发送公钥以及第二个脚本文件slave_use.sh，然后ssh<br>到slave,手动输入”bash<br>slave_use.sh”即可开始运行slave_use.sh，内容为如果没有.ssh文件夹则创建，然后把公钥追缴到授权文件中，输入”exit”即回到auto_2.sh脚本，继续询问：是否还需要免密登录其他机器。</p>
<pre><code>#!/bin/bash 
#author niumeng 
#auto_2.sh
# ssh 远程服务器
#ssh hadoop@&quot;$remote_ip&quot;

# expect 自动输入密码登录master节点，现在客户机操作的是master
#expect &lt;&lt;EOF
#spawn ssh hadoop@&quot;$remote_ip&quot;
#expect &quot;password:&quot;
#send &quot;hadoop\r&quot; 
#expect &quot;*Last login*&quot; 
#interact 
#EOF

# 如果我们有xshell,直接使用xshell模拟终端登录master，不用ssh远程登录


    echo &quot;-------------欢迎操作远程登录脚本：$0-------------&quot;

x=1
user=hadoop

while [ ${x} -eq 1 ]

do
    echo &quot;请输入您要远程登录的服务器相关信息：）&quot;
        echo &quot;登录服务器ip:&quot;
    read remote_ip
    echo &quot;登录服务器pwd:&quot;
    read remote_Password

# 1.master 节点创建公钥
# 如果没有该目录，创建该目录

    if [ ! -d /home/$USER/.ssh ];then
    mkdir ~/.ssh 
    fi

    cd ~/.ssh
# 删除之前生成的公钥

    if [ -f ./id_rsa ];then
    rm -rf ./id_rsa
    fi
    if [ -f ./id_rsa.pub ];then
    rm -rf ./id_rsa.pub
    fi


    ssh-keygen -t rsa 
# 生成公钥
    echo &quot;master节点生成公钥成功！：）&quot;

#----------------------------------------------
#2. master 节点无密码SSH localhost 
    cat ./id_rsa.pub &gt;&gt; ./authorized_keys
# 测试登录本机    
#expect &lt;&lt;EOF
#set timeout -1
#spawn ssh localhost
#expect { 
#&quot;yes/no&quot; { send &quot;yes\r&quot; }
#&quot;password:&quot; { send &quot;hadoop\n&quot; }
# }
#expect eof 
#EOF

        if  [ $? -eq 0 ];then 
    echo &quot;追加授权文件成功！&quot;
    else 
    echo &quot;追加授权文件失败！请查找原因！ &quot;
    fi

#3.将本机密钥发送给slave节点
scp ./id_rsa.pub $user@$remote_ip:/home/$user
# 可用expect省略输入密码部分

if  [ $? -eq 0 ];then 
    echo &quot;发送密钥成功！&quot;
    else 
    echo &quot;发送密钥失败！请查找原因！ &quot;
    fi





#4.把slave节点需要执行的命令文件发送到slave

scp ~/slave_use.sh $user@$remote_ip:/home/$user

if  [ $? -eq 0 ];then 
    echo &quot;发送slave_use.sh成功！&quot;
    else 
    echo &quot;发送slave_use.sh失败！请查找原因！ &quot;
    fi

#5.ssh node 
# 此处可改进为expect自动登录
ssh $user@$remote_ip

#6.end
echo &quot;本台服务器已经成功实现免密登录功能！您是否要继续登录其他机器？&quot;
read -p &quot;yes请输入1/no请输入0：&quot; x

done 


# 如果报错：sign_and_send_pubkey: signing failed: agent refused operation
#执行如下两条语句则可以成功运行！

eval &quot;$(ssh-agent -s)&quot;
ssh-add


#!/bin/bash 
#author niumeng 
#slave_use.sh
# 已经把id_rsa.pub公钥发送到服务器的~/

#在slave上，将公钥加入授权
user=hadoop
    if [ ! -f ~/.ssh ];then 
    mkdir /home/$user/.ssh 
    echo &quot;在slave节点上创建.ssh文件夹成功！&quot;
    fi 

    cat /home/$user/id_rsa.pub &gt;&gt; /home/$user/.ssh/authorized_keys 
    if [ $? -eq 0 ];then 
    echo &quot;公钥加入slave节点授权文件&quot;
    else 
    echo &quot;加入授权文件失败！请查找原因！&quot;
    fi
</code></pre><p>脚本2：<br>目的：在master和slave节点上安装JDK+hadoop，并完成环境变量的配置；以及hadoop配置文件的设置。</p>
<p>step1:<br>auto_install.sh:从客户机上向五台机器上发送JDK+HADOOP的安装包，以及在节点上运行的脚本文件slave_use_install，以及环境变量的配置内容（这个是用来cat追加的，应该可以写到脚本里）</p>
<h2 id="auto-install-sh"><a href="#auto-install-sh" class="headerlink" title="auto_install.sh"></a>auto_install.sh</h2><pre><code>#!/bin/bash 
#author niumeng 
#auto install jdk and hadoop as well as path 


x=1

while [ $x -eq 1]
do
echo &quot;----------欢迎来到远程安装JDK + hadoop 的脚本：$0----------&quot;
echo &quot;请输入您要远程登录的服务器相关信息：）&quot;
echo &quot;登录服务器ip:&quot; 
read remote_ip
echo &quot;登录服务器pwd:&quot; 
read remote_Password

user=hadoop
#step1:进入~/下载,把本地的jdk+hadoop+enviroment.sh+slave_use_install.sh发送到远程登录机器的下载目录下
scp ~/下载/jdk-8u131-linux-x64.tar.gz $user@$remote_ip:/home/$user/下载
scp ~/下载/hadoop-2.7.3.tar.gz $user@$remote_ip:/home/$user/下载
scp ~/下载/environment.sh $user@$remote_ip:/home/$user/下载
scp ~/slave_use_install.sh $user@remote_ip:/home/$user/下载

if [ $? -eq 0 ];then 
    echo &quot;发送两个压缩包成功！&quot;
else 
    echo &quot;发送失败！请查找原因！&quot;
fi 

echo &quot;是否还要继续发送文件到其他节点？yes:1/no:0&quot;
read x
done 
</code></pre><p>完善：如何用循环直接把四个文件传送给五台机器？</p>
<h2 id="environment-sh"><a href="#environment-sh" class="headerlink" title="environment.sh"></a>environment.sh</h2><pre><code>export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_131  
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/sbin
</code></pre><h2 id="slave-install-use-sh"><a href="#slave-install-use-sh" class="headerlink" title="slave_install_use.sh"></a>slave_install_use.sh</h2><pre><code>#!/bin/bash
#author niumeng 
#used in slave node to install jdk and hadoop as well as path

echo &quot;------欢迎来到slave节点，安装jdk+hadoop:$0-----&quot;

#1.安装jdk
if [ ! -d /usr/lib/jdk ];then
sudo mkdir /usr/lib/jdk
fi
if [ $? -eq 0];then
echo &quot;mkdir success!&quot;
else
echo &quot;mkdir failure!&quot;
fi

sudo cp ~/下载/jdk-8u131-linux-x64.tar.gz /usr/lib/jdk
cd /usr/lib/jdk
sudo tar -xvf jdk-8u131-linux-x64.tar.gz
if [ $? -eq 0 ];then
        echo &quot;解压JDK包成功！&quot;
else
        echo &quot;解压失败！请查找原因！&quot;
fi
#2.追加环境变量配置文件到.bashrc
cat ~/下载/environment.sh &gt;&gt; ~/.bashrc
if [ $? -eq 0 ];then
        echo &quot;环境变量配置成功！&quot;
else
        echo &quot;环境变量配置失败！请查找原因！&quot;
fi
#3.检验是否安装成功
java -version
if [ $? -eq 0 ];then
        echo &quot;java install成功！&quot;
else
        echo &quot;java install失败！请查找原因！&quot;
fi

#4.安装hadoop
cd ~/下载
sudo tar -zxf hadoop-2.7.3.tar.gz -C /usr/local
cd /usr/local/
sudo mv ./hadoop-2.7.3/ ./hadoop
sudo chown -R hadoop:hadoop ./hadoop


#5.检查hadoop是否可用

cd /usr/local/hadoop/bin

hadoop version

if [ $? -eq 0 ];then
        echo &quot;hadoop install成功！&quot;
else
        echo &quot;hadoop install失败！请查找原因！&quot;
fi
</code></pre><p>step2:<br>至此，hadoop已经安装成功，我们需要对配置文件进行配置，现在首先ssh到master0节点，然后在master0节点之上进行配置文件的更改，再压缩hadoop压缩包并发送到其他四个节点机器上，在依次进入其余四台机器上运行一个shell脚本并安装该配置文件。</p>
<h2 id="auto-3-sh"><a href="#auto-3-sh" class="headerlink" title="auto_3.sh"></a>auto_3.sh</h2><pre><code>#!/bin/bash 
#author niumeng 
# hadoop 配置文件，我们xshell或者ssh到一台master上，bash该文件


echo &quot;----------欢迎来到hadoop配置文件脚本：$0----------&quot;

#1.slaves文件配置
#用slave.sh文件直接覆盖原文件
cat ~/slave.sh &gt; /usr/local/hadoop/etc/hadoop/slaves

if [ $? -eq 0 ];then
    echo &quot;success!&quot;
else 
    echo &quot;failure!please check out your shell!&quot;
fi 

# 2. core-site.xml
# 删除最后两行configuration  
sed &#39;N;$!P;$!D;$d&#39;  /usr/local/hadoop/etc/hadoop/core-site.xml
if [ $? -eq 0 ];then
    echo &quot;success!&quot;
else 
    echo &quot;failure!please check out your shell!&quot;
fi 
# 追加配置文件到末尾
# 首先取出机器名,赋值给变量machinename
while read line
do
   machinename=&quot;$line&quot;
done&lt;/etc/hostname
echo &quot;机器名为：$machinename&quot;

# 使用here document 来追加
cat &lt;&lt; EOF &gt;&gt; core-site.xml
&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://$machinename:9000&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;
        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
EOF

if [ $? -eq 0 ];then
    echo &quot;cat core-site success!&quot;
else 
    echo &quot;cat core-site failure!please check out your shell!&quot;
fi 

# 3. hdfs-site.xml 
# 删除最后两行configuration  
sed &#39;N;$!P;$!D;$d&#39;  /usr/local/hadoop/etc/hadoop/hdfs-site.xml
if [ $? -eq 0 ];then
    echo &quot;success!&quot;
else 
    echo &quot;failure!please check out your shell!&quot;
fi 
# 追加配置文件到末尾
cat &lt;&lt; EOF &gt;&gt; hdfs-site.xml
&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;
        &lt;value&gt;$machinename:50090&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;
        &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;
        &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
EOF
if [ $? -eq 0 ];then
    echo &quot;cat hdfs-site.xml success!&quot;
else 
    echo &quot;cat hdfs-site.xml failure!please check out your shell!&quot;
fi 
#4.mapred-site.xml 
# 重命名 默认文件名问mapred-site.xml.template

if [ -f mapred-site.xml.template ];then
mv mapred-site.xml.template mapred-site.xml
echo &quot;change name successfully!&quot;
fi

# 删除最后两行configuration  
sed &#39;N;$!P;$!D;$d&#39;  /usr/local/hadoop/etc/hadoop/mapred-site.xml
if [ $? -eq 0 ];then
    echo &quot;success!&quot;
else 
    echo &quot;failure!please check out your shell!&quot;
fi 
# 追加配置文件到末尾
cat &lt;&lt; EOF &gt;&gt; mapred-site.xml
&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;
        &lt;value&gt;$machinename:10020&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;
        &lt;value&gt;$machinename:19888&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
EOF

if [ $? -eq 0 ];then
    echo &quot;cat mapred-site.xml success!&quot;
else 
    echo &quot;cat mapred-site.xml failure!please check out your shell!&quot;
fi 
#5.yarn.site.xml 

# 删除最后两行configuration  
sed &#39;N;$!P;$!D;$d&#39;  /usr/local/hadoop/etc/hadoop/yarn-site.xml
if [ $? -eq 0 ];then
    echo &quot;success!&quot;
else 
    echo &quot;failure!please check out your shell!&quot;
fi 
# 追加配置文件到末尾
cat &lt;&lt; EOF &gt;&gt; yarn-site.xml
&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;$machinename&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
EOF

if [ $? -eq 0 ];then
    echo &quot;cat yarn-site.xml success!&quot;
else 
    echo &quot;cat yarn-site.xml failure!please check out your shell!&quot;
fi 

echo &quot;until now we have already finished the configuration of hadoop files :)&quot;

# end 将master节点上的/user/local/hadoop文件夹复制到各个节点上
#　如果跑过分布式，先删除临时文件
if [ -f /usr/local/hadoop/tmp ];then
    sudo rm -rf ./tmp
    sudo rm -rf ./logs/*
    echo &quot;delete successfully&quot;
fi 


tar -zcf ~/hadoop.master.tar.gz /usr/local/hadoop
cd ~ 

user=hadoop
x=1;
while [ $x -eq 1]
do
# 输入复制节点的信息
echo &quot;请输入您要复制文件的slave节点ip地址：&quot;
read remote_slave_ip
echo &quot;请输入您要复制文件的slave节点密码：&quot;
read remote_pwd
# 先压缩再复制,把hadoop文件夹复制到~/

scp ./hadoop.master.tar.gz $user@$remote_slave_ip:/home/hadoop

if [ $? -eq 0 ];then
    echo &quot;scp tar.gz successfully&quot;
else 
    echo &quot;scp tar.gz failure!please check out !&quot;
fi 
#把节点使用脚本放到下载中
scp ~/slave_use_3.sh $user@remote_slave_ip:/home/hadoop/下载
if [ $? -eq 0 ];then
    echo &quot;scp slave_use_3.sh successfully&quot;
else 
    echo &quot;scp slave_use_3.sh failure!please check out !&quot;
fi 

echo &quot;是否还有下一台slave机器需要拷贝文件？yes:1/no：0&quot;
read $x
done 

echo &quot;恭喜您已经成功配置好了所有hadoop文件并给slave节点安装成功！HAVE A NICE DAY:)&quot;
</code></pre><h2 id="slave-sh"><a href="#slave-sh" class="headerlink" title="slave.sh"></a>slave.sh</h2><p>注意：有几个slave节点都要添加进去</p>
<pre><code>slave2
</code></pre><p>思考：如何不用这个.sh脚本，直接添加进去？</p>
<p>至此，master0机器上的已经配置好的hadoop文件夹已经打包好并传送给其余节点了，现在我们需要ssh每台机器上并解压该压缩包</p>
<h2 id="slave-use-3-sh"><a href="#slave-use-3-sh" class="headerlink" title="slave_use_3.sh"></a>slave_use_3.sh</h2><pre><code>#!/bin/bash
#author niumeng 
# 配置hadoop文件完成之后需要把压缩包传送给各个slave节点，此脚本为在各个节点之上解压压缩包的文件

echo &quot;------------欢迎来到slave节点配置hadoop文件的脚本：$0---------&quot;
# 删除旧文件（如果存在）
if [ ! -d /usr/local/hadoop]
sudo rm -r /usr/local/hadoop
sudo tar -zxf ~/hadoop.master.tar.gz -C /usr/local
sudo chown -R hadoop:hadoop /usr/local/hadoop

if [ $? -eq 0 ];then 
    echo &quot;tar success ! &quot;
else 
    echo &quot;tar failure! &quot;
fi 
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Python 入门学习（三）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/Python 入门学习（三）/">Python 入门学习（三）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/Python 入门学习（三）/" class="article-date">
  <time datetime="2018-08-14T03:00:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>2.3 list和tuple<br><strong>list</strong></p>
<ul>
<li>可变长的集合：增加和删除元素</li>
<li>len(list) </li>
<li>list[0] / list[-1] ：索引访问元素</li>
</ul>
<pre><code>1 classmate = [&#39;niu&#39;,&#39;meng&#39;,&#39;hello world&#39;] # 中括号表示
2 classmate.append(&#39;the end&#39;)
3 classmate.pop()
4 classmate.insert(i,&#39;insert&#39;)
5 classmate[0] = &#39;change&#39;
6 classmate = [] len(classmate)=0
</code></pre><p><strong>tuple</strong></p>
<ul>
<li>不可变的有序列表，没有insert和append方法</li>
<li>tuple元祖的指向永远是不变的，但是如果tuple的一个元素是list，那么可以修改list中的值来修改tuple。</li>
</ul>
<pre><code>1 tuple = (&#39;hello&#39;,&#39;world&#39;)
</code></pre><p>2.4 条件判断和循环<br><strong>条件判断</strong></p>
<pre><code> 1 if &lt;条件判断1&gt;:
2     &lt;执行1&gt;
3 elif &lt;条件判断2&gt;:
4     &lt;执行2&gt;
5 elif &lt;条件判断3&gt;:
6     &lt;执行3&gt;
7 else:
8     &lt;执行4&gt;
</code></pre><p><strong>循环</strong></p>
<pre><code> 1 sum = 0
2 for x in range(101):
3     sum = sum + x
4 print sum
</code></pre><p>2.5 dict和set的使用<br><strong>dict</strong></p>
<ul>
<li>字典即为所谓的key-value键值对嘛 </li>
</ul>
<pre><code>1 &gt;&gt;&gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}
2 &gt;&gt;&gt; d[&#39;Michael&#39;]
</code></pre><ul>
<li>注意啦注意啦！写脚本的时候查找mongodb总是报这个错误呢，一开始不明白，后来才发现是没有该字段名。MongoDB的文档，本质上是个dict。</li>
</ul>
<pre><code>1 &gt;&gt;&gt; d[&#39;Thomas&#39;]
2 Traceback (most recent call last):
3   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
4 KeyError: &#39;Thomas&#39;
</code></pre><p>判断key是否存在的方法：</p>
<pre><code>1 &gt;&gt;&gt; &#39;Thomas&#39; in d
2 False
</code></pre><ol>
<li>通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：</li>
</ol>
<pre><code>1 &gt;&gt;&gt; d.get(&#39;Thomas&#39;)
2 &gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)
3 -1
</code></pre><ul>
<li><p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：</p>
</li>
<li><p>1 &gt;&gt;&gt; d.pop(‘Bob’)</p>
</li>
</ul>
<p>key 必须为不可变对象，如字符串；而list则不能作为key</p>
<p><strong>set</strong></p>
<ul>
<li>set和dict类似，也是一组key的集合， <strong>但不存储value</strong> 。由于key不能重复，所以，在set中，没有重复的key。</li>
</ul>
<pre><code> 1 &gt;&gt;&gt; s = set([1, 2, 3])
 2 &gt;&gt;&gt; s
 3 set([1, 2, 3])
 4 &gt;&gt;&gt; s.add(4) 集合增加一个元素
 5 &gt;&gt;&gt;&gt; s.remove(4) 删除一个元素 
 6 
 7 &gt;&gt;&gt; s1 = set([1, 2, 3])
 8 &gt;&gt;&gt; s2 = set([2, 3, 4])
 9 &gt;&gt;&gt; s1 &amp; s2 求两个集合的交集
10 set([2, 3])
11 &gt;&gt;&gt; s1 | s2
12 set([1, 2, 3, 4])
</code></pre><p><strong>不可变对象</strong></p>
<pre><code> 1  可变对象list:
 2 &gt;&gt;&gt; a = [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]
 3 &gt;&gt;&gt; a.sort()
 4 &gt;&gt;&gt; a
 5 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
 6 
 7 不可变对象：str
 8 &gt;&gt;&gt; a = &#39;abc&#39;
 9 &gt;&gt;&gt; a.replace(&#39;a&#39;, &#39;A&#39;)
10 &#39;Abc&#39;
11 &gt;&gt;&gt; a
12 &#39;abc&#39;
13 字符串本身并没有改变
</code></pre><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p>3.2 定义函数</p>
<p><strong>函数的定义格式</strong></p>
<pre><code> 1 def my_abs(x):
2     if x &gt;= 0:
3         return x
4     else:
5         return -x
6 空函数
</code></pre><ul>
<li>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</li>
</ul>
<pre><code>1 def nop():
2     pass
</code></pre><p><strong>函数多返回值</strong></p>
<ul>
<li>在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以， <strong>Python的函数返回多值其实就是返回一个tuple</strong> ，但写起来更方便。</li>
</ul>
<pre><code>1 def move(x, y, step, angle=0):
2     nx = x + step * math.cos(angle)
3     ny = y - step * math.sin(angle)
4     return nx, ny
5 
6 &gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
7 &gt;&gt;&gt; print r
8 (151.96152422706632, 70.0)
</code></pre><p>3.3 函数的参数<br><strong>默认参数</strong></p>
<ul>
<li>默认参数： <code>def enroll(name, gender, age=6, city=&#39;Beijing&#39;):</code></li>
<li>必选参数在前，默认参数在后，否则Python的解释器会报错</li>
<li>默认参数的一个巨大的坑：默认参数必须指向不变变量，不能指向list</li>
</ul>
<p><strong>可变参数</strong></p>
<pre><code> 1 def calc(*numbers):
2     sum = 0
3     for n in numbers:
4         sum = sum + n * n
5     return sum
</code></pre><ul>
<li>在参数numbers前面加了一个*，在函数内部，参数numbers收到的是一个tuple,可传入0-人一个参数。</li>
</ul>
<p><strong>关键字参数</strong></p>
<ul>
<li>如何传入一个dict</li>
</ul>
<pre><code>1 def person(name, age, **kw):
2     print &#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw 
3 &gt;&gt;&gt; person(&#39;Bob&#39;, 35, city=&#39;Beijing&#39;)
4 name: Bob age: 35 other: {&#39;city&#39;: &#39;Beijing&#39;}
5 &gt;&gt;&gt; person(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)
6 name: Adam age: 45 other: {&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;}
</code></pre><p>小结：</p>
<ul>
<li><p>*args是可变参数，args接收的是一个tuple；</p>
</li>
<li><p>**kw是关键字参数，kw接收的是一个dict。</p>
</li>
<li><p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过 _args传入：func(_ (1, 2, 3))；</p>
</li>
<li><p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过 <strong>kw传入：func(</strong> {‘a’: 1, ‘b’: 2})。</p>
</li>
</ul>
<h2 id="四、高级特性"><a href="#四、高级特性" class="headerlink" title="四、高级特性"></a>四、高级特性</h2><p>4.1 切片</p>
<ul>
<li>什么是切片：<code>&gt;&gt;&gt; L[0:3] [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]</code></li>
<li>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。</li>
<li>倒数切片：<code>L[-2:-1]</code></li>
<li>每隔i个取一个数：<code>L[:10:2]</code></li>
<li>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</li>
</ul>
<p>4.2 迭代</p>
<ul>
<li>可迭代对象：list / tuple / dict / str</li>
<li>dict 如何进行迭代：</li>
</ul>
<pre><code>1 &gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
2 &gt;&gt;&gt; for key in d:
3 ...     print key
4 默认情况下，dict迭代的是key。
5 如果要迭代value，可以用for value in d.itervalues()。
6 如果要同时迭代key和value，可以用for k, v in d.iteritems()。
</code></pre><ul>
<li>判断一个对象是否可迭代：</li>
</ul>
<pre><code>1 &gt;&gt;&gt; from collections import Iterable
2 &gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
3 True
4 &gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
5 True
6 &gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
7 False
</code></pre><ul>
<li>对list实现类似Java那样的下标循环：</li>
</ul>
<pre><code>1 &gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
2 ...     print i, value
3 ...
4 0 A
5 1 B
6 2 C






在Python中可以在for循环中同时使用两个变量：


1 &gt;&gt;&gt; for x, y in [(1, 1)print x, y
2 ...
3 1 1
4 2 4
5 3 9
</code></pre><p>4.3 列表生成式</p>
<ul>
<li>强大的生成list的方式，使循环代码用一行搞定，高效简洁：</li>
</ul>
<pre><code>1 &gt;&gt;&gt; range(1, 11)
2 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
3 &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
4 &gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
</code></pre><p>4.4 生成器</p>
<ul>
<li>列表生成器可以直接生成一个列表，但若我们只用的到这个列表的前几个元素，那便极大地浪费内存空间了。如果可以一边循环一边计算，根据某种算法推算出所需元素，那便要用到我们的生成器（generator）啦！</li>
<li><p>如何创建一个生成器？   </p>
<ol>
<li>第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</li>
</ol>
</li>
</ul>
<pre><code>1 &gt;&gt;&gt; L = [x * x for x in range(10)]
2 &gt;&gt;&gt; L
3 [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
4 &gt;&gt;&gt; g = (x * x for x in range(10))
5 &gt;&gt;&gt; g
6 &lt;generator object &lt;genexpr&gt; at 0x104feab40&gt;
</code></pre><ul>
<li>生成器元素的打印方法？</li>
</ul>
<pre><code>1 &gt;&gt;&gt; g.next()
2 0
3 &gt;&gt;&gt; g.next()
4 1
5 &gt;&gt;&gt; g = (x * x for x in range(10))
6 &gt;&gt;&gt; for n in g:
7 ...     print n，&#39;还是使用for循环迭代生成器方便地多呀&#39;
</code></pre><ul>
<li>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。如著名的斐波那契数列的生成：</li>
</ul>
<pre><code>1 def fib(max):
2     n, a, b = 0, 0, 1
3     while n &lt; max:
4         print b
5         a, b = b, a + b
6         n = n + 1
</code></pre><p>运行这个fib()们想把它变成一个生成器，每打印一个数字便暂停等待。只需要:</p>
<pre><code>1 print b --&gt; yield b 
</code></pre><p>使用fib生成器的方法便是for循环调用：</p>
<pre><code>1 for i in fib(6): print i 
</code></pre><ul>
<li>总结：普通的函数为顺序执行，遇到return停止；生成器则遇到yield语句才会暂停。</li>
</ul>
<h2 id="五、函数式编程"><a href="#五、函数式编程" class="headerlink" title="五、函数式编程"></a>五、函数式编程</h2><p>5.1 高阶函数</p>
<p><strong>变量也可以指向函数</strong></p>
<p>5.2 返回函数<br>5.3 匿名函数<br>5.4 装饰器<br>5.5 偏函数</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-python 入门学习（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/python 入门学习（二）/">python 入门学习（二）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/python 入门学习（二）/" class="article-date">
  <time datetime="2018-08-14T02:56:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>还有十天在实验室的生活，然后我就要回我们大山东啦哈哈哈！这十天想过的有意义一点，做实验写论文之余，希望学点自己喜欢的事情（♪(＾∀＾●)ﾉ）一直使用一款统计玩手机时长的APP叫”小容”，今个早晨一看，给我吓一大跳，昨天使用手机时长8小时，我都不知道我昨天在搞什么飞机，我感觉我一直在学习呀？所以，今天要开启新的学习模式，用整片的时间来玩手机，而不是学一会儿玩一会儿，切换任务频率太高了会导致种种后遗症啊。<br>说说python的学习路线：</p>
<h2 id="Part-1-基础教程"><a href="#Part-1-基础教程" class="headerlink" title="Part 1 基础教程"></a>Part 1 基础教程</h2><p>之前有Python的基础，但是不精，这就导致写脚本的时候要反复地百度知识，因此这次想还是从基础入手，一气呵成地把基础过一遍。网上有很多的视频教程：<br><a href="http://pan.baidu.com/s/1kUZpbOb" target="_blank" rel="noopener">Python基础教程</a><br>这个视频是从知乎上看到的，下载之后发现很全面，从Linux开始介绍。但是看视频毕竟是太慢太慢啦，因此我还是乖乖去找我们的廖雪峰叔叔吧~<br><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001407375700558864523211a5049c4983176de304549c8000" target="_blank" rel="noopener">廖雪峰<br>Python教程</a></p>
<h2 id="Part-2-Scrapy"><a href="#Part-2-Scrapy" class="headerlink" title="Part 2 Scrapy"></a>Part 2 Scrapy</h2><p>之前也用过scrapy框架，但是怎么说呢，感觉并不是很明白，充其量就算是会用而已。又搞到了一套视频，或者直接看文档，学起来很快的啦~<br><a href="https://mp.csdn.net/mdeditor/pan.baidu.com/s/1dF3qhFV" target="_blank" rel="noopener">Scrapy视频教程</a></p>
<h2 id="Part-3-Django"><a href="#Part-3-Django" class="headerlink" title="Part 3 Django"></a>Part 3 Django</h2><p>总是要学会用Python写个简单的博客的吧~<br><a href="http://pan.baidu.com/s/1nvFlfU5" target="_blank" rel="noopener">Django视频教程</a></p>
<h2 id="Part-4-全栈教程"><a href="#Part-4-全栈教程" class="headerlink" title="Part 4 全栈教程"></a>Part 4 全栈教程</h2><p><a href="http://pan.baidu.com/s/1dETyqXF" target="_blank" rel="noopener">全栈视频教程</a></p>
<hr>
<p>内容还是很多的啦，有时间的时候我就使劲看看看！多学一点知识使我感到快乐！但是前提是先把最重要最紧急的工作做好，再来学自己喜欢的东西！<br>下面会记录一些学廖雪峰教程中的笔记：</p>
<h2 id="一、安装Python"><a href="#一、安装Python" class="headerlink" title="一、安装Python"></a>一、安装Python</h2><p>Python 解释器 ： 运行.py文件</p>
<ul>
<li>Cpython : 用C语言编写的Python解释器</li>
<li>Jpython : 运行在Java平台上的Python解释器</li>
<li>IPython : IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。</li>
</ul>
<h2 id="二、Python-基础"><a href="#二、Python-基础" class="headerlink" title="二、Python 基础"></a>二、Python 基础</h2><p>2.1 数据类型和变量<br>数据类型</p>
<ul>
<li>整数、浮点数</li>
<li>字符串：转义字符”\”的使用、r”\\\”表示引号中内容都不转义</li>
<li>布尔值：true false 布尔运算：and not or </li>
<li>空值：None</li>
</ul>
<p>变量：动态语言：变量本身类型不固定</p>
<p>常量：通常用全部大写的变量名表示常量</p>
<p>2.2 字符串和编码<br>编码方法的发展过程</p>
<ul>
<li>美国127个字母：ASCII编码，一个字节表示一个字符</li>
<li>中国用两个字节表示一个汉字，GB2312</li>
<li>但一篇全英文文本使用Unicode编码就会比使用ASCII编码编写同样内容的文本多花费一倍空间，为了节省存储空间，Unicode编码被转换成可变长的UTF-8编码：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</li>
</ul>
<p>计算机通用的字符编码工作方式</p>
<ul>
<li>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</li>
</ul>
<p>字符串的编码</p>
<ul>
<li>Unicode转UTF-8 ： u”string”.encode(“utf-8”) 编码</li>
<li>UTF-8转Unicode ：’abc’.decode(‘utf-8’) 解码</li>
<li>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</li>
</ul>
<pre><code>1 #!/usr/bin/env python 
2 # -*- coding: utf-8 -*-
3 第一行注释告诉linux/os x系统这是一个Python可执行文件
4 第二行注释告诉Python解释器，要按照utf-8编码读取源代码 
5 在写python脚本的时候为避免出错，尽量不要打印中文字符串，毕竟我们是学过英语的人嘛~
</code></pre><p>字符串的格式化</p>
<ul>
<li>1 ‘Hello, %s’ % ‘world’</li>
</ul>
<p>%s 字符串 %d 整数 %f 浮点数</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-python 入门学习" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/python 入门学习/">python 入门学习</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/python 入门学习/" class="article-date">
  <time datetime="2018-08-14T02:55:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>把sublime编辑的.py文件保存在本地，在当前目录下输入</p>
<pre><code>1 python hello.py





即可运行该程序，一定要在当前目录下运行。如果当前目录下没有该文件则不能成功运行。 
</code></pre><p>其中cmd黑窗口下有这么几个快捷键，<br>c: 进入另一个盘<br>dir 显示当前目录<br>tab 进行代码补全</p>
<p>直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了</p>
<p>python代码运行助手<br>在存放learning.py的目录下运行命令：</p>
<pre><code>1 C:\Users\michael\Downloads&gt; python learning.py


1.如何输出与输出 
</code></pre><p>字符串用单引号<br>print()函数也可以接受多个字符串，用逗号”,”隔开，就可以连成一串输出</p>
<pre><code>1 print(&#39;The quick brown fox&#39;, &#39;jumps over&#39;, &#39;the lazy dog&#39;)
2 print(&#39;100+300=&#39;,100+300)
3 &gt;&gt;&gt; name = input()
4 #这个是注释！
</code></pre><p>Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。</p>
<p>转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\。</p>
<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>
<p>字母A用ASCII编码是十进制的65，二进制的01000001；</p>
<p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p>
<p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p>
<p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把Unicode编码转化为”可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：<br>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Python 爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/Python 爬虫/">Python 爬虫</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/Python 爬虫/" class="article-date">
  <time datetime="2018-08-14T02:54:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>Requests urllib的升级版本打包了全部功能并简化了使用方法<br>beautifulsoup 是一个可以从HTML或XML文件中提取数据的Python库.<br>LXML 一个HTML解析包 用于辅助beautifulsoup解析网页</p>
<p>urllib2用一个Request对象来映射你提出的HTTP请求。<br>在它最简单的使用形式中你将用你要请求的地址创建一个Request对象，<br>通过调用urlopen并传入Request对象，将返回一个相关请求response对象，<br>这个应答对象如同一个文件对象，所以你可以在Response中调用.read()。</p>
<p><strong>百度贴吧小爬虫</strong><br>目的：输入带分页的地址，去掉最后面的数字，设置一下起始页数和终点页数。<br>功能：下载对应页码内的所有页面并存储为html文件。</p>
<pre><code> 1 import urllib2
 2 import string 
 3 
 4 def baidu_tieba(url,begin_page,end_page):
 5     for i in range(begin_page,end_page):
 6         sName = string.zfill(i,5)+&#39;.html&#39;
 7         print &#39;is downloading &#39; + str(i) +&#39; page and restore it as &#39;+ sName + &#39;......&#39;
 8         f=open(sName,&#39;w+&#39;)
 9         m=urllib2.urlopen(url+str(i)).read()
10         f.write(m)
11         f.close()
12 
13 bdurl = &quot;http://tieba.baidu.com/p/4989517604?pn=&quot;
14 begin_page = 1
15 end_page = 5
16 
17 baidu_tieba(bdurl,begin_page,end_page)
</code></pre><p>查看workspace，我们可以看到<br><img src="http://img.blog.csdn.net/20170519130915683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20170519131007739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这样一个一个的页面就被我们保存到本地啦！！真的很简单很开心啊！！！</p>
<p><strong>re模块</strong><br>使用re的一般步骤是：<br>Step1：先将正则表达式的字符串形式编译为Pattern实例。<br>Step2：然后使用Pattern实例处理文本并获得匹配结果（一个Match实例）。<br>Step3：最后使用Match实例获得信息，进行其他的操作。</p>
<p>用户代理 User Agent，是指浏览器,它的信息包括硬件平台、系统软件、应用软件和用户个人偏好。<br>如何查看chrome的用户代理信息？<br>在地址栏中输入：chrome://version/ 即可显示全部信息</p>
<pre><code>1 用户代理    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36





出现 SyntaxError: Non-ASCII character &#39;\xef&#39; in file hello.py on line 10, but no encoding declared; see &lt;http://python.org/dev/peps/pep-0263/&gt; for details问题时很明显是编码的问题，那么就在.py文件头添加一句


#coding:utf-8
</code></pre><p>便可以解决问题。</p>
<p>小技能：f12+fn 快速调出审查元素</p>
<p><strong>糗事百科</strong></p>
<pre><code> 1  # coding:utf-8
 2 import urllib2
 3 import urllib
 4 import re
 5 page = 1 
 6 url = &#39;http://www.qiushibaike.com/hot/page/&#39;+str(page)
 7 user_agent = &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&#39;
 8 headers = {&#39;User-Agent&#39; : user_agent}
 9 try:
10     request = urllib2.Request(url,headers = headers)
11     response = urllib2.urlopen(request)
12     content  = response.read()
13     pattern = re.compile(&#39;h2&gt;(.*?)&lt;/h2.*?content&quot;&gt;(.*?)&lt;/.*?number&quot;&gt;(.*?)&lt;/&#39;,re.S)
14     items = re.findall(pattern,content)
15     for item in items:
16         print item[1],item[2]
17 
18 except urllib2.URLError,e:
19     if hasattr(e,&quot;code&quot;):
20         print e.code
21     if hasattr(e,&quot;reason&quot;):
22         print e.reason
23 
24 # 打印出第一页的html code,这里使用headers是伪装成浏览器，防止被封，有的网站需要这样的
25 # 措施，否则会报出httplib.BadStatusLine: &#39;&#39;这样的错误，有的则没有被封的风险。
26 
27 #2.提取某一页的所有段子
28 #1）.*? 是一个固定的搭配，.和*代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。
29 
30 #2）(.*?)代表一个分组，在这个正则表达式中我们匹配了三个分组，在后面的遍历item中，item[0]就代表第一个(.*?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。
31 
32 #3）re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。
33 #这样我们便获得了发布内容 点赞数
</code></pre><p><strong>Quotes 一个hin简单的网站！</strong><br>经过一天的摸鱼之旅之后终于要开始学习scrapy框架啦，毕竟干写爬虫和用框架写一定是不一样的。<br>看了一些基础scrapy教程之后爬了一个结构很简单的网站，但是还没有保存，其中有些东西还不是很懂。</p>
<pre><code> 1 import scrapy 
 2 
 3 
 4 class Myspider(scrapy.Spider):
 5 
 6     name = &#39;hello&#39;
 7 
 8     def start_requests(self):
 9        urls=[
10        &#39;http://quotes.toscrape.com/page/1/&#39;,
11        &#39;http://quotes.toscrape.com/page/2/&#39;,
12        ]
13        for url in urls:
14            yield scrapy.Request(url=url,callback=self.parse) 
15 
16 
17     def parse(self, response):
18         # page = response.url.split(&quot;/&quot;)[-2]
19         # filename = &#39;quotes-%s.html&#39; % page
20         # with open(filename,&#39;wb&#39;) as f:
21         #     f.write(response.body)
22         # self.log(&#39;Saved file %s&#39; % filename)
23         content = response.xpath(&quot;.//div[@class=&#39;quote&#39;]/span[1]/text()&quot;).extract()
24         for i in content: 
25             print i 
</code></pre><p><img src="http://img.blog.csdn.net/20170519210926266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>上面的一个引号便是一条条的quote啦，超级简单啦~</p>
<p>2017/5/20 愉快的节日~心情很好所以想学一下Ｍysql在python中的应用。<br>1）#!/usr/bin/python<br>是用来说明脚本语言是Python的。是要用/usr/bin下面的程序（工具）python，这个解释器，来解释python脚本，来运行python脚本的。</p>
<p>2）#- _- coding: utf-8 -_ -<br>是用来指定文件编码为utf-8的。</p>
<p>我搜索了一下”# - _- coding:utf-8 -_ -<br>为什么要这样的格式？”，有人在下面回复说：”大概是颜文字？”萌到我了！其实应该是Emacs处理编码的方式。在sublime里面我们输入#<br>coding:urf-8也是没有问题的啦~</p>
<p><strong>连接mysql数据库</strong></p>
<ul>
<li><p>到mysql5.7/bin/下输入，以进入数据库：</p>
</li>
<li><p>1 mysql -hlocalhost -uroot -p</p>
</li>
</ul>
<p>显示数据库内容：</p>
<ul>
<li>1 SHOW DATABASES;</li>
</ul>
<p>创建数据库:</p>
<ul>
<li>1 CREATE DATABASE testdb;</li>
</ul>
<p>创建一个’testuser’的测试用户，并予以相应的权限：</p>
<ul>
<li>1 CREATE USER ‘testuser’@’localhost’ IDENTIFIED BY ‘test623’;</li>
</ul>
<p>使用数据库：</p>
<ul>
<li>1 mysql&gt; USE testdb;</li>
</ul>
<p>grant 权限 on 数据库对象 to 用户，赋予权限给用户</p>
<ul>
<li>1 mysql&gt; GRANT ALL ON testdb.* TO ‘testuser’@’localhost’;</li>
</ul>
<p>退出</p>
<pre><code> 1 mysql&gt; quit;
 2 #!user/bin/python
 3 # coding:utf-8
 4 # print mysql version
 5 import MySQLdb as mdb
 6 import sys
 7 con = None
 8 try:
 9     con = mdb.connect(&#39;localhost&#39;,&#39;testuser&#39;,&#39;test623&#39;,&#39;testdb&#39;)
10     # 主机名 用户名 密码 数据库
11     cur = con.cursor()
12     # 创建游标
13     cur.execute(&quot;SELECT VERSION()&quot;)
14     data = cur.fetchone()
15     print &quot;database version：%s &quot; %data
16 except mdb.Error,e:
17     print &quot;error %d: %s&quot; %(e.args[0],e.args[1])
18 finally:
19     if con:
20         con.close()
</code></pre><p>便打印出数据库的版本：</p>
<pre><code>1 database version：5.7.17-log
</code></pre><p>2.新建表并插入数据<br>我们先来看看SQL建表语句</p>
<pre><code> 1 create table userinfo 
 2 
 3 ( 
 4   id int primary key identity,--identity每次自动加1
 5   name char(20), 
 6   age int check(age&gt;10), 
 7   sex char(2) 
 8 )
 9 
10 --插入
11 insert into userinfo(name,age,sex) values(&#39;张三&#39;,24,&#39;男&#39;)
</code></pre><p>tip:运行python时每次弹出”IndentationError: unindent does not match any outer<br>indentation level”就说明tab and blank又混用啦！不得不说这一点真麻烦呢。</p>
<pre><code> 1 # coding: utf-8
 2 import MySQLdb as mdb
 3 import sys
 4 
 5 con = mdb.connect(&#39;localhost&#39;, &#39;testuser&#39;, &#39;test623&#39;, &#39;testdb&#39;);
 6 with con:
 7     cur = con.cursor()
 8     cur.execute(&quot;CREATE TABLE IF NOT EXISTS Writers(Id INT PRIMARY KEY AUTO_INCREMENT, Name VARCHAR(25))&quot;)
 9     cur.execute(&quot;INSERT INTO Writers(Name) VALUES(&#39;Jack London&#39;)&quot;)
10     cur.execute(&quot;INSERT INTO Writers(Name) VALUES(&#39;Honore de Balzac&#39;)&quot;)
11     cur.execute(&quot;INSERT INTO Writers(Name) VALUES(&#39;Lion Feuchtwanger&#39;)&quot;)
12     cur.execute(&quot;INSERT INTO Writers(Name) VALUES(&#39;Emile Zola&#39;)&quot;)
13     cur.execute(&quot;INSERT INTO Writers(Name) VALUES(&#39;Truman Capote&#39;)&quot;)
</code></pre><p>３.提取表中数据</p>
<pre><code> 1 # coding: utf-8
 2 import MySQLdb as mdb
 3 import sys
 4 
 5 con = mdb.connect(&#39;localhost&#39;, &#39;testuser&#39;, &#39;test623&#39;, &#39;testdb&#39;);
 6 with con:
 7     cur = con.cursor()
 8     cur.execute(&quot;SELECT * FROM Writers&quot;)
 9     rows = cur.fetchall()
10     #get all the data from the table and put it in a list
11     for row in rows:
12         print row
13 C:\python\workspace&gt;python haha.py
14 (1L, &#39;Jack London&#39;)
15 (2L, &#39;Honore de Balzac&#39;)
16 (3L, &#39;Lion Feuchtwanger&#39;)
17 (4L, &#39;Emile Zola&#39;)
18 (5L, &#39;Truman Capote&#39;)
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构实验报告（六）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/数据结构实验报告（六）/">数据结构实验报告（六）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/数据结构实验报告（六）/" class="article-date">
  <time datetime="2018-08-14T02:49:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="实验6-排序"><a href="#实验6-排序" class="headerlink" title="实验6 排序"></a>实验6 排序</h2><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #define INFINITY INT_MAX
  5 #define MAXSIZE 100
  6 
  7 using namespace std;
  8 typedef struct list
  9 {int key;
 10 }ElemType;
 11 typedef struct {
 12 ElemType data[MAXSIZE+1];
 13 int length; /*参加排序元素的实际个数*/
 14 }SeqList;
 15 //创建顺序表
 16 void creatList(SeqList &amp;l)
 17 {
 18     cout&lt;&lt;&quot;请输入数据个数&quot;&lt;&lt;endl;
 19     cin&gt;&gt;l.length;
 20     cout&lt;&lt;&quot;请顺次输入一组无序数据&quot;&lt;&lt;endl;
 21     for (int i=1;i&lt;=l.length;i++)
 22     {
 23         cin&gt;&gt;l.data[i].key;
 24     }
 25 }
 26 // 直接插入排序
 27 void InsertSort(SeqList &amp;l)
 28 {
 29     int i,j;
 30     for (i=2;i&lt;=l.length;i++)
 31     {
 32         if (l.data[i].key &lt; l.data[i-1].key )
 33         {
 34             l.data[0].key=l.data[i].key;
 35             l.data[i].key=l.data[i-1].key;
 36             for (j=i-2;l.data[0].key &lt; l.data[j].key ;j--)
 37                 l.data[j+1].key=l.data[j].key;
 38             l.data[j+1].key=l.data[0].key;
 39         }
 40     }
 41 }
 42 //输出顺序表元素
 43 void print(SeqList l)
 44 {
 45     int i;
 46     for (i=1;i&lt;=l.length;i++)
 47         cout&lt;&lt;l.data[i].key&lt;&lt;&quot; &quot;;
 48     cout&lt;&lt;endl;
 49 }
 50 //冒泡排序
 51 void BubbleSort(SeqList &amp;l)
 52 {
 53     int i,j;
 54     for (i=1;i&lt;=l.length-1;i++)
 55         for (j=1;j&lt;=l.length-i;j++)
 56     {
 57         if (l.data[j].key &gt; l.data[j+1].key)
 58         {
 59            l.data[0]=l.data[j];
 60            l.data[j]=l.data[j+1];
 61            l.data[j+1]=l.data[0];
 62         }
 63     }
 64 }
 65 // 直接选择排序
 66 void SelectSort(SeqList &amp;l)
 67 {
 68     int i,j,k;
 69     for (i=1;i&lt;=l.length-1;i++)
 70     {
 71         k=i;
 72         for (j=i;j&lt;=l.length;j++)
 73         {
 74           if (l.data[j].key&lt;l.data[k].key)
 75           {
 76               k=j;
 77           }
 78         }
 79         if (k!=i)
 80         {
 81             l.data[0]=l.data[k];
 82             l.data[k]=l.data[i];
 83             l.data[i]=l.data[0];
 84         }
 85     }
 86 }
 87 //希尔插入
 88 void ShellInsert(SeqList &amp;l,int dk)
 89 {
 90     //dk是位置增量
 91     int i,j;
 92     for (i=dk+1;i&lt;=l.length;i++)
 93     {
 94         if (l.data[i].key &lt; l.data[i-dk].key)
 95         {
 96             l.data[0]=l.data[i];
 97             for (j=i-dk;j&gt;0&amp;&amp;l.data[0].key&lt;l.data[j].key;j=j-dk)
 98             {
 99                 l.data[j+dk]=l.data[j];
100             }
101             l.data[j+dk]=l.data[0];
102         }
103     }
104 }
105 //希尔排序
106 void ShellSort(SeqList &amp;l,int dlta[],int t)
107 {
108     //dlta[]是增量数组，每一次循环以dlta[k]为增量，dlta[0---t-1]
109     int k;
110     for (k=0;k&lt;t;k++)
111         ShellInsert(l,dlta[k]);
112 }
113 //快排
114 int Partition(SeqList &amp;l,int low,int high)
115 {
116     l.data[0]=l.data[low];
117     int p;
118     p=l.data[low].key;
119     while (low&lt;high)
120     {
121         while (low&lt;high&amp;&amp;l.data[high].key&gt;=p) high--;
122         l.data[low]=l.data[high];
123         while (low&lt;high&amp;&amp;l.data[low].key&lt;=p) low++;
124         l.data[high]=l.data[low];
125     }
126     l.data[low]=l.data[0];
127     return low;
128 }
129 void QSort(SeqList &amp;l,int low,int high)
130 {
131     int p;
132     if (low&lt;high)
133     {
134        p=Partition(l,low,high);
135        QSort(l,low,p-1);
136        QSort(l,p+1,high);
137     }
138 }
139 
140 //堆调整
141 void HeapAdjust(SeqList &amp;l,int s,int m)
142 {
143     ElemType rc=l.data[s];
144     int j;
145     for (j=2*s;j&lt;=m;j*=2)
146     {
147         if (j&lt;m &amp;&amp; l.data[j].key &lt; l.data[j+1].key)
148             j++;
149         if (!(rc.key &lt; l.data[j].key))
150             break;
151         l.data[s]=l.data[j];s=j;
152     }
153     l.data[s]=rc;
154 }
155 //堆排序
156 void HeapSort(SeqList &amp;l)
157 {
158     int i;
159     for (i=l.length/2;i&gt;0;i--)
160         HeapAdjust(l,i,l.length);
161     for (i=l.length;i&gt;1;i--)
162     {
163         l.data[0]=l.data[1];
164         l.data[1]=l.data[i];//data[1]即为最大的数
165         l.data[i]=l.data[0];
166         HeapAdjust(l,1,i-1);
167     }
168 
169 
170 }
171 
172 //折半插入排序
173 void BinInsertSort(SeqList &amp;l)
174 {
175     int i,j,low,high,mid;
176     for (i=2;i&lt;=l.length;i++)
177     {
178         l.data[0]=l.data[i];
179         low=1;high=i-1;
180         while (low&lt;=high)
181         {
182             mid=(low+high)/2;
183             if (l.data[0].key &lt; l.data[mid].key ) high=mid-1;
184             else low=mid+1;
185         }
186         for (j=i-1;j&gt;=high+1;j--)
187             l.data[j+1]=l.data[j];
188         l.data[high+1]=l.data[0];
189     }
190 }
191 // 链式存储实现简单选择排序
192 typedef struct LNode
193 {
194     ElemType data;
195     struct LNode *next;
196 }LNode,*linklist;
197 //创建单链表l
198 void createLinkList(linklist &amp;l)
199 {
200     linklist p,q;
201     l=(linklist)malloc(sizeof(LNode));
202     p=l;
203     cout&lt;&lt;&quot;请输入数据个数&quot;&lt;&lt;endl;
204     int n;cin&gt;&gt;n;
205     cout&lt;&lt;&quot;请输入一组数据&quot;&lt;&lt;endl;
206     ElemType e;
207 
208     for (int i=0;i&lt;n;i++)
209     {
210         cin&gt;&gt;e.key;
211         q=(linklist)malloc(sizeof(LNode));
212         q-&gt;data.key=e.key;
213         q-&gt;next=NULL;
214         p-&gt;next=q;
215         p=q;
216     }
217 
218 }
219 // 简单选择排序
220 void SelectSort_linklist(linklist &amp;l)
221 {
222     ElemType tmp;
223     linklist p,q,k;//P为工作指针，Q为指向最小元素的指针,k为前面指向第一个为排序元素的指针
224     p=l-&gt;next;q=p;k=p;
225     while (k)
226     {
227 
228     while (p)
229     {
230         if (p-&gt;data.key &lt; q-&gt;data.key )
231         {
232             q=p;
233         }
234         p=p-&gt;next;
235     }
236     if (k!=q)
237     {
238         tmp=k-&gt;data;
239         k-&gt;data=q-&gt;data;
240         q-&gt;data=tmp;
241     }
242     k=k-&gt;next;
243     p=k;
244     q=k;
245     }
246 }
247 //打印链表
248 void print_linklist(linklist l)
249 {
250     linklist p=l-&gt;next;
251     while (p)
252     {
253         cout&lt;&lt;p-&gt;data.key&lt;&lt;&quot; &quot;;
254         p=p-&gt;next;
255     }
256     cout&lt;&lt;endl;
257 }
258 // 链式直接插入排序
259 void InsertSort_linklist(linklist &amp;l)
260 {
261     linklist p,q,t;
262     p=l-&gt;next-&gt;next;//把P插入到链表L中
263     l-&gt;next-&gt;next=NULL;
264     q=l;
265     while (p)
266     {
267         while (q-&gt;next &amp;&amp; p-&gt;data.key &gt;q-&gt;next-&gt;data.key)
268             q=q-&gt;next;
269         if (!q)
270         {
271             q-&gt;next = p;
272             p=p-&gt;next;
273             p-&gt;next=NULL;
274         }
275         else
276         {
277             t=p;p=p-&gt;next;
278             t-&gt;next=q-&gt;next;
279             q-&gt;next=t;
280         }
281         q=l;
282     }
283 }
284 // 链式冒泡排序
285 void BubbleSort_linklist(linklist &amp;l)
286 {
287     linklist p=l-&gt;next,q,c;
288     q=p-&gt;next;
289     ElemType e;
290     c=p;
291     while (c)
292     {
293        while (q)
294     {
295 
296         if (p-&gt;data.key &gt; q-&gt;data.key )
297         {
298             e=p-&gt;data;
299             p-&gt;data=q-&gt;data;
300             q-&gt;data=e;
301         }
302         p=p-&gt;next;q=q-&gt;next;
303     }
304     p=l-&gt;next,q=p-&gt;next;
305     c=c-&gt;next;
306     }
307 
308 
309 }
310 int main()
311 {   cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;endl;
312     cout&lt;&lt;&quot;1.InsertSort():直接插入排序&quot;&lt;&lt;endl;
313     cout&lt;&lt;&quot;2.Bl.data[1]ubbleSort():冒泡排序&quot;&lt;&lt;endl;
314     cout&lt;&lt;&quot;3.SelectSort():直接选择排序&quot;&lt;&lt;endl;
315     cout&lt;&lt;&quot;4.ShellSort():希尔排序&quot;&lt;&lt;endl;
316     cout&lt;&lt;&quot;5.QSort():快速排序&quot;&lt;&lt;endl;
317     cout&lt;&lt;&quot;6.HeapSort():堆排序&quot;&lt;&lt;endl;
318     cout&lt;&lt;&quot;7.BinInsertSort():折半插入排序&quot;&lt;&lt;endl;
319     cout&lt;&lt;&quot;9.SelectSort_linklist():链式简单选择排序&quot;&lt;&lt;endl;
320     cout&lt;&lt;&quot;10.InsertSort_linklist():链式直接插入排序&quot;&lt;&lt;endl;
321     cout&lt;&lt;&quot;11.BubbleSort_linklist():链式冒泡排序&quot;&lt;&lt;endl;
322     cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;endl;
323 ll1:cout&lt;&lt;&quot;请输入您选择的函数序号&quot;&lt;&lt;endl;
324     int x;cin&gt;&gt;x;
325     SeqList l;
326     linklist l1;
327     switch(x)
328     {
329     case 1:
330     {
331     creatList(l);
332     cout&lt;&lt;&quot;直接插入排序前的结果&quot;&lt;&lt;endl;
333     print(l);
334     InsertSort(l);
335     cout&lt;&lt;&quot;直接插入排序后的结果&quot;&lt;&lt;endl;
336     print(l);
337     break;
338     }
339 
340     case 2:
341     {
342     creatList(l);
343     cout&lt;&lt;&quot;冒泡排序前的结果&quot;&lt;&lt;endl;
344     print(l);
345     BubbleSort(l);
346     cout&lt;&lt;&quot;冒泡排序后的结果&quot;&lt;&lt;endl;
347     print(l);
348        break;
349     }
350 
351     case 3:
352         {
353     creatList(l);
354     cout&lt;&lt;&quot;直接选择排序前的结果&quot;&lt;&lt;endl;
355     print(l);
356     SelectSort(l);
357     cout&lt;&lt;&quot;直接选择排序后的结果&quot;&lt;&lt;endl;
358     print(l);
359             break;
360         }
361     case 4:
362     creatList(l);
363     cout&lt;&lt;&quot;希尔排序前的结果&quot;&lt;&lt;endl;
364     print(l);
365     int dlta[3];dlta[0]=5;dlta[1]=3;dlta[2]=1;
366     ShellSort(l,dlta,3);
367     cout&lt;&lt;&quot;希尔排序后的结果&quot;&lt;&lt;endl;
368     print(l);
369         break;
370 
371     case 5:
372     creatList(l);
373     cout&lt;&lt;&quot;快速排序前的结果&quot;&lt;&lt;endl;
374     print(l);
375     QSort(l,1,8);
376     cout&lt;&lt;&quot;快速排序后的结果&quot;&lt;&lt;endl;
377     print(l);
378         break;
379 
380     case 6:
381         {
382     creatList(l);
383     cout&lt;&lt;&quot;堆排序前的结果&quot;&lt;&lt;endl;
384     print(l);
385     HeapSort(l);
386     cout&lt;&lt;&quot;堆排序后的结果&quot;&lt;&lt;endl;
387     print(l);
388       break;
389         }
390 
391     case 7:
392         {
393     creatList(l);
394     cout&lt;&lt;&quot;折半插入排序前的结果&quot;&lt;&lt;endl;
395     print(l);
396     BinInsertSort(l);
397     cout&lt;&lt;&quot;折半插入排序后的结果&quot;&lt;&lt;endl;
398     print(l);
399       break;
400         }
401     case 9:
402         {
403             createLinkList(l1);
404             cout&lt;&lt;&quot;链式简单选择排序之前：&quot;&lt;&lt;endl;
405             print_linklist(l1);
406             SelectSort_linklist(l1);
407             cout&lt;&lt;&quot;链式简单选择排序之后：&quot;&lt;&lt;endl;
408             print_linklist(l1);
409             break;
410         }
411     case 10:
412         {
413             createLinkList(l1);
414             cout&lt;&lt;&quot;链式直接插入排序之前：&quot;&lt;&lt;endl;
415             print_linklist(l1);
416             InsertSort_linklist(l1);
417             cout&lt;&lt;&quot;链式直接插入排序之后：&quot;&lt;&lt;endl;
418             InsertSort_linklist(l1);
419             break;
420         }
421 
422     case 11:
423         {
424             createLinkList(l1);
425             cout&lt;&lt;&quot;链式冒泡排序之前：&quot;&lt;&lt;endl;
426             print_linklist(l1);
427             BubbleSort_linklist(l1);
428             cout&lt;&lt;&quot;链式冒泡排序之后：&quot;&lt;&lt;endl;
429             print_linklist(l1);
430             break;
431         }
432 
433 
434 
435 
436     }
437     cout&lt;&lt;&quot;您是否还要继续测试其他函数？y/n&quot;&lt;&lt;endl;
438     fflush(stdin);
439     char z;
440     cin&gt;&gt;z;
441     if (z==&#39;y&#39;)
442         goto ll1;
443     else
444     return 0;
445 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-数据结构实验报告（五）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/14/数据结构实验报告（五）/">数据结构实验报告（五）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/14/数据结构实验报告（五）/" class="article-date">
  <time datetime="2018-08-14T02:48:00.000Z" itemprop="datePublished">2018-08-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>实验报告五 查找的相关操作</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #define INFINITY INT_MAX
  5 #define MAXSIZE 20
  6 
  7 using namespace std;
  8 //1.折半查找
  9 typedef int KeyType;
 10 typedef struct
 11 {
 12     KeyType key;
 13     char data1;
 14 }ElemType;
 15 typedef struct
 16 {
 17     ElemType data[MAXSIZE];
 18     int length;
 19 
 20 }SeqList;
 21 
 22 void createSeqList(SeqList &amp;l)
 23 {
 24     cout&lt;&lt;&quot;请输入关键字个数&quot;&lt;&lt;endl;
 25     cin&gt;&gt;l.length;
 26     cout&lt;&lt;&quot;请顺序输入一组有序的数据及其关键字（key,data1）&quot;&lt;&lt;endl;
 27     for (int i=1;i&lt;=l.length;i++)
 28     {
 29         scanf(&quot;%d%c&quot;,&amp;l.data[i].key,&amp;l.data[i].data1);
 30     }
 31 }
 32 
 33 int Search_Bin(SeqList &amp;l,KeyType key)
 34 {
 35    int low=1,high=l.length;
 36    int mid;
 37    while (low&lt;=high)
 38    {
 39        mid=(low+high)/2;
 40        if (key == l.data[mid].key)
 41         return mid;
 42        else if (key &lt; l.data[mid].key )
 43         high=mid-1;
 44        else
 45         low=mid+1;
 46    }
 47    return 0;
 48 }
 49 //2.二叉排序树
 50 typedef struct BiTNode
 51 {
 52     ElemType data;
 53     struct BiTNode *left,*right;
 54 }BiTNode,*BiTree;
 55 
 56 // 查找二叉排序树
 57 int SearchBST(BiTree t,KeyType key,BiTree f,BiTree &amp;p)
 58 {
 59     if (!t) {p=f;return 0;}
 60     else if (key==t-&gt;data.key){p=t;return 1;}
 61     else if (key &lt;t-&gt;data.key)
 62         return SearchBST(t-&gt;left,key,t,p);
 63     else return SearchBST(t-&gt;right,key,t,p);
 64 }
 65 // 插入一个数据到二叉排序树
 66 int InsertBST(BiTree &amp;t,ElemType e)
 67 {
 68     BiTree p,s;
 69     if (!SearchBST(t,e.key,NULL,p))
 70     {
 71         s=(BiTree)malloc(sizeof(BiTNode));
 72         s-&gt;data.key=e.key;
 73         s-&gt;data.data1=e.data1;
 74         s-&gt;left=s-&gt;right=NULL;
 75         if (!p)
 76             t=s;
 77         else if (e.key &lt; p-&gt;data.key )
 78             p-&gt;left=s;
 79         else
 80             p-&gt;right=s;
 81         return 1;
 82     }
 83     else
 84         return 0;
 85 }
 86 // 循环插入一组数据，建立二叉排序树
 87 void InsertBST_for()
 88 {
 89     void InOrderTraverse(BiTree &amp;t);
 90     void DeleteBST(BiTree &amp;t,KeyType key);
 91     BiTree t;
 92     t=NULL;
 93     ElemType e;
 94     int n;
 95     cout&lt;&lt;&quot;请输入您要输入的数据个数&quot;&lt;&lt;endl;
 96     cin&gt;&gt;n;
 97     cout&lt;&lt;&quot;请依次输入您要插入的数据及其关键字（key,data1）&quot;&lt;&lt;endl;
 98     for (int i=0;i&lt;n;i++)
 99     {
100       cin&gt;&gt;e.key&gt;&gt;e.data1;
101       InsertBST(t,e);
102     }
103      cout&lt;&lt;&quot;中序遍历输出的结果为：&quot;&lt;&lt;endl;
104      InOrderTraverse(t);
105      cout&lt;&lt;&quot;请输入您要删除的某一元素的关键字&quot;&lt;&lt;endl;
106      KeyType key;
107      cin&gt;&gt;key;
108      DeleteBST(t,key);
109      cout&lt;&lt;&quot;删除指定元素后的中序遍历结果为：&quot;&lt;&lt;endl;
110      InOrderTraverse(t);
111 
112 
113 
114 
115 }
116 // 中序遍历二叉排序树
117 void InOrderTraverse(BiTree &amp;t)
118 {
119     if (t)
120     {
121         InOrderTraverse(t-&gt;left);
122         cout&lt;&lt;t-&gt;data.key&lt;&lt;&quot; &quot;;
123         InOrderTraverse(t-&gt;right);
124     }
125 }
126 // 二叉排序树删除:删除某一指定结点
127 int Delete(BiTree &amp;p)
128 {
129     BiTree q,s;
130     if (!p-&gt;right)
131     {
132         q=p;
133         p=p-&gt;left;
134         free(q);
135     }
136     else if (!p-&gt;right)
137     {
138         q=p;
139         p=p-&gt;right;
140         free(q);
141     }
142     else
143     {
144         q=p;
145         s=p-&gt;left;
146         while (s-&gt;right)
147         {
148             q=s;
149             s=s-&gt;right;
150         }
151         p-&gt;data.key=s-&gt;data.key;
152         p-&gt;data.data1=s-&gt;data.data1;
153 
154         if (q!=p)
155             q-&gt;right=s-&gt;left;
156         else
157             q-&gt;left=s-&gt;left;
158         delete(s);
159 
160     }
161     return 1;
162 }
163 // 删除某关键字
164 int DeleteBST(BiTree &amp;t,KeyType key)
165 {
166     if (!t)
167         return 0;
168     else
169     {
170         if (key == t-&gt;data.key )
171             return Delete(t);
172         else if (key &lt; t-&gt;data.key)
173         return DeleteBST(t-&gt;left,key);
174         else
175             return DeleteBST(t-&gt;right,key);
176     }
177     return 1;
178 }
179 // AVL
180 typedef struct BSTNode
181 {
182     ElemType data;
183     int bf;
184     struct BSTNode *left,*right;
185 }BSTNode,*BSTree;
186 
187 // 右旋
188 void R_Rotate(BSTree &amp;p)
189 {
190     BSTree lc;
191     lc=p-&gt;left;
192     p-&gt;left=lc-&gt;right;
193     lc-&gt;right=p;
194     p=lc;
195 
196 }
197 //左旋
198 void L_Rotate(BSTree &amp;p)
199 {
200     BSTree lc;
201     lc=p-&gt;right;
202     p-&gt;right=lc-&gt;left;
203     lc-&gt;left=p;
204     p=lc;
205 }
206 //左平衡
207 void LeftBalance(BSTree &amp;t)
208 {
209     BSTree lc,rd;
210     lc=t-&gt;left;
211     switch(lc-&gt;bf)
212     {
213     case 1:
214         t-&gt;bf=lc-&gt;bf=0;
215         R_Rotate(t);
216         break;
217     case -1:
218         rd=lc-&gt;right;
219         switch(rd-&gt;bf)
220         {
221         case 1:
222             t-&gt;bf=-1;
223             lc-&gt;bf=0;
224             break;
225         case 0:
226             t-&gt;bf=lc-&gt;bf=0;
227             break;
228         case -1:
229             t-&gt;bf=0;
230             lc-&gt;bf=1;
231             break;
232         }
233         rd-&gt;bf=0;
234         L_Rotate(t-&gt;left);
235         R_Rotate(t);
236     }
237 
238 }
239 //右平衡
240 void RightBalance(BSTree &amp;t)
241 {
242     BSTree lc,rd;
243     lc=t-&gt;right;
244     switch(lc-&gt;bf)
245     {
246     case 1:
247         rd=lc-&gt;left;
248         switch(rd-&gt;bf)
249         {
250         case 1:
251             t-&gt;bf=0;
252             lc-&gt;bf=-1;
253             break;
254         case 0:
255             t-&gt;bf=lc-&gt;bf=0;
256             break;
257         case -1:
258             t-&gt;bf=1;
259             lc-&gt;bf=0;
260             break;
261         }
262         rd-&gt;bf=0;
263         R_Rotate(t-&gt;right);
264         L_Rotate(t);
265         break;
266     case -1:
267         t-&gt;bf=lc-&gt;bf=0;
268         L_Rotate(t);
269     }
270 
271 }
272 //插入建立平衡二叉排序树
273 int InsertAVL(BSTree &amp;t,ElemType e,bool taller)
274 {
275     if (!t)
276     {
277         t=(BSTree )malloc(sizeof(BSTNode));
278         t-&gt;bf=0;
279         t-&gt;left=t-&gt;right=NULL;
280         t-&gt;data.data1=e.data1;
281         t-&gt;data.key=e.key;
282         taller=true;//树长高则为正
283     }
284     else
285     {
286         if (e.key==t-&gt;data.key)
287         {
288             taller=false;
289             return 0;
290         }
291         if (e.key &lt; t-&gt;data.key)
292         {
293             if (!InsertAVL(t-&gt;left,e,taller))
294                 return 0;
295                 if (taller)
296                 {
297                     switch(t-&gt;bf)
298                     {
299                         case 1:
300                             LeftBalance(t);
301                             taller=false;
302                             break;
303                         case 0:
304                             t-&gt;bf=1;
305                             taller=true;
306                             break;
307                         case -1:
308                             t-&gt;bf=0;
309                             taller=false;
310                             break;
311                     }
312                 }
313         }
314         else
315         {
316             if (!InsertAVL(t-&gt;right,e,taller))
317                 return 0;
318                 if (taller)
319                 {
320                     switch(t-&gt;bf)
321                     {
322                         case 1:
323                             t-&gt;bf=0;
324                             taller=false;
325                             break;
326                         case 0:
327                             t-&gt;bf=-1;
328                             taller=true;
329                             break;
330                         case -1:
331                             RightBalance(t);
332                             taller=false;
333                             break;
334                     }
335                 }
336         }
337     }
338     return 1;
339 }
340 // 中序遍历平衡二叉排序树
341 void InOrderTraverse_BST(BSTree &amp;t)
342 {
343     if (t)
344     {
345         InOrderTraverse_BST(t-&gt;left);
346         cout&lt;&lt;t-&gt;data.key&lt;&lt;&quot; &quot;;
347         InOrderTraverse_BST(t-&gt;right);
348     }
349 }
350 // 线性探测法建立散列表
351 typedef struct
352 {
353     ElemType data[MAXSIZE];
354     int count;
355 }HashTable;
356 // 哈希函数
357 int Hash(KeyType k)
358 {
359     int p=13;
360     return k%13;
361 }
362 //发生冲突之后求出下一探查地址
363 void collision(HashTable h,int &amp;p)
364 {
365     p=(p+1+MAXSIZE)%MAXSIZE;
366 }
367 // 在哈希表中查找某关键字
368 int SearchHash(HashTable h,KeyType key,int &amp;p)
369 {
370     p=Hash(key);// 哈西地址
371     while (h.data[p].key!=NULL &amp;&amp; key!=h.data[p].key )
372     collision(h,p);
373 
374     if (key==h.data[p].key)
375         return 1;
376     else
377         return 0;
378 
379 }
380 // 插入机建立线性探测哈希表
381 int InsertHash(HashTable &amp;h,ElemType e)
382 {
383     int p;
384     h.count=0;
385     if (SearchHash(h,e.key,p))
386         return 0;
387     else
388         h.data[p].key=e.key;
389         h.data[p].data1=e.data1;
390         h.count++;
391         return 1;
392 }
393 // 遍历输出线线性探测哈希表
394 void TraverseHash(HashTable h)
395 {
396     int i;
397     for (i=0;i&lt;MAXSIZE;i++)
398         cout&lt;&lt;&quot;(&quot;&lt;&lt;h.data[i].key&lt;&lt;&quot;,&quot;&lt;&lt;h.data[i].data1&lt;&lt;&quot;)&quot;;
399     cout&lt;&lt;endl;
400 }
401 
402 // 外拉链法建立哈希表
403 typedef struct Node
404 {
405     ElemType e;
406     struct Node *next;
407 }Node,HashTable2[MAXSIZE];
408 // 查找外拉链表
409 int searchHash2(HashTable2 h,ElemType e,int &amp;p)
410 {
411     p=Hash(e.key);// 哈西地址
412     Node *q;
413     q=h[p].next;
414     while (q)
415     {
416        if (q-&gt;e.key==e.key)
417             return 1;
418         q=q-&gt;next;
419     }
420     return 0;
421 }
422 // 插入建立外拉链表
423 int InsertHash2(HashTable2 h,ElemType e)
424 {
425     int p;
426     Node *q;
427     if (searchHash2(h,e,p))
428         return 0;
429     else
430     {
431        q=(Node*)malloc(sizeof(Node));
432        q-&gt;e.key=e.key;
433        q-&gt;e.data1=e.data1;
434        q-&gt;next=h[p].next;//头插法插入元素
435        h[p].next=q;
436     }
437     return 1;
438 }
439 // 遍历外拉链表
440 void TraverseHash2(HashTable2 h)
441 {
442     int i;
443     Node *p;
444     for (i=0;i&lt;MAXSIZE;i++)
445     {
446        p=h[i].next;
447        while (p)
448        {
449            cout&lt;&lt;&quot;(&quot;&lt;&lt;p-&gt;e.key&lt;&lt;&quot;,&quot;&lt;&lt;p-&gt;e.data1&lt;&lt;&quot;)&quot;;
450            p=p-&gt;next;
451        }
452     }
453 }
454 
455 
456 int main()
457 {   cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;endl;
458     cout&lt;&lt;&quot;1.Search_Bin():采用折半查找实现某一已知的关键字的查找&quot;&lt;&lt;endl;
459     cout&lt;&lt;&quot;2.InsertBST()&amp;&amp;DeleteBST():插入算法建立二叉排序树并删除某指定元素&quot;&lt;&lt;endl;
460     cout&lt;&lt;&quot;3.InsertAVL():建立AVL树并实现删除某一指定关键字元素&quot;&lt;&lt;endl;
461     cout&lt;&lt;&quot;4.InsertHash():线性探测法建立哈希表&quot;&lt;&lt;endl;
462     cout&lt;&lt;&quot;5.InsertHash2():外拉链法建立哈希表&quot;&lt;&lt;endl;
463     cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;endl;
464 ll1:cout&lt;&lt;&quot;请输入您选择的函数序号&quot;&lt;&lt;endl;
465     int x;cin&gt;&gt;x;
466     ElemType e;int n;
467     switch(x)
468     {
469     case 1:
470     {
471     SeqList l;
472     createSeqList(l);
473     cout&lt;&lt;&quot;请输入任一关键字&quot;&lt;&lt;endl;
474     KeyType key;
475     cin&gt;&gt;key;
476     int location=Search_Bin(l,key);
477     printf(&quot;查找位置为：%d\n&quot;,location);
478     break;
479     }
480 
481     case 2:
482     {
483        InsertBST_for();
484        break;
485     }
486 
487     case 3:
488         {
489             BSTree t1;
490             t1=NULL;
491             cout&lt;&lt;&quot;请输入数据个数&quot;&lt;&lt;endl;
492             cin&gt;&gt;n;
493             cout&lt;&lt;&quot;请输入一组数据（key,data1）以建立平衡二叉树&quot;&lt;&lt;endl;
494             for (int i=0;i&lt;n;i++)
495             {
496                 cin&gt;&gt;e.key&gt;&gt;e.data1;
497                 InsertAVL(t1,e,false);
498             }
499             cout&lt;&lt;&quot;建立结束，现在中序遍历&quot;&lt;&lt;endl;
500             InOrderTraverse_BST(t1);
501             break;
502         }
503     case 4:
504         HashTable h;
505         for (int i=0;i&lt;MAXSIZE;i++)
506     {
507       h.data[i].key=0;
508       h.data[i].data1=&#39;z&#39;;
509     }
510         cout&lt;&lt;&quot;请输入元素个数&quot;&lt;&lt;endl;
511         cin&gt;&gt;n;
512         cout&lt;&lt;&quot;请输入一组关键字（key,data1）&quot;&lt;&lt;endl;
513         for (int i=0;i&lt;n;i++)
514         {
515             cin&gt;&gt;e.key&gt;&gt;e.data1;
516             InsertHash(h,e);
517         }
518         cout&lt;&lt;&quot;建立结束，遍历哈希表,(0,z)表示NULL&quot;&lt;&lt;endl;
519         TraverseHash(h);
520 
521         break;
522 
523     case 5:
524         HashTable2 h1;
525         for (int i=0;i&lt;MAXSIZE;i++)
526     {
527      h1[i].next=NULL;
528     }
529         cout&lt;&lt;&quot;请输入元素个数&quot;&lt;&lt;endl;
530         cin&gt;&gt;n;
531         cout&lt;&lt;&quot;请输入一组关键字（key,data1）&quot;&lt;&lt;endl;
532         for (int i=0;i&lt;n;i++)
533         {
534             cin&gt;&gt;e.key&gt;&gt;e.data1;
535             InsertHash2(h1,e);
536         }
537         cout&lt;&lt;&quot;建立结束，遍历哈希表&quot;&lt;&lt;endl;
538         TraverseHash2(h1);
539         break;
540     }
541     cout&lt;&lt;&quot;您是否还要继续测试其他函数？y/n&quot;&lt;&lt;endl;
542     fflush(stdin);
543     char z;
544     cin&gt;&gt;z;
545     if (z==&#39;y&#39;)
546         goto ll1;
547     else
548     return 0;
549 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 John Doe 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>