<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-排序题目练习（Ignatius and the Pincess IV、排序、Clock、排名）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/排序题目练习（Ignatius and the Pincess IV、排序、Clock、排名）/">排序题目练习（Ignatius and the Pincess IV、排序、Clock、排名）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/排序题目练习（Ignatius and the Pincess IV、排序、Clock、排名）/" class="article-date">
  <time datetime="2018-08-21T04:50:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>HDJ排序题目练习</p>
<p>HDU Sort</p>
<ol>
<li><a href="https://cn.vjudge.net/problem/HDU-1029" target="_blank" rel="noopener">HDU 1029</a> Ignatius and the Pincess IV</li>
<li><a href="https://cn.vjudge.net/problem/HDU-1106" target="_blank" rel="noopener">HDU 1106</a> 排序</li>
<li><a href="https://cn.vjudge.net/problem/HDU-1209" target="_blank" rel="noopener">HDU 1209</a> Clock</li>
<li><a href="https://cn.vjudge.net/problem/HDU-1236" target="_blank" rel="noopener">HDU 1236</a> 排名      </li>
</ol>
<p><a href="https://cn.vjudge.net/problem/HDU-1280" target="_blank" rel="noopener"><strong>Ignatius and the  Pincess IV</strong></a></p>
<p>Problem Description</p>
<p>“OK, you are not too bad, em… But you can never pass the next test.”<br>feng5166 says.  </p>
<p>“I will tell you an odd number N, and then N integers. There will be a special<br>integer among them, you have to tell me which integer is the special one after<br>I tell you all the integers.” feng5166 says.  </p>
<p>“But what is the characteristic of the special integer?” Ignatius asks.  </p>
<p>“The integer will appear at least (N+1)/2 times. If you can’t find the right<br>integer, I will kill the Princess, and you will be my dinner, too.<br>Hahahaha…..” feng5166 says.  </p>
<p>Can you find the special integer for Ignatius?</p>
<p><strong>  
</strong></p>
<p>Input</p>
<p>The input contains several test cases. Each test case contains two lines. The<br>first line consists of an odd integer N(1&lt;=N&lt;=999999) which indicate the<br>number of the integers feng5166 will tell our hero. The second line contains<br>the N integers. The input is terminated by the end of file.</p>
<p><strong>  
</strong></p>
<p>Output</p>
<p>For each test case, you have to output only one line which contains the<br>special number you have found.</p>
<p><strong>  
</strong></p>
<p>Sample Input</p>
<p>5 1 3 2 3 3 11 1 1 1 1 1 5 5 5 5 5 5 7 1 1 1 1 1 1 1</p>
<p><strong>  
</strong></p>
<p>Sample Output</p>
<p>3 5 1</p>
<p>思路：用map存储输入数据并计算每个数出现的次数后，map容器按照key自动排序，但value的排序需要通过自定义的结构体pai进行转储，然后对结构体进行排序便得到value最大的数字。</p>
<p>注意map进行循环遍历的方法以及调用key和value的方法。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;queue&gt;
 4 #include &lt;string.h&gt;
 5 #include &lt;algorithm&gt;
 6 #include &lt;map&gt;
 7 
 8 using namespace std;
 9 
10 /*
11 找到最少出现（n+1）/2次的special number
12 */
13 const int maxn=1000000;
14 map&lt;int,int&gt; m;
15 struct pai
16 {
17     int key,value;
18 }p[maxn];
19 bool cmp(const pai &amp;a,const pai &amp;b)
20 {
21     return a.value&lt;b.value;
22 }
23 int main()
24 {
25     int n,x,i;
26     map&lt;int,int&gt;::iterator iter;
27     while (cin &gt;&gt;n)
28     {
29         m.clear(); // map容器的清空方法？
30        // m.erase(m.begin(),m.end());
31         for (int i=0;i&lt;n;i++)
32         {
33             cin &gt;&gt;x;
34             m[x]++;
35         }
36         // 把map中的键值对转储到pair中形成结构体数组
37         int k=0;
38         iter=m.begin();
39         while (iter!=m.end())
40         {
41             p[k].key=iter-&gt;first;
42             p[k].value=iter-&gt;second;
43             k++;iter++;
44         }
45 
46         sort(p,p+k,cmp);
47         cout &lt;&lt;p[k-1].key&lt;&lt;endl;
48     }
49     return 0;
50 }
</code></pre><p>map的基本使用方法：<a href="https://www.cnblogs.com/empty16/p/6395813.html" target="_blank" rel="noopener">https://www.cnblogs.com/empty16/p/6395813.html</a></p>
<p>map的迭代遍历方法：<a href="https://blog.csdn.net/u010429424/article/details/75332700" target="_blank" rel="noopener">https://blog.csdn.net/u010429424/article/details/75332700</a></p>
<p><strong>排序</strong></p>
<p>Problem Description</p>
<p>输入一行数字，如果我们把这行数字中的’5’都看成空格，那么就得到一行用空格分割的若干非负整数（可能有些整数以’0’开头，这些头部的’0’应该被忽略掉，除非这个整数就是由若干个’0’组成的，这时这个整数就是0）。  </p>
<p>你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出。  </p>
<p>Input</p>
<p>输入包含多组测试用例，每组输入数据只有一行数字（数字之间没有空格），这行数字的长度不大于1000。  </p>
<p>输入数据保证：分割得到的非负整数不会大于100000000；输入数据不可能全由’5’组成。</p>
<p>Output</p>
<p>对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空格分开，每组输出占一行。</p>
<p>Sample Input</p>
<p>0051231232050775</p>
<p>Sample Output</p>
<p>0 77 12312320</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;queue&gt;
 4 #include &lt;string.h&gt;
 5 #include &lt;algorithm&gt;
 6 #include &lt;map&gt;
 7 #include &lt;vector&gt;
 8 
 9 using namespace std;
10 /*
11 可能会有连续的5出现，不应该只跳过一个五
12 
13 最后一个数字可能不是5，所以\0也是一个分界符
14 */
15 vector&lt;int&gt; a;
16 char s[1001];
17 void push_into_vector(int i,int j)
18 {
19     // s[i-j-1]进入vector中
20     if (i==j) return ;
21     int sum=0;
22     int k=1;
23     int t=j-i;
24     while (t--)
25     {
26         sum+=(s[--j]-&#39;0&#39;)*k;
27         k=k*10;
28     }
29     a.push_back(sum);
30 }
31 int main()
32 {
33 
34     int i,j,k;
35     while (cin&gt;&gt;s)
36     {
37         i=0;j=0;
38         while (!a.empty()) a.pop_back();
39         while (s[i]!=&#39;\0&#39;)
40         {
41             while (s[j]!=&#39;5&#39;&amp;&amp;s[j]!=&#39;\0&#39;) j++;
42             k=j;
43             while (s[k]==&#39;5&#39;) k++;
44             push_into_vector(i,j);
45             i=k;j=i;
46         }
47         sort(a.begin(),a.end());
48         for (i=0;i&lt;a.size()-1;i++) cout &lt;&lt; a[i] &lt;&lt;&quot; &quot;;
49         cout &lt;&lt; a[i]&lt;&lt;endl;
50     }
51     return 0;
52 }
</code></pre><p><strong>Clock</strong></p>
<p>Problem Description</p>
<p>There is an analog clock with two hands: an hour hand and a minute hand. The<br>two hands form an angle. The angle is measured as the smallest angle between<br>the two hands. The angle between the two hands has a measure that is greater<br>than or equal to 0 and less than or equal to 180 degrees.  </p>
<p>Given a sequence of five distinct times written in the format hh : mm , where<br>hh are two digits representing full hours (00 &lt;= hh &lt;= 23) and mm are two<br>digits representing minutes (00 &lt;= mm &lt;= 59) , you are to write a program that<br>finds the median, that is, the third element of the sorted sequence of times<br>in a nondecreasing order of their associated angles. Ties are broken in such a<br>way that an earlier time precedes a later time.  </p>
<p>For example, suppose you are given a sequence (06:05, 07:10, 03:00, 21:00,<br>12:55) of times. Because the sorted sequence is (12:55, 03:00, 21:00, 06:05,<br>07:10), you are to report 21:00.</p>
<p><strong>  
</strong></p>
<p>Input</p>
<p>The input consists of T test cases. The number of test cases (T) is given on<br>the first line of the input file. Each test case is given on a single line,<br>which contains a sequence of five distinct times, where times are given in the<br>format hh : mm and are separated by a single space.</p>
<p><strong>  
</strong></p>
<p>Output</p>
<p>Print exactly one line for each test case. The line is to contain the median<br>in the format hh : mm of the times given. The following shows sample input and<br>output for three test cases.</p>
<p><strong>  
</strong></p>
<p>Sample Input</p>
<p>3 00:00 01:00 02:00 03:00 04:00 06:05 07:10 03:00 21:00 12:55 11:05 12:05<br>13:05 14:05 15:05</p>
<p><strong>  
</strong></p>
<p>Sample Output</p>
<p>02:00 21:00 14:05</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;queue&gt;
 4 #include &lt;string.h&gt;
 5 #include &lt;algorithm&gt;
 6 #include &lt;map&gt;
 7 #include &lt;vector&gt;
 8 #include &lt;math.h&gt;
 9 
10 using namespace std;
11 /*
12 abs:int 
13 fabs:float 
14 这里除以2极有可能是浮点类型的
15 */
16 struct node
17 {
18     int h,m;
19     float angle;
20 }a[6];
21 int cmp(node x,node y)
22 {
23     if(x.angle!=y.angle)
24     return x.angle&lt;y.angle;
25     return x.h&lt;y.h; // 角度相同时按照小时进行排序
26 }
27 int main()
28 {
29     int t,hh;
30     while (cin&gt;&gt;t)
31     {
32         while (t--)
33         {
34             for (int i=0;i&lt;5;i++)
35             {
36                 scanf(&quot;%d:%d&quot;,&amp;a[i].h,&amp;a[i].m);
37                 // 作为整型的输入方式即可，用字符串太麻烦
38             //    cout &lt;&lt; a[i].h&lt;&lt;&quot;:&quot;&lt;&lt;a[i].m&lt;&lt;endl;
39 
40                 if (a[i].h&gt;=12) hh=a[i].h-12;
41                 else hh=a[i].h;
42                     a[i].angle=fabs(30.0*(hh)-6.0*a[i].m+a[i].m/2.0);
43                 if (a[i].angle&gt;180) a[i].angle=360-a[i].angle;
44             }
45             sort(a,a+5,cmp);
46             printf(&quot;%02d:%02d\n&quot;,a[2].h,a[2].m);
47 
48         }
49     }
50 
51 
52     return 0;
53 }
</code></pre><p>  <strong>排名</strong></p>
<p>今天的上机考试虽然有实时的Ranklist，但上面的排名只是根据完成的题数排序，没有考虑<br>每题的分值，所以并不是最后的排名。给定录取分数线，请你写程序找出最后通过分数线的<br>考生，并将他们的成绩按降序打印。</p>
<p>Input</p>
<p>测试输入包含若干场考试的信息。每场考试信息的第1行给出考生人数N ( 0 &lt; N<br>&lt; 1000 )、考题数M ( 0 &lt; M &lt; = 10 )、分数线（正整数）G；第2行排序给出第1题至第M题的正整数分值；以下N行，每行给出一<br>名考生的准考证号（长度不超过20的字符串）、该生解决的题目总数m、以及这m道题的题号<br>（题目号由1到M）。<br>当读入的考生人数为0时，输入结束，该场考试不予处理。</p>
<p><strong>  
</strong></p>
<p>Output</p>
<p>对每场考试，首先在第1行输出不低于分数线的考生人数n，随后n行按分数从高<br>到低输出上线考生的考号与分数，其间用1空格分隔。若有多名考生分数相同，则按他们考<br>号的升序输出。</p>
<p><strong>  
</strong></p>
<p>Sample Input</p>
<p>4 5 25 10 10 12 13 15 CS004 3 5 1 3 CS003 5 2 4 1 3 5 CS002 2 1 2 CS001 3 2 3<br>5 1 2 40 10 30 CS001 1 2 2 3 20 10 10 10 CS000000000000000001 0<br>CS000000000000000002 2 1 2 0</p>
<p><strong>  
</strong></p>
<p>Sample Output</p>
<p>3 CS003 60 CS001 37 CS004 37 0 1 CS000000000000000002 20</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;queue&gt;
 4 #include &lt;string.h&gt;
 5 #include &lt;algorithm&gt;
 6 #include &lt;map&gt;
 7 #include &lt;vector&gt;
 8 #include &lt;math.h&gt;
 9 
10 /*
11 成绩相同时按照考号升序进行排序；
12 考察的主要是结构体数据的排序过程。
13 
14 */
15 using namespace std;
16 int n,m,line;
17 int grade[11];
18 struct stu
19 {
20     char sno[50];
21     int num;
22     int no[11];
23 }s[1001];
24 bool cmp(const stu &amp;a,const stu &amp;b)
25 {
26     if (a.num!=b.num)
27     return a.num &gt; b.num;
28     else
29     {
30         return strcmp(a.sno,b.sno)&lt;0;
31     }
32 
33 }
34 int main()
35 {
36     while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;line)!=EOF)
37     {
38         if (n==0) break;
39         for (int i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;grade[i]);
40 
41         int sum;
42         int cnt=0;
43         for (int i=0;i&lt;n;i++)
44         {
45             scanf(&quot;%s %d&quot;,&amp;s[i].sno,&amp;s[i].num);
46             sum=0;
47             for (int j=0;j&lt;s[i].num;j++)
48             {
49                 scanf(&quot;%d&quot;,&amp;s[i].no[j]);
50                 sum+=grade[s[i].no[j]-1];
51             }
52             s[i].num=sum;
53             if (sum&gt;=line) cnt++;
54         }
55         sort(s,s+n,cmp);
56         int i=0;
57         printf(&quot;%d\n&quot;,cnt);
58         while (n--&amp;&amp;s[i].num&gt;=line)
59         {
60             printf(&quot;%s %d\n&quot;,s[i++].sno,s[i].num);
61         }
62 
63 
64     }
65 
66 
67     return 0;
68 }
</code></pre><p>八大排序算法复习</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-下雨日有悟" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/下雨日有悟/">下雨日有悟</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/下雨日有悟/" class="article-date">
  <time datetime="2018-08-20T23:49:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>外面的空气刚刚好。</p>
<p>出去溜达了一圈，又反思自己的状态。我现在天天思考的时间比实际行动的时间还要多的多啊，如果能够像男孩子一样想要什么就去勇敢啊地追求该多么好啊。所以，别给自己这么多有的没的，该做的就马上去做，没有必要写在纸上，你知道自己是在拖延而已。主次难道你还能分不清楚吗？这么大的人了，拖延症还需要妈妈叮嘱吗？所以又照例骂了自己一顿，我觉得不是打鸡汤的问题，而是习惯（思维上的习惯和行为上的习惯）的问题。遇到问题就想办法解决，天天想着玩、想着买衣服，不是在消费就是在堕落而已。</p>
<p>做你喜欢的事情，对自己狠心一点。作为一个女孩子，社会对我们的要求就是如此地苛刻，那么就别啰里啰嗦地，想要什么就去做吧~加油二萌！！~成为你想要成为的样子吧~</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-codeforces 1006" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/codeforces 1006/">codeforces 1006</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/codeforces 1006/" class="article-date">
  <time datetime="2018-08-20T18:23:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>div3 1006 E dfs系列</p>
<p>我的解法：</p>
<p>中规中矩但wa+timelimit了，估计是算法效率太低。</p>
<p>！！！！这个序列只需要递归一遍，从根节点开始，然后根据输入的查询查找序列即可</p>
<pre><code> 1 #include&lt;bits/stdc++.h&gt;
 2  
 3 using namespace std;
 4 const int maxn=200001;
 5 vector&lt;int&gt; que[maxn],ans;//记录每个节点的孩子结点
 6 int u,k,n,q,x,cnt;
 7 bool dfs(int index)
 8 {
 9 // cnt:搜索到孩子个数
10 if (cnt==k)
11 {
12 ans.push_back(index); return true;
13 }
14 if (index&gt;n) return false;
15 // cout &lt;&lt;que[index].size()&lt;&lt;&quot;11&quot;&lt;&lt;endl;
16 for (int i=0;i&lt;que[index].size();i++) // 遍历孩子结点
17 {
18 cnt++;
19 // cout&lt;&lt;&quot;index:&quot;&lt;&lt;index&lt;&lt;&quot;,cnt:&quot;&lt;&lt;cnt&lt;&lt;&quot;,que[index][i]&quot;&lt;&lt;que[index][i]&lt;&lt;endl;
20 if (dfs(que[index][i])) return true;
21 }
22  
23 }
24 int main()
25 {
26 while (scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF)
27 {
28 for (int i=1;i&lt;=n;i++) que[i].clear();
29 for (int i=2;i&lt;=n;i++)
30 {
31 cin&gt;&gt;x;
32 que[x].push_back(i);
33 }
34 ans.clear();
35 while (q--)
36 {
37 cin&gt;&gt;u&gt;&gt;k;//从u点为根开始先序遍历的第k个结点的序号，深搜
38 cnt=1;
39 if (!dfs(u)) ans.push_back(-1);
40 }
41 for (int i=0;i&lt;ans.size();i++) cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
42 }
43  
44 return 0;
45 }







  1 #include &lt;bits/stdc++.h&gt;
  2  
  3 using namespace std;
  4  
  5 int v1[200000 + 1];
  6 int v2[200000 + 1];
  7 int v3[200000 + 1];
  8 vector &lt;int&gt; adjList[200000 + 1];
  9 int cont;
 10  
 11 int dfs(int nodo) {
 12 v1[cont] = nodo;
 13 ++cont;
 14 v3[nodo] = cont;
 15  
 16 int suma = 0;
 17 for(int i = 0; i &lt; adjList[nodo].size(); i++) {
 18 suma += dfs(adjList[nodo][i]);
 19 }
 20  
 21 v2[nodo] += suma+1;
 22 return v2[nodo];
 23 }
 24  
 25 int main() {
 26  
 27 int n,q;
 28 scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
 29  
 30 int aux;
 31 for (int i = 1; i &lt; n; i++) {
 32 scanf(&quot;%d&quot;, &amp;aux);
 33 adjList[aux-1].push_back(i);
 34 }
 35  
 36 cont = 0;
 37 dfs(0);
 38  
 39 int a,b;
 40 while (q--) {
 41 scanf(&quot;%d%d&quot;,&amp;a, &amp;b);
 42 if (v2[a-1] &gt;= b)
 43 cout &lt;&lt; v1[v3[a-1]-2+b]+1 &lt;&lt; endl;
 44 else
 45 cout &lt;&lt; -1 &lt;&lt; endl;
 46 }
 47  
 48 return 0;
 49 }
 50 #include&lt;bits/stdc++.h&gt;
 51  
 52 using namespace std;
 53  
 54 const int maxn=200001;
 55  
 56 vector&lt;int&gt; que[maxn];
 57 int child[maxn],order[maxn],ans[maxn];//记录每个节点的孩子结点
 58 int u,k,n,q,x,cnt;
 59  
 60 int dfs(int index)
 61 {
 62 ans[cnt++]=index;//依次存放以0为根的序列
 63 order[index]=cnt; // index在最终的序列中为第几个位置
 64  
 65 int sum=0;
 66 for (int i=0;i&lt;que[index].size();i++) // 遍历孩子结点
 67 {
 68 // cout&lt;&lt;&quot;index:&quot;&lt;&lt;index&lt;&lt;&quot;,que[index][i]：&quot;&lt;&lt;que[index][i]&lt;&lt;endl;
 69 sum+=dfs(que[index][i]);
 70 }
 71 child[index]=sum+1;
 72 return child[index];//以index为根节点的子节点总个数
 73 }
 74 int main()
 75 {
 76 while (scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF)
 77 {
 78 /* 全局变量会默认地初始化为0 而局部变量不会 有内存就是任性
 79 for (int i=1;i&lt;=n;i++) que[i].clear();
 80 ans.clear();
 81 memset(child,0,sizeof(child));
 82 memset(order,0,sizeof(order));
 83 */
 84 for (int i=2;i&lt;=n;i++)
 85 {
 86 cin&gt;&gt;x;
 87 que[x].push_back(i);
 88 }
 89  
 90 cnt=0;
 91 dfs(1);
 92 // for (int i=0;i&lt;ans.size();i++) cout &lt;&lt; ans[i] &lt;&lt;&quot; &quot;; cout &lt;&lt; endl;
 93  
 94 while (q--)
 95 {
 96 cin&gt;&gt;u&gt;&gt;k;//从u点为根开始先序遍历的第k个结点的序号，深搜
 97 if (child[u]&gt;=k)
 98 {
 99 cout &lt;&lt; ans[order[u]+k-2] &lt;&lt; endl;
100 }
101 else
102 cout &lt;&lt; -1 &lt;&lt; endl;
103 }
104 }
105 return 0;
106 }
</code></pre><p>A. New Year Transportation</p>
<p>time limit per test2 seconds</p>
<p>memory limit per test256 megabytes</p>
<p>inputstandard input</p>
<p>outputstandard output</p>
<p>New Year is coming in Line World! In this world, there are n cells numbered by<br>integers from 1 to n, as a 1 × n board. People live in cells. However, it was<br>hard to move between distinct cells, because of the difficulty of escaping the<br>cell. People wanted to meet people who live in other cells.</p>
<p>So, user tncks0121 has made a transportation system to move between these<br>cells, to celebrate the New Year. First, he thought of n - 1 positive integers<br>a1, a2, …, an - 1. For every integer i where 1 ≤ i ≤ n - 1 the condition 1 ≤<br>ai ≤ n - i holds. Next, he made n - 1 portals, numbered by integers from 1 to<br>n - 1. The i-th (1 ≤ i ≤ n - 1) portal connects cell i and cell (i + ai), and<br>one can travel from cell i to cell (i + ai) using the i-th portal.<br>Unfortunately, one cannot use the portal backwards, which means one cannot<br>move from cell (i + ai) to cell i using the i-th portal. It is easy to see<br>that because of condition 1 ≤ ai ≤ n - i one can’t leave the Line World using<br>portals.</p>
<p>Currently, I am standing at cell 1, and I want to go to cell t. However, I<br>don’t know whether it is possible to go there. Please determine whether I can<br>go to cell t by only using the construted transportation system.</p>
<p>Input</p>
<p>The first line contains two space-separated integers n (3 ≤ n ≤ 3 × 104) and t<br>(2 ≤ t ≤ n) — the number of cells, and the index of the cell which I want to<br>go to.</p>
<p>The second line contains n - 1 space-separated integers a1, a2, …, an - 1 (1 ≤<br>ai ≤ n - i). It is guaranteed, that using the given transportation system, one<br>cannot leave the Line World.</p>
<p>Output</p>
<p>If I can go to cell t using the transportation system, print “YES”. Otherwise,<br>print “NO”.</p>
<p>Examples</p>
<p>inputCopy</p>
<p>8 4</p>
<p>1 2 1 2 1 2 1</p>
<p>outputCopy</p>
<p>YES</p>
<p>inputCopy</p>
<p>8 5</p>
<p>1 2 1 2 1 1 1</p>
<p>outputCopy</p>
<p>NO</p>
<pre><code> 1 #include&lt;bits/stdc++.h&gt;
 2  
 3 using namespace std;
 4  
 5 const int maxn=30005;
 6 int n,t,a[maxn],j;
 7  
 8 int main()
 9 {
10 int flag;
11 while (scanf(&quot;%d%d&quot;,&amp;n,&amp;t)!=EOF)
12 {
13 flag=false;
14 for (int i=1;i&lt;n;i++) {
15 scanf(&quot;%d&quot;,&amp;a[i]);
16 a[i]+=i;
17 }
18 for (j=1;j&lt;t;j=a[j]);
19 // 不停地往下跳，j是一定小于t的
20 cout &lt;&lt; (j==t?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl;
21 }
22 return 0;
23 }
</code></pre><p>没有理解清楚题意，很巧妙的解法。</p>
<h3 id="B-BerSU-Ball"><a href="#B-BerSU-Ball" class="headerlink" title="B. BerSU Ball"></a>B. BerSU Ball</h3><p>outputstandard output</p>
<p>The Berland State University is hosting a ballroom dance in celebration of its<br>100500-th anniversary! n boys and m girls are already busy rehearsing waltz,<br>minuet, polonaise and quadrille moves.</p>
<p>We know that several boy&amp;girl pairs are going to be invited to the ball.<br>However, the partners’ dancing skill in each pair must differ by at most one.</p>
<p>For each boy, we know his dancing skills. Similarly, for each girl we know her<br>dancing skills. Write a code that can determine the largest possible number of<br>pairs that can be formed from n boys and m girls.</p>
<p>Input</p>
<p>The first line contains an integer n (1 ≤ n ≤ 100) — the number of boys. The<br>second line contains sequence a1, a2, …, an (1 ≤ ai ≤ 100), where ai is the<br>i-th boy’s dancing skill.</p>
<p>Similarly, the third line contains an integer m (1 ≤ m ≤ 100) — the number of<br>girls. The fourth line contains sequence b1, b2, …, bm (1 ≤ bj ≤ 100), where<br>bj is the j-th girl’s dancing skill.</p>
<p>Output</p>
<p>Print a single number — the required maximum possible number of pairs.</p>
<p>Examples</p>
<p>inputCopy</p>
<p>4</p>
<p>1 4 6 2</p>
<p>5</p>
<p>5 1 5 7 9</p>
<p>outputCopy</p>
<p>3</p>
<pre><code> 1 #include&lt;bits/stdc++.h&gt;
 2 #define f(s,a) for(int i=0;i&lt;s;i++) cin&gt;&gt;a[i];
 3 // 避免代码重复度高，只需要替换两个字符便能解决的函数
 4 using namespace std;
 5  
 6 int n,m;
 7  
 8 int main()
 9 {
10 int n,m,c,a[1000],b[1000];
11 cin&gt;&gt;n;
12 f(n,a)
13 cin&gt;&gt;m;
14 f(m,b)
15 sort(a,a+n);
16 sort(b,b+m);
17 for(int i=0,j=0;i&lt;n &amp;&amp; j&lt;m;) // for循环的循环增长条件可以不写
18 if(a[i]-1&gt;b[j]) j++;
19 else
20 if(a[i]&lt;b[j]-1) i++;
21 else c++,i++,j++;
22 // a[i] b[j]的三种关系：a[i]远大于b，b远大于a,以及绝对值相差1以内
23 cout&lt;&lt;c;
24  
25 return 0;
26 }
</code></pre><p>看别人的代码真的能够学到好多东西！！</p>
<h3 id="dfs-hdu-搜索练习！"><a href="#dfs-hdu-搜索练习！" class="headerlink" title="dfs hdu 搜索练习！"></a>dfs hdu 搜索练习！</h3><h3 id="temple-of-bone-hdu1010"><a href="#temple-of-bone-hdu1010" class="headerlink" title="temple of bone hdu1010"></a>temple of bone hdu1010</h3><p>明明和正确答案敲得一样，但是却总是WA，气得我一直不停地提交不知道提交了几十遍了。但最后看起来最不起眼的一个地方却是致命点，其实还是我对这个程序的理解不够深！不然怎么会犯这样的错误！全局变量和局部变量的问题+递归调用对局部变量的使用问题！归根结底还是没有研究明白啊你！先读别人的代码！想一想这样写的好处是什么？以及你之前写dfs的时候的问题！</p>
<p>心情舒畅！</p>
<p>我的正确代码：</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 using namespace std;
  4 /*
  5 1. 起点终点位置不固定，需要先求出来
  6 2. 坐标和的奇偶性：每走一步奇偶性会产生变化
  7 */
  8 int n,m,t;
  9 char a[10][10];
 10 int path[4][2]=
 11 {
 12 0,1,1,0,0,-1,-1,0
 13 };
 14 bool success;
 15 void dfs(int ct,int i,int j)
 16 {
 17 for (int k=0;k&lt;4;k++)
 18 {
 19 int ni=i+path[k][0];
 20 int nj=j+path[k][1];
 21 if (ni&gt;=n||nj&gt;=m||ni&lt;0||nj&lt;0) continue;
 22 if (a[ni][nj]==&#39;X&#39;) continue;
 23 if (a[ni][nj]==&#39;D&#39;)
 24 {
 25 if (ct+1==t)
 26 {
 27 success=true;
 28 return;
 29 }else
 30 continue;
 31 }
 32  
 33 a[ni][nj]=&#39;X&#39;;
 34 dfs(ct+1,ni,nj);
 35 a[ni][nj]=&#39;.&#39;;
 36 if (success) return;
 37 }
 38 }
 39 int main ()
 40 {
 41 int dx,dy;
 42 while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t)!=EOF){
 43 if (n==0&amp;&amp;m==0&amp;&amp;t==0) break;
 44 success = false;
 45 for (int i=0;i&lt;n;i++) scanf(&quot;%s&quot;,a[i]);
 46 for (int i=0;i&lt;n;i++)
 47 {
 48 for (int j=0;j&lt;m;j++)
 49 {
 50 if (a[i][j]==&#39;D&#39;) {dx=i;dy=j;}
 51 }
 52 }
 53 for (int i=0;i&lt;n;i++)
 54 {
 55 for (int j=0;j&lt;m;j++)
 56 {
 57 if (a[i][j]==&#39;S&#39; &amp;&amp; (i+j)%2==((dx+dy)%2+t%2)%2){
 58 a[i][j]=&#39;X&#39;;
 59 dfs(0,i,j);
 60 }
 61 }
 62 }
 63 puts(success==true?&quot;YES&quot;:&quot;NO&quot;);
 64  
 65 }
 66 return 0;
 67 }
 68  
 69 另一种我更喜欢写但效率上偏低的写法：
 70 #include &lt;iostream&gt;
 71 #include &lt;stdio.h&gt;
 72 using namespace std;
 73 /*
 74 1. 起点终点位置不固定，需要先求出来
 75 2. 坐标和的奇偶性：每走一步奇偶性会产生变化
 76 */
 77 int n,m,t;
 78 char a[10][10];
 79 int path[4][2]=
 80 {
 81 0,1,1,0,0,-1,-1,0
 82 };
 83 bool success;
 84 void dfs(int ct,int i,int j)
 85 {
 86 if (a[i][j]==&#39;D&#39;)
 87 {
 88 if (ct==t)
 89 success=true;
 90 return;
 91 }
 92 if (i&gt;=n||j&gt;=m||i&lt;0||j&lt;0) return;
 93 if (a[i][j]==&#39;X&#39;) return;
 94  
 95 for (int k=0;k&lt;4;k++)
 96 {
 97 a[i][j]=&#39;X&#39;;
 98 dfs(ct+1,i+path[k][0],j+path[k][1]);
 99 a[i][j]=&#39;.&#39;;
100 if (success) return;
101 }
102 }
103 int main ()
104 {
105 int dx,dy;
106 while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t)!=EOF){
107 if (n==0&amp;&amp;m==0&amp;&amp;t==0) break;
108 success = false;
109 for (int i=0;i&lt;n;i++) scanf(&quot;%s&quot;,a[i]);
110 for (int i=0;i&lt;n;i++)
111 {
112 for (int j=0;j&lt;m;j++)
113 {
114 if (a[i][j]==&#39;D&#39;) {dx=i;dy=j;}
115 }
116 }
117 for (int i=0;i&lt;n;i++)
118 {
119 for (int j=0;j&lt;m;j++)
120 {
121 if (a[i][j]==&#39;S&#39; &amp;&amp; (i+j)%2==((dx+dy)%2+t%2)%2){
122 dfs(0,i,j);
123 }
124 }
125 }
126 puts(success==true?&quot;YES&quot;:&quot;NO&quot;);
127  
128 }
129 return 0;
130 }
</code></pre><p>注意：</p>
<ol>
<li>标注为石头的当前层在递归结束返回该层后要记得还原，否则再往上返回时的棋局和之前便不一样了。</li>
<li>success的目标是在找到正确答案后立即返回，不进行接下来的循环。</li>
<li>或者改为return bool的形式</li>
</ol>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 using namespace std;
 4 /*
 5 1. 起点终点位置不固定，需要先求出来
 6 2. 坐标和的奇偶性：每走一步奇偶性会产生变化
 7 */
 8 int n,m,t;
 9 char a[10][10];
10 int path[4][2]=
11 {
12 0,1,1,0,0,-1,-1,0
13 };
14 bool success;
15 bool dfs(int ct,int i,int j)
16 {
17 if (a[i][j]==&#39;D&#39;)
18 {
19 if (ct==t)
20 return true;
21 else return false;
22 }
23 if (i&gt;=n||j&gt;=m||i&lt;0||j&lt;0) return false;
24 if (a[i][j]==&#39;X&#39;) return false;
25  
26 for (int k=0;k&lt;4;k++)
27 {
28 a[i][j]=&#39;X&#39;;
29 success = dfs(ct+1,i+path[k][0],j+path[k][1]);
30 a[i][j]=&#39;.&#39;;
31 if (success) return true;
32 }
33 }
34 int main ()
35 {
36 int dx,dy;
37 while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t)!=EOF){
38 if (n==0&amp;&amp;m==0&amp;&amp;t==0) break;
39 success = false;
40 for (int i=0;i&lt;n;i++) scanf(&quot;%s&quot;,a[i]);
41 for (int i=0;i&lt;n;i++)
42 {
43 for (int j=0;j&lt;m;j++)
44 {
45 if (a[i][j]==&#39;D&#39;) {dx=i;dy=j;}
46 }
47 }
48 for (int i=0;i&lt;n;i++)
49 {
50 for (int j=0;j&lt;m;j++)
51 {
52 if (a[i][j]==&#39;S&#39; &amp;&amp; (i+j)%2==((dx+dy)%2+t%2)%2){
53 dfs(0,i,j);
54 }
55 }
56 }
57 puts(success==true?&quot;YES&quot;:&quot;NO&quot;);
58  
59 }
60 return 0;
61 }
</code></pre><h3 id="hdu-1016-prime-ring-problem"><a href="#hdu-1016-prime-ring-problem" class="headerlink" title="hdu 1016 prime ring problem"></a>hdu 1016 prime ring problem</h3><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;vector&gt;
 4 #include &lt;string&gt;
 5 #include &lt;string.h&gt;
 6  
 7 using namespace std;
 8 int n;
 9 int a[21];
10 bool prime[41];// 1-40是所有加和可能出现的素数
11 vector&lt;int&gt; ans;
12 bool visited[21];
13 void init()
14 {
15 memset(prime,false,sizeof(prime));
16 for (int i=2;i&lt;=41;i++)
17 {
18 if (prime[i] == true) continue;// 非素数为true
19 for (int j=i*i;j&lt;=41;j+=i)
20 prime[j]=true;
21 }
22 }
23 void print(int num)
24 {
25 // 检查最后一个数和1是否组成素数
26 int i;
27 if (!prime[1+num])
28 {
29 for (i=0;i&lt;ans.size()-1;i++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
30 cout &lt;&lt; ans[i] &lt;&lt;endl;
31 }
32 return;
33 }
34 void dfs(int num,int cnt)
35 {
36 if (cnt==n)
37 {
38 print(num);
39 return;
40 }
41 // num是当前环上的数字，cnt 是1-n个数已经安顿了几个？
42 for (int i=2;i&lt;=n;i++)
43 {
44 if (num==i) continue; // 当前数字
45 if (visited[i]) continue; // 已经使用过的数字
46 if (prime[i+num]) continue;//和为非素数
47 ans.push_back(i);
48 visited[i]=true;
49 dfs(i,cnt+1);
50 visited[i]=false;
51 ans.pop_back();
52 }
53 }
54 int main()
55 {
56 int casei=0;
57 init();// prime中2-41间的素数均标记为false
58 while (cin&gt;&gt;n)
59 {
60 ans.clear();
61 printf(&quot;Case %d:\n&quot;,++casei);
62 memset(visited,false,sizeof(visited));
63 ans.push_back(1);
64 visited[1]=true;
65 dfs(1,1);
66 printf(&quot;\n&quot;);
67 }
68 return 0;
69 }
</code></pre><ol>
<li>素数筛代码要熟练写出</li>
</ol>
<h4 id="Oil-Deposits"><a href="#Oil-Deposits" class="headerlink" title="Oil Deposits"></a>Oil Deposits</h4><p>Problem Description</p>
<p>The GeoSurvComp geologic survey company is responsible for detecting<br>underground oil deposits. GeoSurvComp works with one large rectangular region<br>of land at a time, and creates a grid that divides the land into numerous<br>square plots. It then analyzes each plot separately, using sensing equipment<br>to determine whether or not the plot contains oil. A plot containing oil is<br>called a pocket. If two pockets are adjacent, then they are part of the same<br>oil deposit. Oil deposits can be quite large and may contain numerous pockets.<br>Your job is to determine how many different oil deposits are contained in a<br>grid.</p>
<p>Input</p>
<p>The input file contains one or more grids. Each grid begins with a line<br>containing m and n, the number of rows and columns in the grid, separated by a<br>single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;=<br>100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not<br>counting the end-of-line characters). Each character corresponds to one plot,<br>and is either *’, representing the absence of oil, or@’, representing an oil<br>pocket.</p>
<p>Output</p>
<p>For each grid, output the number of distinct oil deposits. Two different<br>pockets are part of the same oil deposit if they are adjacent horizontally,<br>vertically, or diagonally. An oil deposit will not contain more than 100<br>pockets.</p>
<p>Sample Input</p>
<p>1 1</p>
<p>*</p>
<p>3 5</p>
<p>@@*</p>
<p>@</p>
<p>@@*</p>
<p>1 8</p>
<p>@<em>*@</em></p>
<p>5 5</p>
<p>**@</p>
<p>@@@</p>
<p>@*@</p>
<p>@@*@</p>
<p>@**@</p>
<p>0 0</p>
<p>Sample Output</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>2</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;vector&gt;
 4 #include &lt;string&gt;
 5 #include &lt;string.h&gt;
 6 /*
 7 相连的@代表一片油田，求油田总个数
 8  
 9 */
10 using namespace std;
11 int m,n,cnt;
12 char maze[101][101];
13 int go[8][2]=
14 {
15 -1,0,
16 -1,1,
17 0,1,
18 1,1,
19 1,0,
20 1,-1,
21 0,-1,
22 -1,-1
23 };
24 void dfs(int x,int y)
25 {
26 maze[x][y]=&#39;*&#39;;
27 for (int i=0;i&lt;8;i++)
28 {
29 int newx = go[i][0]+x;
30 int newy = go[i][1]+y;
31 if (maze[newx][newy]!=&#39;@&#39;)
32 continue;
33 if (newx&lt;0||newy&lt;0||newx&gt;m||newy&gt;n)
34 continue;
35 dfs(newx,newy);
36 }
37  
38 }
39 int main()
40 {
41  
42 while (cin&gt;&gt;m&gt;&gt;n)
43 {
44 if (m==0&amp;&amp;n==0) break;
45 for (int i=0;i&lt;m;i++)
46 {
47 for (int j=0;j&lt;n;j++)
48 {
49 cin&gt;&gt;maze[i][j];
50 }
51 }
52 cnt=0;
53 for (int i=0;i&lt;m;i++)
54 {
55 for (int j=0;j&lt;n;j++)
56 {
57 if (maze[i][j]==&#39;@&#39;)
58 {
59 dfs(i,j);
60 cnt++;
61 }
62  
63 }
64 }
65 cout &lt;&lt; cnt &lt;&lt; endl;
66 }
67 return 0;
68 }
</code></pre><h3 id="rescue"><a href="#rescue" class="headerlink" title="rescue"></a>rescue</h3><p>求最短的路径，可以找到深搜所有的路径并求最小值，但更好地方法是用bfs求解。</p>
<p>dfs的做法，本地OK但超时。</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;vector&gt;
  4 #include &lt;string&gt;
  5 #include &lt;string.h&gt;
  6 /*
  7 如何求最短的路径？？
  8  
  9 */
 10 using namespace std;
 11 int m,n,mtime;
 12 char maze[201][201];
 13 int go[4][2]=
 14 {
 15 -1,0,
 16 0,1,
 17 1,0,
 18 0,-1
 19 };
 20 struct node
 21 {
 22 int x,y,time;
 23 }a,r;
 24 void dfs(node cur)
 25 {
 26 char c=maze[cur.x][cur.y];
 27 for (int i=0;i&lt;4;i++)
 28 {
 29 node t;
 30 t.x=go[i][0]+cur.x;
 31 t.y=go[i][1]+cur.y;
 32 t.time=cur.time+1;
 33  
 34 if (t.x&lt;0||t.y&lt;0||t.x&gt;m||t.y&gt;n) continue;
 35 if (maze[t.x][t.y]==&#39;#&#39;) continue;
 36 if (maze[t.x][t.y]==&#39;x&#39;) {t.time++;maze[t.x][t.y]=&#39;.&#39;;}
 37 if (maze[t.x][t.y]==&#39;a&#39;)
 38 {
 39 a.time=t.time+1;
 40 if (a.time&lt;mtime)
 41 {
 42 mtime=a.time;
 43 return;
 44 }
 45 }
 46 maze[cur.x][cur.y]=&#39;#&#39;;
 47 dfs(t);
 48 maze[cur.x][cur.y]=c;
 49 }
 50 }
 51 int main()
 52 {
 53  
 54 while (cin&gt;&gt;m&gt;&gt;n)
 55 {
 56 for (int i=0;i&lt;m;i++)
 57 {
 58 for (int j=0;j&lt;n;j++)
 59 {
 60 cin&gt;&gt;maze[i][j];
 61 if (maze[i][j]==&#39;r&#39;)
 62 {
 63 r.x=i;r.y=j;r.time=0;
 64 }
 65 }
 66 }
 67 mtime=9999;
 68 dfs(r);
 69 cout&lt;&lt;mtime&lt;&lt;endl;
 70  
 71 }
 72 return 0;
 73 }
 74  
 75 BFS+优先队列：
 76 #include &lt;iostream&gt;
 77 #include &lt;stdio.h&gt;
 78 #include &lt;queue&gt;
 79  
 80 /*
 81 如何求最短的路径？？
 82 题意：X代表卫兵，a代表终点，r代表起始点，.代表路，#代表墙
 83  
 84 路花费一秒，x花费两秒
 85  
 86 问到达终点的最少时间
 87 */
 88 using namespace std;
 89 int m,n,xx,yy;
 90 char maze[201][201];
 91 int go[4][2]=
 92 {
 93 -1,0,
 94 0,1,
 95 1,0,
 96 0,-1
 97 };
 98 struct node
 99 {
100 int x,y,time;
101 /* bool operator&lt; (const node &amp;a)const
102 {
103 return time &gt; a.time;
104 }
105 */
106 }a,r;
107 bool operator &lt; (node c,node d)
108 {
109 return c.time &gt; d.time;
110 }
111 void bfs()
112 {
113 priority_queue&lt;node&gt; q; //默认大顶堆
114 q.push(r);
115 maze[r.x][r.y]=&#39;#&#39;;
116 node t,newt;
117 while (!q.empty())
118 {
119 t=q.top();q.pop();
120 //--------------------!!!!!---------------------
121 maze[t.x][t.y]=&#39;#&#39;;
122 //至关重要的一句！目的是让走过的路不要再重复
123 //--------------------!!!!!---------------------
124 for (int i=0;i&lt;4;i++)
125 {
126 xx=t.x+go[i][0];
127 yy=t.y+go[i][1];
128 newt.x=xx;
129 newt.y=yy;
130 newt.time=t.time+1;
131 if (xx&lt;0||yy&lt;0||xx&gt;=m||yy&gt;=n||(maze[xx][yy]==&#39;#&#39;)) continue;
132 if (maze[xx][yy]==&#39;x&#39;)
133 {
134 newt.time++;
135 }
136 else
137 if (maze[xx][yy]==&#39;a&#39;)
138 {
139 printf(&quot;%d\n&quot;,newt.time);
140 return;
141 }
142 q.push(newt);
143 // maze[xx][yy]=&#39;#&#39;; 这句话加在这里就会出错：不能把它放进去的时候就变路
144 }
145 }
146 printf(&quot;Poor ANGEL has to stay in the prison all his life.\n&quot;);
147  
148 }
149  
150 int main()
151 {
152  
153 while (scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF)
154 {
155 for (int i=0;i&lt;m;i++)
156 {
157 for (int j=0;j&lt;n;j++)
158 {
159 cin&gt;&gt;maze[i][j];
160 if (maze[i][j]==&#39;r&#39;)
161 {
162 r.x=i;r.y=j;r.time=0;
163 }
164 }
165 }
166 bfs();
167  
168 }
169 return 0;
170 }
</code></pre><p>关于优先队列：</p>
<p>默认大顶堆，也就是队首为最大值。队列按照从大到小的顺序排列。如果需要从小到大排序：</p>
<p>两种方式：</p>
<ol>
<li>结构体内运算符重载，记住括号右侧const必须要加不然会报错</li>
<li>结构体外运算符重载</li>
<li>cmp结构体内运算符重载</li>
<li>友元函数</li>
</ol>
<p>以结构体Time为例：</p>
<pre><code>struct Time{
int start, end;
};
</code></pre><p>使用优先队列时，如果需要对Time中的start从小到大排序，有两种方法：</p>
<p>priority_queue<time> pq;</time></p>
<p>一.在结构体外重载结构体小于运算符：</p>
<pre><code>bool operator &lt;(const Time&amp; a,const Time&amp; b){
return a.start &gt; b.start;
} //这里以大于重载小于是因为默认情况下，优先队列是以大的作为队首，这样一反，就可以再默认情况下使得小的作为队首
</code></pre><p>二.直接在结构体中重载小于运算符：</p>
<pre><code>struct Time{
int start, end;
bool operator &lt; (const Time&amp; t)const{
return start &gt; t.start;
}
};
</code></pre><p>// 第二个const的作用：（我已经百度了无数遍了），const函数，不能修改成员变量，括号内的const表示不能修改参数变量</p>
<p>三.直接在cmp中重载小于运算符：</p>
<pre><code>struct cmp
{
bool operator &lt;(Time t1, Time t2)
{
return t1.start &gt; t2.start;
}
};
priority_queue&lt;Time,vector&lt;Time&gt; , cmp &gt; q; 调用形式
</code></pre><p>四.友元函数</p>
<p>在Time结构体中定义友元函数,省去了const的麻烦</p>
<pre><code>friend bool operator&lt; (Time f1, Time f2)
{
return f1.start &lt; f2.start;
}
</code></pre><p>什么是友元函数？</p>
<ul>
<li>友元函数不属于类的成员函数，需要在类外实现函数主题，不需要加类限定</li>
<li>友元函数可以访问类的私有成员但必须通过类对象形参的方式使用</li>
</ul>
<p>小顶堆：priority_queue<time,vector<time>,greater<time></time></time,vector<time></p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-codeforces" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/codeforces/">codeforces</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/codeforces/" class="article-date">
  <time datetime="2018-08-20T18:20:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://maxiang.io/#/?provider=evernote&amp;guid=8ff81848-729a-4333-8053-f5a6a565673d&amp;notebook=%E4%BA%8C%E8%90%8C%E6%9A%B4%E8%B5%B0%E7%BC%96%E7%A8%8B%E2%98%85" target="_blank" rel="noopener">Edit</a></p>
<pre><code>include &lt;bits/stdc++.h&gt; // 万能头文件
ios::sync_with_stdio(false);
cin.tie(0);
加速c++输入输出流
</code></pre><p>setprecision() 浮点数从做到右一共能输出几个数字，但小数末尾为0则不能输出</p>
<p>fix 保留几位小数 cout.setf(ios::fixed);</p>
<p>showpoint cout.setf(ios::showpoint); 输出小数末尾的0</p>
<p><a href="https://blog.csdn.net/u011321546/article/details/9293547" target="_blank" rel="noopener">https://blog.csdn.net/u011321546/article/details/9293547</a></p>
<p>C：</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;cstdio&gt;
 3  
 4 using namespace std;
 5 int main()
 6 {
 7 double n, sum = 0, tem = 0;
 8 int a[100000] = {0};
 9 int b = 1, k, v;
10 cin &gt;&gt; n &gt;&gt; k;
11 for (int i = 0; i &lt; n; i++)
12 {
13 cin &gt;&gt; a[i];
14 }
15  
16 for (int i = 0; i &lt;= n - k; i++)
17 {
18 b = 0;
19 sum = 0;
20 v = k;
21 for (int j = i; j &lt; k + i; j++)
22 {
23 sum += a[j];
24 }
25 if (sum / (k + b) &gt; tem)
26 {
27 tem = sum / (k + b);
28 }
29 while (v &lt; n)
30 {
31 sum = sum + a[k + i + b];
32 b++;
33 if (sum / (k + b) &gt; tem)
34 tem = sum / (k + b);
35 v++;
36 }
37 }
38 printf (&quot;%.15lf&quot;, tem);
39  
40 return 0;
41 }
</code></pre><ul>
<li>在程序设计的时候比下一种做法更有技巧：每次从k增加一个数</li>
</ul>
<pre><code> 1 #include &lt;bits/stdc++.h&gt;
 2  
 3 using namespace std;
 4  
 5 int main() {
 6 ios_base::sync_with_stdio(0);
 7 cin.tie(NULL);
 8 double s = 0;
 9 long long n, k, i, l, r, tmp;
10 cin &gt;&gt; n &gt;&gt; k;
11 vector&lt;long long&gt; a(n);
12 for(i=0;i&lt;n;i++) cin &gt;&gt; a[i];
13  
14 for(l = 0; l &lt; n; l++) {
15 tmp = 0;
16 for(r = l; r &lt; n; r++) {
17 tmp += a[r];
18 if(r-l+1 &gt;= k) {
19 s = max(s, double(tmp /1.0 / (r-l+1)));
20 }
21 }
22 }
23  
24 cout &lt;&lt; setprecision(10) &lt;&lt; fixed &lt;&lt; s;
25 return 0;
26 }
</code></pre><ul>
<li>换了个编译器就好使了？？？</li>
</ul>
<h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;map&gt;
 3 using namespace std;
 4 map&lt;int,int&gt; mp;
 5 struct{
 6 int sm;
 7 }st[35];
 8 int mn;
 9 int s[35];
10 void init(){
11 int i,a;
12 a=1;
13 mp[1]=0;
14 st[0].sm=1;
15 for(i=1;i&lt;=31;i++){
16 a=a*2;
17 mp[a]=i;
18 st[i].sm=a;
19 }
20 }
21 int min(int a,int b){
22 if(a&lt;b)
23 return a;
24 return b;
25 }
26 int dfs(int k,int j,int cnt){
27 int i;
28 if(j&lt;0){
29 if(k==0)
30 mn=cnt;
31 return 0;
32 }
33 i=min(k/st[j].sm,s[mp[st[j].sm]]);
34 dfs(k-i*st[j].sm,j-1,cnt+i);
35 return 0;
36 }
37 int main(){
38 init();
39 int n,q;
40 int i,j,a;
41 scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
42 for(i=0;i&lt;n;i++){
43 scanf(&quot;%d&quot;,&amp;a);
44 s[mp[a]]++;
45 }
46 while(q--){
47 mn=0;
48 scanf(&quot;%d&quot;,&amp;a);
49 dfs(a,31,0);
50 if(mn==0)
51 printf(&quot;-1\n&quot;);
52 else
53 printf(&quot;%d\n&quot;,mn);
54 }
55 return 0;
56 }
</code></pre><ul>
<li>我的常规DFS做法，中间调试了很久，因为我对这个过程还是不是特别了解。并没有掉到坑里之后永远见到这个坑绕道走。</li>
<li>还是超时了呵呵哒</li>
</ul>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;cstdio&gt;
 3  
 4 using namespace std;
 5 int a[1000001];
 6 int n,q,num,best;
 7 void dfs(int i,int count1,int sum) // 第i个硬币选或不选，count为选择硬币个数，sum为硬币的和
 8 {
 9 if (i == n || sum == num)
10 {
11 if (sum==num &amp;&amp;count1 &lt; best)
12 {
13 best = count1;
14 return ;
15 }
16 return ; // 很关键！
17  
18 }
19 if (sum &gt; num)
20 return ;
21 if (sum+a[i] &lt;= num)
22 {
23 // 选择该硬币
24 dfs(i+1,count1+1,sum+a[i]);
25 }
26 // 不选择该硬币
27 dfs(i+1,count1,sum);
28 }
29 int main()
30 {
31  
32 while (scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF)
33 {
34 for (int i=0;i&lt;n;i++)
35 scanf(&quot;%d&quot;,&amp;a[i]);
36 for (int i=0;i&lt;q;i++)
37 {
38 scanf(&quot;%d&quot;,&amp;num);
39 best = 65515;
40 dfs(0,0,0);
41 if (best == 65515)
42 cout &lt;&lt; -1 &lt;&lt;endl;
43 else
44 cout &lt;&lt; best &lt;&lt; endl;
45  
46 }
47  
48  
49 }
50  
51 return 0;
52 }
53  
</code></pre><ul>
<li>我重新做了一遍</li>
</ul>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;map&gt;
 3 #include &lt;iostream&gt;
 4 #include &lt;string&gt;
 5 #include &lt;string.h&gt;
 6 using namespace std;
 7  
 8 map&lt;int,int&gt; mp;
 9 int rmap[32];
10 int s[32];
11 int bst; //最小的
12 void init()
13 {
14 int a = 1;
15 mp[a] = 0;
16 rmap[0] = a;
17 for (int i = 1;i&lt;=31;i++)
18 {
19 a*=2;
20 mp[a] = i;
21 rmap[i]=a;
22 }
23 // for (int i=0;i&lt;32;i++)
24 // cout &lt;&lt; i &lt;&lt;&#39; &#39;&lt;&lt;rmap[i] &lt;&lt; endl;
25 }
26 void dfs(int sum,int level,int cnt)
27 {
28 if (level &lt; 0)
29 {
30 if (sum==0)
31 {
32 bst = cnt; // 一定是最小的方案
33 }
34 return ;
35 }
36 int i = min(sum/rmap[level],s[level]);
37 dfs(sum-i*rmap[level],level-1,cnt+i);
38 }
39 int main(){
40  
41 int n,q,a,cnt;
42 cin &gt;&gt; n &gt;&gt;q;
43 memset(s,0,sizeof(s));
44 memset(rmap,0,sizeof(rmap));
45 mp.clear();
46 init();
47  
48 for (int i=0;i&lt;n;i++)
49 {
50 cin &gt;&gt; a;
51 s[mp[a]]++;
52 }
53 while (q--)
54 {
55 cin &gt;&gt; a;
56 bst = 0;
57 dfs(a,31,0); // cnt为数字的个数
58 if (bst==0)
59 cout &lt;&lt; -1 &lt;&lt; endl;
60 else
61 cout &lt;&lt; bst &lt;&lt; endl;
62 }
63  
64 return 0;
65 }
</code></pre><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;vector&gt;
  3 #include &lt;algorithm&gt;
  4 #include &lt;string&gt;
  5  
  6 #define all(a) a.begin(), a.end()
  7 #define forn(a, b) for(int a = 0; a &lt; b; a++)
  8 #define from(a, b, c) for(int a = b; a &lt; c; a++)
  9 #define KEK cout &lt;&lt; &quot;KEK\n&quot;;
 10  
 11 using namespace std;
 12  
 13  
 14 int n, d, k;
 15 int ptr = 2;
 16  
 17 vector&lt; vector &lt; int &gt; &gt; tree(1000000);
 18  
 19 int deep[1000000];
 20 int mark[1000000];
 21  
 22 bool first_chek() {
 23 if((n - 1) &lt; d)
 24 return true;
 25  
 26 if(k == 1 &amp;&amp; d != (n - 1))
 27 return true;
 28  
 29 return false;
 30 }
 31  
 32 void first_step() {
 33 //KEK
 34 int a, b, top = 1;
 35  
 36 if(k == 1) {
 37 a = 1;
 38 b = 0;
 39 } else {
 40 a = d / 2;
 41 b = (d + 1) / 2;
 42 }
 43  
 44 //cout &lt;&lt; &quot; :: &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
 45 //KEK
 46 forn(i, a) {
 47 tree[top].push_back(ptr);
 48 deep[ptr] = deep[top] + 1;
 49 top = ptr;
 50 ptr++;
 51 }
 52 //KEK
 53 top = 1;
 54 forn(i, b) {
 55 if(d % 2 == 1 &amp;&amp; top != 1)mark[top] = 1;
 56 tree[top].push_back(ptr);
 57 deep[ptr] = deep[top] + 1;
 58 top = ptr;
 59 ptr++;
 60  
 61 }
 62 //KEK
 63 }
 64  
 65 void second_step(){
 66 //KEK
 67 for(int i = 1; i &lt; ptr &amp;&amp; i &lt;= n; i++) {
 68 //cout &lt;&lt; i &lt;&lt; endl;
 69 if(deep[i] + 1 &gt; d / 2) {
 70 if(mark[i] == 0)
 71 continue;
 72 else
 73 mark[i] = 0;
 74 }
 75 if(ptr &gt; n)
 76 return;
 77 //cout &lt;&lt; &quot;1:: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; tree[i].size() &lt;&lt; endl;
 78 for(int j = tree[i].size(); j &lt; k - (i != 1 ? 1 : 0); j++) {
 79 if(ptr &gt; n)
 80 return;
 81 tree[i].push_back(ptr);
 82 deep[ptr] = deep[i] + 1;
 83 mark[ptr] = mark[i];
 84 ptr++;
 85 }
 86 }
 87 }
 88  
 89  
 90 int main() {
 91  
 92 cin &gt;&gt; n &gt;&gt; d &gt;&gt; k;
 93  
 94 if(first_chek()){
 95 cout &lt;&lt; &quot;NO\n&quot;;
 96 return 0;
 97 }
 98  
 99 first_step();
100  
101 second_step();
102  
103 //KEK
104  
105 //cout &lt;&lt; ptr &lt;&lt; endl;
106  
107 if(ptr &lt;= n)
108 cout &lt;&lt; &quot;NO\n&quot;;
109 else {
110 cout &lt;&lt; &quot;YES\n&quot;;
111 for(int i = 1; i &lt;= n; i++) {
112 for(int j = 0; j &lt; tree[i].size(); j++) {
113 cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; tree[i][j] &lt;&lt; endl;
114 }
115 }
116 }
117  
118 }





 1 #include &lt;iostream&gt;
 2 #include &lt;bits/stdc++.h&gt;
 3  
 4 using namespace std;
 5  
 6 int main()
 7 {
 8 int n, d, k;
 9 cin &gt;&gt; n &gt;&gt; k &gt;&gt; d;
10 if(n - 1 &lt; k)return cout &lt;&lt; &quot;NO&quot;, 0;
11  
12 if(d == 1 || n == 2 || k == 1){
13 if(n == 2 &amp;&amp; k == 1 &amp;&amp; d &gt;= 1) cout &lt;&lt; &quot;YES\n1 2&quot;;
14 else cout &lt;&lt; &quot;NO&quot;;
15 return 0;
16 }
17 vector&lt;vector&lt;int&gt; &gt; edges(n);
18 int currNode = 1;
19  
20 for(int i=1;i&lt;=ceil(k * 0.5);i++){
21 edges[i - 1].push_back(i);
22 currNode++;
23 }
24  
25 int stopNode1 = currNode - 1;
26 edges[0].push_back(currNode);
27 currNode++;
28 for(int i=1;i&lt;k/2;i++){
29 edges[currNode - 1].push_back(currNode);
30 currNode++;
31 }
32 int stopNode2 = currNode - 1;
33 queue&lt;int&gt; q;
34 q.push(0);
35 while(!q.empty() &amp;&amp; currNode != n){
36 int node = q.front(); q.pop();
37 for(int ch : edges[node]){
38 q.push(ch);
39 }
40 if(node == stopNode1 || node == stopNode2)break;
41 while(edges[node].size() + (node != 0) &lt; d &amp;&amp; currNode != n){
42 edges[node].push_back(currNode);
43 q.push(currNode);
44 currNode++;
45 }
46 }
47  
48  
49 if(currNode != n)cout &lt;&lt; &quot;NO&quot;;
50 else{
51 cout &lt;&lt; &quot;YES\n&quot;;
52 for(int i=0;i&lt;n;i++){
53 for(int ch : edges[i]){
54 cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; ch + 1 &lt;&lt; endl;
55 }
56 }
57 }
58 return 0;
59 }
</code></pre><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><pre><code> 1 #include&lt;bits/stdc++.h&gt;
 2  
 3 using namespace std;
 4  
 5 map&lt;string,int&gt;mp;
 6  
 7 int main() {
 8 int n,id=0;
 9 string tmp;
10 vector&lt;int&gt; a(n+1),b(n+1);
11  
12 cin&gt;&gt;n;
13 // 统计每一个单词的个数，a[i]存放第i个位置的字符串的相同串的个数
14 for(int i=1;i&lt;=n;i++){
15 cin&gt;&gt;tmp;
16 if(mp[tmp]==0) mp[tmp]=++id;
17 a[i]=mp[tmp];
18 b[i]=tmp.length()+b[i-1]; // 统计串的长度
19 }
20  
21 int cnt=b.back()+n-1,ans=cnt; // 字符串中非空格串长度+空格的个数，ans默认为这个
22  
23 for(int i=1;i&lt;=n;i++){
24 for(int j=i;j&lt;=n;j++){
25 int len=1-(b[j]-b[i-1]),ct=0;
26 for(int k=j+1;k+j-i&lt;=n;k++){
27 int flag=1;
28 for(int p=0;p&lt;j-i+1;p++){
29 if(a[i+p]!=a[k+p]){
30 flag=0;break;
31 }
32 }
33 if(flag){
34 ct++;k=k+j-i;
35 }
36 }
37 if(ct){
38 ans=min(ans,cnt+(ct+1)*len);
39 }
40 }
41 }
42  
43 cout&lt;&lt;ans&lt;&lt;endl;
44 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-线段树、树状数组" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/线段树、树状数组/">线段树、树状数组</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/线段树、树状数组/" class="article-date">
  <time datetime="2018-08-20T18:16:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>A 树状数组:</p>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;algorithm&gt;
 4 #include &lt;string.h&gt;
 5 using namespace std;
 6 // 1h / 10min
 7 const int maxn = 32001;
 8 int c[maxn],ans[maxn]; // c[i] : 以i为横坐标的星星左侧和下侧星星的个数， ans[i] : 某层的星星的个数
 9 int x,y;
10 int lowbit(int x)
11 {
12 return x&amp;(-x);
13 }
14 int sum(int x) // 计算横坐标为x的星星的level
15 {
16 int s = 0;
17 for (x ; x &gt; 0 ; x -=lowbit(x))
18 {
19 s += c[x];
20 }
21 return s;
22 }
23 void insert(int x)
24 {
25 for (x ; x &lt;= maxn ; x += lowbit(x))
26 {
27 c[x]++;
28 }
29 }
30 int main()
31 {
32 int n;
33 while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
34 {
35 memset(c,0,sizeof(c));
36 memset(ans,0,sizeof(ans));
37 for (int i=0;i&lt;n;i++)
38 {
39 scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x++;// 横坐标整体往右移动一位
40 ans[sum(x)]++;
41 insert(x);
42 }
43 for (int i=0;i&lt;n;i++)
44 cout &lt;&lt; ans[i] &lt;&lt; endl;
45 }
46  
47 }
</code></pre><p>树状数组：</p>
<p><a href="https://www.cnblogs.com/hsd-/p/6139376.html" target="_blank" rel="noopener">https://www.cnblogs.com/hsd-/p/6139376.html</a></p>
<p><a href="https://blog.csdn.net/flushhip/article/details/79165701" target="_blank" rel="noopener">https://blog.csdn.net/flushhip/article/details/79165701</a></p>
<p><a href="https://blog.csdn.net/zheng0518/article/details/51119042" target="_blank" rel="noopener">https://blog.csdn.net/zheng0518/article/details/51119042</a></p>
<p><a href="https://blog.csdn.net/kkkkahlua/article/details/76785265" target="_blank" rel="noopener">https://blog.csdn.net/kkkkahlua/article/details/76785265</a></p>
<p><a href="https://blog.csdn.net/moep0/article/details/52770728" target="_blank" rel="noopener">https://blog.csdn.net/moep0/article/details/52770728</a></p>
<p>题目解析：<a href="https://blog.csdn.net/zhanghaoxian1/article/details/74275951" target="_blank" rel="noopener">https://blog.csdn.net/zhanghaoxian1/article/details/74275951</a></p>
<ul>
<li>有一点明白但还是不是很懂怎么转换的过程，再重新顺一遍过程。</li>
</ul>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><ul>
<li><p>自学困难的知识的时候，不要有畏难心理。所有的难知识都可以通过一定的方法，掰碎了一点一点消化吸收的，我只需要一个程序一个程序地编写。在编写的过程中，遇到不清楚的知识点，一定要记下来!并且回去反复思考总结！我的问题总是反反复复的出现，一如我踩过的坑，下次遇到这个坑的时候还是义无反顾地跳进去，这就是我最大的问题！不总结！犯重复的错误！而且你要有时刻准备好的状态，不要畏畏缩缩的，大家都是这么过来的，慢慢来，还有两个月的时间，每天做五道题，你会超越绝大多数的人。</p>
</li>
<li><p>创建线段树和中序遍历线段树的代码写不对，爆出segment fault这等高级段错误，与结构体、指针、构造函数有关。</p>
</li>
<li><p><a href="https://blog.csdn.net/ray_seu/article/details/8705640" target="_blank" rel="noopener">菜鸟都能理解的线段树</a></p>
</li>
</ul>
<pre><code>  1 #include&lt;iostream&gt;
  2 #include&lt;cstdio&gt;
  3 #include&lt;algorithm&gt;
  4 using namespace std;
  5  
  6 struct line
  7 {
  8 int l,r,count;
  9 struct line *lchild,*rchild;
 10 line(int a,int b)
 11 {
 12 l = a;r = b;count = 0;
 13 lchild = NULL;
 14 rchild = NULL;
 15 }
 16 };
 17  
 18  
 19 const int maxn = 20;
 20 int a[maxn][2],p[maxn];
 21  
 22 /*
 23  
 24 指针一定要初始化了在使用！！！
 25 两种初始化创建的方法： 第一种一直调试不过原因：
 26 1. line中指针一定要初始化为NULL
 27 2. 传参数的时候要传引用。指针的引用。不然仅仅是复制一个指针并不是在原来的指针上改变。
 28 如果改变影响到它自身的话就用引用。
 29 */
 30 // 这个创建树也不太会写诶
 31 void createLine(line* &amp;root,int left,int right)
 32 {
 33 root = new line(left,right);
 34 if (left &lt; right) // l==r 叶节点时便不往下继续分了
 35 {
 36 int mid = (left+right)/2;
 37 createLine(root-&gt;lchild,left,mid);
 38 createLine(root-&gt;rchild,mid+1,right);
 39 }
 40 }
 41  
 42 /*
 43 void createLine(line *root) {
 44 int left = root-&gt;l;
 45 int right = root-&gt;r;
 46 if (left &lt; right) {
 47 int mid = (left + right) / 2;
 48 line *lc = new line(left, mid);
 49 line *rc = new line(mid + 1, right);
 50 root-&gt;lchild = lc;
 51 root-&gt;rchild = rc;
 52 createLine(lc);
 53 createLine(rc);
 54 }
 55 }
 56 */
 57 void inOrder(line *root)
 58 {
 59  
 60 if ( root !=NULL)
 61 {
 62 inOrder(root-&gt;lchild);
 63 cout &lt;&lt; &quot;[&quot;&lt;&lt;root-&gt;l&lt;&lt;&quot;,&quot;&lt;&lt;root-&gt;r&lt;&lt;&quot;]&quot; &lt;&lt; root-&gt;count&lt;&lt; endl;
 64 inOrder(root-&gt;rchild);
 65 }
 66 }
 67 void insertLine(line* &amp;root,int l, int r )
 68 {
 69 // 把[l,r]插入到线段树中
 70 cout &lt;&lt; root-&gt;l &lt;&lt; &quot;,&quot; &lt;&lt; root-&gt;r &lt;&lt; endl;
 71 if (root-&gt;l == l &amp;&amp; root-&gt;r == r)
 72 {
 73 // 1. 刚好重合
 74 root-&gt;count ++;
 75 return ;
 76 }
 77 else
 78 {
 79 int mid = (root-&gt;l+root-&gt;r)/2; // 判断线段在root的左半区间还是右半区间
 80 if (r &lt;= mid) // 左半区间
 81 {
 82 insertLine(root-&gt;lchild,l,r);
 83 }
 84 else if ( l &gt; mid ) // 右半区间
 85 {
 86 insertLine(root-&gt;rchild,l,r);
 87 }
 88 else
 89 {
 90 // 从中间分开
 91 int mid_l = (l+r)/2; // 把小线段从中间分开而不是用root的区间 ？ 用root的区间可以吗？
 92 insertLine(root-&gt;lchild,l,mid_l);
 93 insertLine(root-&gt;rchild,mid_l+1,r);
 94 }
 95 }
 96  
 97 }
 98 // 这个递归不太会写诶
 99 int getCount(line *root,int x)
100 { // 每一层的ans = 根的count + 左子树count + 右子树count
101 int ans = 0; // count 个数
102 int mid = (root-&gt;l+root-&gt;r)/2;
103 if (root-&gt;l &lt;= x &amp;&amp; root-&gt;r &gt;= x) // 在区间范围内
104 ans += root-&gt;count;
105 if (root-&gt;l == root-&gt;r)
106 {
107 return ans;
108 }
109 if (x &gt; mid)
110 {
111 ans += getCount(root-&gt;rchild,x);
112 }
113 else
114 {
115 ans +=getCount(root-&gt;lchild,x);
116 }
117 return ans;
118 }
119 int main()
120 {
121 int n,m;
122 // 给定N条线段 ， M个点， 判断每个点在几个线段中出现过
123 while (cin &gt;&gt; n &gt;&gt; m)
124 {
125 // 输入线段和点
126 int l = 65515,r = -65515;
127 for (int i=0;i&lt;n;i++)
128 {
129 cin &gt;&gt;a[i][0] &gt;&gt; a[i][1];
130 if (a[i][0] &lt; l)
131 {
132 l = a[i][0];
133 }
134 if (a[i][1] &gt; r)
135 {
136 r = a[i][1];
137 }
138 }
139 for (int i=0;i&lt;m;i++) cin &gt;&gt; p[i];
140 // 创建线段树
141 // 1. 找到给定线段所覆盖的最大区间范围,创建以该范围为根节点的线段树
142 line *root = new line(l,r);
143 createLine(root,l,r);
144 // createLine(root);
145 // inOrder(root);
146 for (int i = 0;i&lt;n;i++)
147 {
148 insertLine(root,a[i][0],a[i][1]); // 依次把各条线段插入线段树
149 }
150 for (int i=0;i&lt;m;i++)
151 {
152 // 对于每一个点
153 cout &lt;&lt; getCount(root,i)&lt;&lt; endl;
154 }
155 }
156 }
</code></pre><h4 id="敌兵布阵"><a href="#敌兵布阵" class="headerlink" title="敌兵布阵"></a>敌兵布阵</h4><p><a href="https://blog.csdn.net/qq_26071477/article/details/51636464" target="_blank" rel="noopener">详细的线段树入门+题目讲解（提交时超时了）</a></p>
<p><a href="https://blog.csdn.net/libin56842/article/details/12947849" target="_blank" rel="noopener">不超时答案</a></p>
<pre><code>  1 #include&lt;iostream&gt;
  2 #include&lt;cstdio&gt;
  3 #include&lt;algorithm&gt;
  4 #include &lt;string&gt;
  5 #include &lt;string.h&gt;
  6 using namespace std;
  7 // 1h 35
  8 // (step&lt;&lt;1)+1 括号必须加，优先级问题
  9 const int maxn = 1000000; // 数组长度定义为多少？？
 10 struct node
 11 {
 12 int left,right,value;
 13 }tree[maxn];
 14 /*
 15 void build(int l,int r,int step)
 16 {
 17 // 1. 第step个结点的赋值
 18 tree[step].left = l;
 19 tree[step].right = r;
 20 tree[step].value = 0;
 21 // cout &lt;&lt; &quot;结点:&quot;&lt;&lt; step &lt;&lt; &quot;,左:&quot; &lt;&lt; l &lt;&lt; &quot;,右:&quot; &lt;&lt; r&lt;&lt; endl;
 22 // 2. 递归边界
 23 if (l == r)
 24 return ;
 25 // 3. 一分为2，继续递归创建子树
 26 int mid = (l+r)&gt;&gt;1; // 右移1位 = 除以2， 为什么不直接除以2 ？？
 27 build(l,mid,step&lt;&lt;1); // step * 2 左子树
 28 build(mid+1,r,(step&lt;&lt;1)+1); // step * 2 + 1右子树
 29 }
 30 */
 31 void init(int n)//新建一个线段树
 32 {
 33 int i,k;
 34 for(k = 1; k&lt;n; k&lt;&lt;=1);
 35 for(i = k; i&lt;2*k; i++)
 36 {
 37 tree[i].left = tree[i].right = i-k+1;
 38 tree[i].value = 0;
 39 }
 40 for(i = k-1; i&gt;0; i--)
 41 {
 42 tree[i].left = tree[2*i].left;
 43 tree[i].right = tree[2*i+1].right;
 44 tree[i].value = 0;
 45 }
 46 }
 47 void update(int l,int r,int value,int step)
 48 {
 49 tree[step].value += value;
 50 // cout &lt;&lt;&quot;结点：&quot;&lt;&lt; step &lt;&lt; &quot;加上&quot; &lt;&lt; value &lt;&lt;endl;
 51 // 递归边界
 52 if (tree[step].left == tree[step].right ) // 更新到叶子结点 ， 为什么不能写成left = l &amp;&amp; right = r ??
 53 {
 54 // tree[step].value = value;
 55 // cout &lt;&lt; &quot;step:&quot;&lt;&lt; step &lt;&lt; &quot;,l:&quot; &lt;&lt; l &lt;&lt; &quot;,r:&quot; &lt;&lt; r&lt;&lt; value &lt;&lt;endl;
 56 return;
 57 }
 58 int mid = (tree[step].left + tree[step].right) &gt;&gt; 1;
 59 if (r &lt;= mid)
 60 {
 61 // 线段在根节点的左半区间
 62 update(l,r,value,step&lt;&lt;1);
 63 }else if (l &gt; mid) // 右半区间
 64 {
 65 update(l,r,value,(step&lt;&lt;1)+1);
 66 }else
 67 {
 68 // l,r 跨越了mid，分别更新
 69 update(l,mid,value,step&lt;&lt;1);
 70 update(mid+1,r,value,(step&lt;&lt;1)+1);
 71 }
 72 }
 73 int query(int l,int r,int step) // 求 l - r的和 ？？？？
 74 {
 75 // if (tree[step].left == tree[step].right)
 76 if(l == tree[step].left &amp;&amp; r == tree[step].right)
 77 {
 78 // printf(&quot;返节点%d的值%d\n&quot;,step,tree[step].value);
 79 return tree[step].value;
 80 }
 81 int mid = (tree[step].left + tree[step].right) &gt;&gt; 1;
 82 if(r &lt;= mid)
 83 {
 84 // printf(&quot;结点：%d 查询%d到%d \n&quot;,step,l,r);
 85 return query(l, r, step&lt;&lt;1);
 86 }
 87 if(l &gt; mid)
 88 {
 89 // printf(&quot;结点：%d 查询%d到%d \n&quot;,step,l,r);
 90 return query(l, r, (step&lt;&lt;1)+1);
 91 }
 92 else
 93 {
 94 // printf(&quot;结点：%d 查询%d到%d 和%d %d \n&quot;,step,l,mid,mid+1,r);
 95 return query(l, mid, step&lt;&lt;1) + query(mid+1, r, (step&lt;&lt;1)+1);
 96 }
 97 }
 98 int main()
 99 {
100 int t,n,ai,a,b;
101 char order[10];
102 scanf(&quot;%d&quot;,&amp;t);
103 for (int j = 1;j&lt;=t;j++)
104 {
105 scanf(&quot;%d&quot;,&amp;n);
106 // build(1,n,1);
107 init(n);
108 // 依次更新每个营地的人数值
109 for (int i=1;i&lt;=n;i++)
110 {
111 scanf(&quot;%d&quot;,&amp;ai);
112 update(i,i,ai,1);
113 }
114 printf(&quot;Case %d:\n&quot;,j);
115 while (scanf(&quot;%s&quot;,order)!=EOF &amp;&amp; strcmp(order,&quot;End&quot;)!=0)
116 {
117 cin &gt;&gt; a &gt;&gt; b;
118 if (strcmp(order,&quot;Add&quot;) == 0)
119 {
120 update(a,a,b,1);
121 }
122 if (strcmp(order,&quot;Sub&quot;) == 0)
123 {
124 update(a,a,-b,1);
125 }
126 if (strcmp(order,&quot;Query&quot;)==0)
127 {
128 cout &lt;&lt; query(a,b,1) &lt;&lt; endl;
129 }
130 }
131 }
132 }
</code></pre><ul>
<li>我他喵的研究了三个小时之后终于accept而且我好像看懂其中的原理了我很开心。Hhhhhh这大概就是计算机的女人绝不认输的精神吧！</li>
<li><img src="file:///G:/Users/NiuMeng/AppData/Local/Temp/enhtmlclip/1529674317948.png" alt="Alt text"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABj4AAAAwCAYAAAChfgN3AAAgAElEQVR4AeydB7idVZX317kluQklCZDQi1SlSHFEOogOvVhABVRswFhm5htFRucbkTIjtsGxIGXA8ZMmtpESEKQEhqIB6UUJSOiQhBRCQpJ77znf83vf87tn5eWilAQF3vU8++69V/mvtddee9/3nHNL44knnmi1Wq1oNBrR1dVV9I3unugb0VuOG42A0MnEPNupo153d3c0m80hHXXxQ4OQ09AdHBxczB9y9PTjnF4fmVflM6+SfuU714dz5NkHc+IkP7S8LmMUU1v4yrINa9UfY/UzJjxtC4X2F3C0FT/LwciEDuRatBFDPrjqydMWvmPxM44y7Zk/u3DRUP1U8ZijAxZ+GasjhvXAPK/ZefaZ60a+eBlbnv7BUl+/6jCX0Mk4mc9Ym6pe5quX8ydO7qt+WDs2YqMrhnbI1IOn3yx3XJXrjx5cbMXTRjz46tFDxqYuvRjqVO3Vqdpox1rU0ZZ6yPGpa0zoI6dZO1mGnDl2YlbjU4ceUq89fU6nvQLn+nA+HBZxsk73DRv0aVW/VVm2Ya36Y6yvnCt4w+GCo62+C4D2FzAyoQMZnzZiyAdXPXnawncsfsZRpr1zcBhX8eSbz6wjhvXAPK/ZuT6Y13dJfZdQB9QTzdqhRnKdWGfD1SP2UNZXry16Tpd1sy121rhGVSxrP98L4BmjdvRiKcs2r7W7ZMGi/hg1ckSxfNedc2Aezb065tMcmT/k1gO8+i5ZOs8l7lveD8fkXIIHsU809s29zOOsry68qn3mZZuqb+baUg/4Usc++0FOs3ayDD/MMybzaizyqvxCsfIl6yJyrg/nw2ERJznO9wL6NOwz5bUyzjavtbukmjPn5sDcVPnms5o/9K0Hckru4InDXCzkPpfwumqZUX3FNqibseXRa2+PEXx1CpD2F3QyjjJttanqZb74rBnSViz7qh/rRmz0xMg26sHTb5Y7rsr1Rw8utozBk8SDn1+7IscGfiYx5Gf7Kk87dLTTtzx0Xk93iTnOuSFvNHLiXjOu75KyXqlD8mKOcu6Gu0vMsTbqe5eYb/jkGcrY8ujhKy8G9V3ygu4S8pbvjzzOeXy+vTDv7AH7mZ9n3ZfX+11inQ6XT2T1XdL5XmzNvNi7xBwv7buEZ//B/kVD9xH+3D/3lzMBj5hYB8T9Bx9ebsbLnUeD4EE9+XAhLEAKUedCFAwZxDxTnoNnEBmbsU7zBQDfuTouSD6+xKLXnwkwPmTqGScY6NEGBgaKsNExFm3F1I55TmgVt+pLu8JBO150xNU+zx3T23JcVRs3D756rA9bYqU5Jw7GEPo25/rLesroMxlH5mkvLnMo6zrOusRNQyZfO+bwXSd8eOjndamX7fIYucTYuTlTN+dHffyrpy3xGK9ydJRnfXDEFdM5thD68DIfnj7AZWwzfnv59BB8sKxXxlk3x4o+dsht8uBXdatzfWODTFuxMrZydIxHPWLN/GKS9JjrCxvG6jMWm7Uqo3euDnNIPuOsb1x5nfpTT79goEer75LOw7B7ap7poZy/NmtYnvbo09wT7d0PMLKue6FNttOmvkvqu8RatE6qdUUdQdU7wjn66DAfTg+e2IzRtU6tQ30ih1ffJZ373dyYQ/IDmW/G6hSC9pfheOZdG7HUZZ7Hzuu75K/juYR9q+4h+5XPFDrVOTruK7K8/+6xuMr1ZY+8fi4pUlfsQc5pye08xzFXTt6c0+e5Y3qb+Wfunqnn92v46nEPIGdvaM7x5R1hLOLR6y/r5TgZS9o5p9debGNUl3keOyduGjIxwHNO7zr1g35el1jZjjGUMatzcwYfPzk/hXGbr55Y9WuczutE8kaDzBNzc5XHytFFbs+4vkuKdBR5yTktuZ18MVduDplDee6Y3mb+mVdtPGPw1fOMvdbvEnNsDs0NvXl07Fxd5+YMPrr1XfLcO4Icka+cszwnbzTIfOa857Fy98FebHULsPYXZUyRq0MPIWcsNnuojN65Ou6xfHHt9ZfXrQ9x9QsGerT6/ZJyP8gR+TKP5tv80mfKOZWvPTLxkKnrfsDLuu6FNsbgnN47U1tsiFHdjK2dvvXFHMpzcCTsXDfjTCNGjBiyI5ZFixYNPfOh29vbGz09PUWc4DPOfnKd4YM5dvrn3i+edfJvfMAsAukq35TMAdXjOgN1BuoM1BmoM1BnoM5AnYE6A3UG6gzUGagzUGegzkCdgToDdQbqDNQZqDNQZ6DOwEvNAL/xwYcVfAAC9ff3Fx9a+AEJH3IMfU7R/rDHDz7s/ZDDD3H84EM+ej18gSEwn5J01R98vNR9q+3qDNQZqDNQZ6DOQJ2BOgN1BuoM1BmoM1BnoM5AnYE6A3UG6gzUGagzUGegzkCdgT+RAT6H4DMJPuSA/HyCMZ9Z+KEGcubyi0H67Sp/s0Q+OLSu4kv6tVwBVaz7OgN1BuoM1BmoM1BnoM5AnYE6A3UG6gzUGagzUGegzkCdgToDdQbqDNQZqDNQZ6DOwMvNAL+EwYcZfGBR/aUMPqvwtz2QoaMefv2NDmPwFzqwUx8Z4x7+ZlY2RqmmOgN1BuoM1BmoM1BnoM5AnYE6A3UG6gzUGagzUGegzkCdgToDdQbqDNQZqDNQZ6DOwJLMgL+IwYcTED0NPo0PPvjlDD63gO8vasDn/33wZ7Lg0fzgQwx7cHr40IMBxBgAaO6c2YVh/lAEQ+YQoMwzgaMzev4+FzryqvrMadjl5mLEUw/fNPgQff7nJmIZE34lZBC9ONhmLP2ogz5ydVw7dplyTBkDHT+hQodNMb/ag22ced3I9U0PrrZgoWtc6tLrX0zmjPENgZFlyDOOc3HoJcbawmNsbBYaOsuPHVfUj/lSR0zmxOGc3rUZo3/bjVwvXLiwCAE7fOY8Yet+wGeOXvaJsXz9MK+uBT3yZK6Yg03La4FPfMYjFtjw+Ic86usDvsSYWNEZOXJk0RsfPMbDEXYZB2xiFQcb7cWgh2cczGnmgTgc65M5Nto5Rp5x4HMBGRO4jLNPedihzxxSR0z5hbBd+9iAR1/fJa/Pu4R6oAaoHcfUig0Z9eqcPtcz4/ou8VR1evJGkzhj9V1SZsNaMkf2+fsO+VLP+9F80vM9Qzm9MjxgKyGD6MXBVn36jJPPgTrysMsEX52MgQ7nAhk67Hs+M8iRGWdetzLkNHC1BQtd+JJj/YvJnLHfa8HIMuTaguVcHHqJsbbwGC+7/Jh45uk5RTzM1QfTfDHOeMyJI/NcG7iM67vErHd68kaTyPdLvUvGrbhSPD17VrFvOfdgM2fvaPhwjIw5xN7Br59LyjzVd0nnNWZRIC/hLvGe4G77S94l3GlzZs0satwz511l7cP33CDzXCB3zNn03oVPjdA4N5Bn+fX4Gof7hxxD9V3SyQG1saTukuXGjC3ueHOca5japf7wR41ay8WGvAaeS1gb613ad8nYFVYs6pgzn5/f8M0+QvCZE5NxMYfkm3/m3h/IHdd3ySvzXMJ7arOemlHsDbl3nwpGOhfsI/L6/ZLX/mscz+zSvkuoMetqad4lo5ddrnjv1Joe7rnE7wvGQ63TvKeQ57PhPYa+62ANPSZNpgrZgLGAyNXBIaScuXL0HdMjg0dznO0KoPYXfTPVLzwapH/GYIkDXz19Y69NHhfM9MW4YFX9MHdt6JEz16QfoZxXMeD7TR0s/cDPusyVwVfOWD3kYqhLXNrCy3bO4RGDWBkPnSrlfGVb9MRnDE6eiyNf2/ywbQz6EFM8emQ0cw+OetorYy45ruq7b+hpj44Y+NJWHvKsq45x5XjAFzvzC2bKmT7FpQdPX+rbq+ennMwhY1SuvljOldvjR9KnmMrEVs8eOTL0GauPz2pOkGWfztGr2oMJwRdHfOaO6dGFpx59tjNW8bCB1DMmeMoYuy704KvHmAZfmzwumOkLsrwebejBRCaeNSkPvqRfbCBl9K+Xu8Q1kwPzwdrru6SsT3Ji3VqvuX6tJXt16rukPNPkjnx5ZunJkXPzRm8NMlbPfMKzVhm7J+jBV88ahq9NHhfM9AUZWBAYkH6YI2OOXn2XlLkxT/Tmvpo396G+Szo5IyfWLbmjUVc5h0UBtr+oU98l9V3i+aqfS8ofMCMfng/vd3OkjB4ZzXucs6ae9soKQfsLMvXs4fk9AJ72nmt6fGkrrucbftYxriq+2JnPGBKLvr5LOs+s5IZ8QOTZ3JInc+7Y3KGjHn22K4DaX9w3purBo0HgSe4JevDV0zd8bfJYe3tkeT3a0IOJDEz0rEl5YmhjHM7t67vkpd8l5JD8mUv32T2wNpA7Zh+yvvumDnroiMHeaivPvVRXnVwv6oAvdvZbMOu7ZOh8kjvz4x6Rb4g8m1tkNOaO6dGFpx59tiuA2l/cN6bqwaNB4EngigNfPX1jr00ea2+PLK9HG3owkYGJnjUpL8ej32qs8Ou75KXfJebVfXGf3QPz7X6pZ4/cfVMHHrhiWB/I5SHXF2N0mOd6UefF3iU9fqqOM1oRULvgdGqPQ/7bukF4scKHJ6FPIPmTZbDRg5BLYtHbkImHrvjwmOvXxaJvsqpviOnTWNCrkj70q2/nYmhrzow3r804sAUXHeMkBnjiMKZJxog+PllnlosDJhjZHpm+jV85WMg8/MzRF1u7vF5l8rRl7ernePTpWuzB0T864oLD3Caf3gZGdV3I8K++OcKHPHtkkLGhQ5PEznNssePFPIS+sYoLzxygA998yqfX3nWjR2OOnJbjYWw+sNUOflUPHPcEHH8S1XgK56kGxaKnzsRjzti9VAa/SvDk06NLj62NmFyb6zUm5/T4rO+S8jeM3EdymWuCsfkmZ+aafJJ7eOjk/BaTtpwx+0Ku8YG+5H7rE5lyZPrO/pGDhcyYrR1ttcMPtsiVydO2vkvK+yXnjFyRf3r59BC5JKfIbO4fOsgldd0/7eBX9cByT8Cp75JO7ZI3G7k1n+Qs59gcouPZYuweUuuStsw5x5B7rA591ssxIGPuPmqLD/cROfysk2NnbJyv1buE/LnmnNecW/cHXcjv9djR5NPb0KvekcjAUp99YEz+5dkjg4wNHfcpYxdKbV/YYvdafy5hzayV3JCTXKPMzZm5oYcnn75+Lqlf41g7njnPufWCXJk8786/1ucS4jRm+/ou6dwXnH3y4h3AHru31gNz7gfm3hmFUvoiXxx67iEbOaeevO/dC/rc8FG/xnnua5yU6iKH5tu9y3c+PPIMmVvtfXZCn1yzL+hI4oBf3Stk8JBl/9iDhcz7gDn6YmuHH2yRK5On7V/qLiEO12wPzxzlmI0dmfHTo0OTzFmeY4vda/25xDy439bWn7pLcm0xfjnPJeTcmiIW94ox2BL7QWz5bLD/xu9eo+9ajFMce3TFh+deY+v6GXseqHVJW+bGgl6Vsp5xqMPcuLXFh3lAntdmHNiDi9w4iQGeOIxpkjGij098ZLk4+sz2yPSNXP/ogIXMmJmjL7Z22GCLXJk8bf9Sdwlx0YiLeI3PHOWYs8z46dGhSeYszxmD+UrcJT0m3t5AmPMneywYgoYnkQiCp4dYMEHDQ9dCQg5f+6zvWBtx5NPTcmxZFxm48CD8oMtcPXjE5q9+qZd1kfOAog242rmR+IHHpiCX4KOT9RhnfPRt5hNf/gknYzIG1mCuKXbxwFDGmDWBk/0jR6YdYwldCJ58/bAOGnP06FkDOJmwc83ImKMnX1xjcq6NWPKZ4wv9HJ969Pgxn8yxRR9MZNjnln3pB5626sJTV0xwGRsLNsZnLyYy9ZHBp5cvvvnRhz3yKqb1oYwee/i+Ickcv8yRQ/qmp8GX57hQbOuKoS09mJAxiW2OiQFMcoNu1nOuT3pIP/VdsvgdQV7qu+SF3SXUEfVlTVGX1ioy+YytSc9vliGv75L6LrFmOIPUEjVjneQ6o4a8AzMfXVq2y7rIsLMG8YMuc/W8F+vnks6LKPPqOaYnj+4RuSOP5I5znMmcs0/K3DPskUvymSNjLmU9fCFzH7MM/fouWfJ3CXkl75D5dn/cD/YMIv/w6ueSzvOgueKM5HsHvq8vPA/eQdrAh1c/l/x1PpdQ89Q7Ld9bnhPPBfOspy589prG2HtNXPjYKS8OWXr2QiY2MvTAplE3yPRhj6yK+df8GsdckJucD3OYc8AaIc9R/Rrnhb3GIWfk0548k0NyS96tI3prBf5r+f0ScpHPnfVWJCl9L2TuefL8Wofq5ucfeMg9q37PBMOWfYnl/jDPeuqKaczGkuMzTjGRqY9MbPlg014rd8mSfC4hRxJ585zAI6fkDB75wy+EHnx45lt990SbKh85LdtlXWTgwoPy+VUPHrHVr3GWzmsc9oAcuxf0kueMOfvEXMp6nlH3McvQfyVf4xifsTA3Pvscn2u0Rukh+KyZZn6wU5++OCEyYdC6u8qCzYAFv51kA9SJc+3pPRRgGxBjfbkZ8ggQcq5c7GqvL/S1RQc7ePhk7BwZNvaM2dRsLyY99uozZjPQhcRGDk++82ynjDi8EOTxQgS++lwQmcSDpw49NsaAbLjNzXExxk4MbJXLAwe+PWOa2OgRP718dLO965KPnn7ofYghfhqUbbTTR5bB06YwTLWiHfraqqMdvSRPO+f6c64/csBaIHQYZzz04NO0yXroKhdbuXUlJvbo5Ibf7KMIpP3FHDPFBhILH/L1B44PP/D0g43kGpij4zdwseTTGz85ciwmvTEYp7FZV2BIxs88YxCP2MYJrvEj1xc8sCF1lOun2usr26KDHTx8MnaOzFi1re+SspbMrftEb3PPyRn7SY/M/TKnYJD3nGf03E/6+i4p821Nkp98RsglMvrcyKk25rhIdPvekOdegMs48xnDB6e+S8xe2ZtrcmRd55ybN/cAmbnWtr5LXv5dkncl1y589gCerb5L/nruEvfNs8BeSZwZib2rn0vq5xLPNr01Q43kM+79Kt8eHdqr5bnE2mc9+Vww52zkdcrDhrFz8+XcM0UOxESHMTqS36+QaZP10GVOE1t5/VxiFjvf6/O+mK+cJ+TVfOYc+2yhTnX/Ox7LEbbaa4vEfWW/GTtHhr494yX1XAKmdWIPjxiYQ8RBPnI8r9X3S8yz63dPX85ziTksktn+Ii5Ta4EevxJzcm5M6sJzrI575Vyd+i7p/I8+82iuPOPkyDE6NvWsBfoqRt6rPBaDfRDbvXXv0XF/5XkfOFcudrXXD/raooMdPHwydo7MNWi7pO4S/InPWD/mz7jqu6T8jRf3hbyYuyKB6Tkh587cYpcJW+3Jubm33rKde5J5jpFV6yTHuLTukp4cvAsgqMxnbIG7iGrPguFlfp6L54JZHHL4XPDZp7omRD34eSwWfPxT3OKIUTDShwPM9Q0WdsZuj1wCx7XD00Y5PXIOMlT1yxw8m/b4wo65hI728BnbkBmfNurSg6UP5uqKjY2Y9FkunvFrT0+DqjrwxFDHeWHQzoVYf4qXZYyNE1vH6ih3jk/WnQk7bb3wkMODwKRhq54Y6shXvzBMX9TDjr3317PUR27Dl/yqb/hiMc41rCzvq7rgiG8OqmvQJ3zXig0+tKXXDn3IGBkjt07Ry3aldvlVfraHB9kbM3jqDdcTa47BMT0knrbEJXZ9lxQpKvbUPJkb5jTrwbzmnCL/a7tLcvzUhuR6Mi/LGGdbx+oodw5O9SzoA9v6LikfUsiTeanvks73GnNiXTEnV/lOh5eJsybPe4xaw47mmD7XJjbeo/pDPxPy1+tzCXkwH+bRPJE7mnL4w/HMJbKqLfshXz14Eth5v+DrA736Lhn+LjF/5KqaP/JmjpFT38zRM7f0meTD014de/iMPU/6qPbWUeYzdi6evogLGfz6uaTcFffKHJEbG7Jqjs0pPfuDjhjqlsiL7y95z3L3CF39IXdsPGLpV4zqXH3t0ZOG42VZ1dYaUUe5c7BZc+brA9v6Lhn+LjFH9ObPnJI3awK5d4k51lZ9+szTHp4yevjiOR+ut66MQTzn4mpL/GK/2u8S1iTldcJjzlptrJlc0fIeoYuO9uaGuRjVHKtLX98l7kCnrslhfZcsubvE+rQmOxnv5Bweebd+mVun8qhV9Ybrq3UuHj0knrbEJfar/S4hN6/X1zjuIftqDbjH1hx8aThellVtM7561hRzsKmlTPpA78XeJeBke+bZn37QgfD9Ut97XeyDD8A8ZIALDM8Cy4GYVHoOEL/qCTGngYE+OMwZ0wycHlxk6CDLetkW3GyPnTEi0x6+uozho+cBJ1HwaPjSFl1tleEPUgbfGJSB4XrkoWdsHkpwXJs+KQx+ywM+8VVxmIsDdo4XW+b4Yox9jk0s5JBY9OKITW/sjplj61rgk4fMB5efwhAHXbELp8kvc3+jxTyrS/zgggPPMXOxlYFjXOhB9sWkLWesrXGRI/ZDfHRcE3zG+K/6Qs88YEu8/vQJYxq2/okAfaCrbzCY2+Az9gMTMMyP/olFv9hnQj/XjGuFDy7xKGeOnAaBCTFHDxvrlHkmbNVnbH7UQR85GOKjByGDJ4Y5hm+OxAEXoifu+i4pc+j+07tH5sk8m//X4l3CGqktiFqyxjwr1qv1Y/2jBw977ejNp/rMaebSvnBYOSvqWqPWsDERC/bWOXrGAR729vDRJd76LimzTf7IUX2X1M8l1IFnhOpwzJnxHMKjee7kl9XU+Vvu8L0L6rukfAYxJ+SKnNrgM66fS8oq8vuEd379XFI/l/wl7xLOJsQ5hbj/GHue69c4L+81Djklx+RVqp9LOvVFTqg1ckJz7plgrgw9v69Yt96n6MlDzzquX+Msmdc45Ndck1/3IuedMYQMcg+YY1vfJS/vLqG+yeOSuEvYn+rZgOc+1c8lne+L1nE1X/m+4XVA/X5J+YPW5IWcUUuOmZtHZdTb0rxLwOd7B3Hoy54YiG1JvV/S/fnPf/4YnAEMcdm1ohELnn12sYUjIyBeEKHDOAdpUaGXk8ecZJnEIR/tSwEM5NlGLGyMS1xk6EPK82aIpZ724mvHGih8+dhlXRKMTELGnMOErjlTJ8eCzBxpRw9f/+YPLMbIIfEYGxNy+Oqoh1y+L+iRoeeb8FkHPk28bIueuPqRB58xa8cP9qwPIofwsDFnfaNGxbPz5xU8+HlNzG1g0sCDyA9jLyR4YMKngcMFrx+xc03KExsb7ZGxBnps9Gt8zJFB2R4566WHD6GHvtgFs833wkUn1wE62Yc2YhoTmOjhz/wag3GhA74tx4QtDV3s0IXIGw3SHjkEjr3jgpFk6qqnD+aMsRMXXs4ZMuIRG/28b9jBg7IfxthoJwZ99oEtGK5ZG7GcF0ZtH8jEUc5cDHv1jMGYwILHOuu7pNwn6suc5jzJI2eMX+hdor77A6Ykjx5MmjVkPdV3SX2XWC/WI/UCUS/WDnPvq/ouKe9R8mCu8rkzb8jNac4xcvl+v0EOFne+OVeHOU08+S/nLhnZNyrmPTO3wAUHTMjY8SfP2IwDHRrxQPVdUj4rmQfytrSeS0aNXiYWLVw4tDfsSd6fYtL+oqy6j+wb+wcxRo/Y1fecWwv26tfPJfVrHOqGOoGsdernL3mXjOzri4H+/qKOqXnqlsaY+rbG69c4L/01TvnadX6x7+x3fZcs+dc45Lh/0cKijqlf6paz5l1NPXtnsxHuA3roq4cs3/3I1BWj2Mi2nmcFnb/Uc8krdZeMGNkXixYuqN8vad+R3o3sPS3XFfXkOfcuRU6NWCfaW28Zw7G15lzd7IsahKxhceH9qecSnmdbzfKHXbHFjh7Kfhjj3xg8E/rVhxj5TGAjVsbQBzJxlDMXw149YzAmcOARA+dAPnZZN3+P1QZdvq+ha87gKcdeWX2XlPkkJ+Yo58lckS9ryHpiX+SxD/Bp4Czt917LGi/ridjwSbNm4bkO65fYJNb1Qt977T7qqKOO0dAkNbq64tn584eKEcDcdG4g2OUkVvFMpHx6edrpWx3kNPwio3dzlDnXBh3JMTqOkYFl84CBZwL1Za8tc8iY7OGh49yLslBOX6o4iMQUA52sh1wd18E85x2/tIzB2HjEcy6eGBZV9q1N5lXxjY1ePXmjRo8uHmyY4yfroCu/CDrtiTjGpk/0IXrH6ErascYsZ+y67bHRNuPBRweSn7Fy/uHrUzznYBA/vXgFaNsveuLqx/XiI2ObO+yzfzCc6z/7wK8+5NPLQ24c+GAMwTcG7apryPGhY4xgiANfX1kOXz17eehpx3g4v8ir/MzTTt8FYNsGO3waP+uEZ3OuTV6L45xz9MCy1XdJ58GturfkKvOqc3Po3qArD11rMteSeOhZO3lPlGeZuFnPWOgh7agLsOUxtobsldHneJmjk/kZyzrSRp/oO6YHw5oWrwBNeuKK5XrNmXjw1c3+kTvXf/aBX+3k08tDDgZzfDCG4BuDdtU1YGN86Bhj5sHXV5bDV89eHnraMR7OL/IqP/O003cBWN8lxV6QE/Ni7TDPeSe35jfvD7zh5uKJ8XKfS3hzxR/eqcZrrPTGQi/fvdZOHWNDrj5j9eRrrx1rRkc5Y/Ngr4w+4zFHJ/MzVs4/fH2i75geDGtavAI06Ymrf9frORYPvrrZP3Ln+s8+8KudfHp5yPtGjS72DR/gQfCNQbvqGsAwPnSMMfPg6yvL4atnLw897RgP5xd5lZ952um7AKzvkmIvyIl5sXaY57yTW/Ob9wfecHPxxHi5dwl4+mEsvjWJn6yDLnP9Wz9ZJ8vUz3qM4UuMeWOADz70r515sM+26KoP3zzKVwZWzj98eDTxnINB/PTiFUrpHImrH9drzsSCr272j9y5/rMP/Gonn14ecjCY44MxBN8YtMtr8IMP40PHGDMPvr6yHL569vLQ045x9iufvsrPPO30jQzChoZPZPSsUz6987bJUE6Yow/lnDMHy7akXuOUdbyo8Fm/X1I+F1iTuZasH/Jv7eQ9UZ5l8NAnxwsXLCjG2Li/jplTE+jKY2wN2SujR64+c3QyX+1/fKcAACAASURBVBnY1pE28IzBMT0Y1rR4BWg6R+KK5XrNmXjw1c3+kTsHm7lkDNrJp5dnLpjjQ3v4xqBddQ3YoK+NMWZe9pXl8NVjP/mBEHnoQcY0nF/kVX7mgYHcdRaAr7K7hPywBvr6Llk6d4l1Zp2Qa8n6zHUED133xR4bbZGLBx8dfrCDD/eyDH3Prnx9iuccDGuacSZ19PmcP3VF8fR0lz/dbkAYScidO2YuoLIcpEHAIzDs+KkqdZQjM3Bw5KOX58ZCDz/LwJafe8b6x4eELYQv+OhAJBsyRnp0jKkQJv/MjUU/9OIjz/jiInesT+NTxtwLFl2JWPTpWD/kQZ4x68fe2OyxRdd91d6c8gICYu5PFakDHxxjF8d46VkDclteL3LXAl98bYyJufGLrU9iYGxMeV3IcgzgMWdN6DG2Z0zLJBa9TR3n6ohpPMqdZ3xjRyfz0SVG1kKT8hiePrUVBxm68MkleTMOMfCND/cVuflFxhxddMSTrx/wJXiQPHOsHCx14CF37lhc5Mry2owdnvHXd0lZr+aO3LCPEDkyl+bMPWYuuTdgOEZmjuXl/GNvc6/ssUXXfdWeOWTNMfesq4McHGMXx3jpWQNyW14vcuxp8MXXxpiYG7/Y+iQGxsaU14UsxwAec889Y/TpbdhIYtHb0IOcqyMmMuJR7jzjGzs6mY8uMbIWmpTH8PSprTjI0IVf3yX1c4l1Qb3lM5TrCh0adUMPoW8dKoNvvdmrb48OOJ5bMZlDw90l2tCD49kQB18QvfcCOq4JGWPk2NPQq++S+i6xLnO9UlfWE3VDbdbPJfVzCXfGkrxLvKO8A63FwknlPqMGqVGfIbzLrFv6TGLR29Rxro6Yrk25c304p0cn8+ERI2vx/MDLY+3otRVHXfhL6rlEf65Hn/Ah+BB8yBwXk3bs6ih3jm7GRa5MP8xdP7zX4l1irnIu8vda5fKY5/w4zmfLXJozZOqJR1716RiZOZaX8y8GvXtljy267qv2zKHhnkvUQQ4OviFx8APRswbktrxe4wEDfvW5JGOga4OvT8fGlNeV7dG3zj33+heXPpNY9DZ1nKsjpvEod64P5/ToZD48YmQtNCmPtaPXVhx46MJfUncJeOTO9ejT2OAbC705Vo69Osqdo5txkSvTD3PXD899rJ9L6ueSF3OXWGvYWFv00JK8S8ATvwBvf7GurXd6/Wce6i/0Lun+4he/eEw+HMVh6+qOBc/OLy5UD599dsQYosdhThA8ceErZwyfhNFzCNHNG9Fe7xA2MvT5NRx0waCZdHobRuBigy4JUtc5ffZbTRb68CDswUYfYow9TeKixAZd/OKfpj/4tKo9cu0YY4ue8eNLPHzQkBEbvZji6lNc7NEBA1vH6jEnp8ggsZ3jBx1xjBFd4kYPHg1b9Oj9qRkx4dGej5SpBx4EHs2L2lzB0yd67qW/PgdPubrMWQvkmqr+0LFhh55zbejJp3x6cODr17E27hdy18BY/8RPY55zSgzY0vCTCRwxkHk2sEGGDUQM4GpvvMjQQ98aQ4a+NvDVA0PMgtmOH3vs0BUHuRj0kDL901cbevDwQ2yMsaPHP+Ta6GnwiYHeOsAGgp9JPPjmSxx16W3YgmsMrAV95GAxp89+816hh755Qx8e+pA4YEjsPzbomjNi0B98WtUeuXaMsUXP+PElHj5oyIiNXkxx9Sku9uiAga1j9ZgvjbsEfHxDjG0FY5gvyLMu8UNg0Mg9sZoreOho517Wd0n5oqxav+TJnOa8oUcurTFk5JmGDXwIPeaeiYJZ3yVFnsiZ9Ue+6rvkpT+XLLPscsVvDlBr1CW9Y2rOOf3zkTJ1rXvwaPVdsuSfS/ipr/nz5tV3Sf0apzijfP+QPMecQ5rfc9B5PTyXjBg5MuY980zxvYKckAPuJvJiTswXvflCB7k26iJHz7k29ORTPj0Y8MVwrI3PkcjZF+XendyVNOY8P4pNDNjm73WFkzYOY+P3mR0bfGAD4Usd5sbL2BphPeqgrw189ZDzk9X97f9VCh8e/sBEVxxkYtBDyvTvGnOPHnNiJzbG2NHjC3Jt9DRjoM/PB+gSWybx4JsvcdSlt2ELrjGwFvSRg8WcPvvNe4Ue+nkv4KEPiQOGxJ9h4s9Qgm3OiEF/8GlVe+T4MiZsGRs/vsR7vb/G4a7g+yj5cQ/IE+Re1q9xXj2vcdhP7iXOgI29ZPx6vks4594Jnv36Lnl1vl/C94VGLP5+M/XtHUbPHlv/9Ow1fM+CY204G9571gm6PSgIhAKXJKQyPXL4/I0vHEMCM9ZeO+bIsaWn6RQewcCD4EPZL/byfEhCjo16yPWjD2PWll5812FMXPrGgQ7fDMTBB37RpakH3zj0n9cOD1IHGfnKuMaBHnKxXQu2Uh6D4abDr64r7wv2rhNcKPdgMbfxz3XhgWu+wTNWxvrUL/nyH5tjC1+f+Ms+lBuH2PBt2uLftcAzBnoIP+SM2LHNOVLXdRUG6eFLDOTmPdu7du2NzTk9BA5xyMcOHPjGwBx7dHwAVR8MxqwTW7DQz3JswaJHh17fxSCdUWzBck3oQzkG8cBURu+cGCBwaMQCgQEZIzg0Y3W96FT52IqPXF349V1S3yXW3J+6S6w/640a0w4etUpdWZf0zjkHyK09648eAqe+S4pUDJ1T8k3O6rukfi7xPqf3HFIteYzM7xfwPZueNc8fepBn0+8vudefZ/3lPJfoi3j0adzi48944RGrushozuu7pHweqOaEubkuBumZgny/2LukiuH+gEOzXtxL5IzdL/eWfVMXWeajj1xSF379XPJqfi6ZGhOn/DAmtzf2beP/LfYeV77OeTl3CbVDDdV3yWv/NQ6l4+utfGfUd8mSe7+EHJtPxt7f8Ljjvcu9p9Wl97mUMXroSHmMzO8X8P0+4l2PDEIPgs84+4KvH3rbq+EuIXbWyLrr1zjFFg99z6ceyI219Gp4v4QVWN+57q1J5NY2cuuZMTUgzzWj75kQV3t9kRfwkWefyOHDs2EriSe+uMZUv/f66rpL3NulfZdQP9RTri3rmx4iFuKQT41Sb/Bp8K1Xxs/33muPRapTHENcDIyV09PgA2jBo8tcMvA8h+flor246LX+eH78w5d+Fm/91x/GoRuXn9CwOBp2LoheajQGYsqPj44vT3wstjjsO3HUTmOG4ijiXvhkTLnhmrj0htvi7vsejNkLImK51WKTzXeO97x/r3jjmHKdQ+sYnB+P3HxNXHLVpLjrDw/GY89ERN+YWGez7WO/9747dlxnmcI1+pnmP3RNnHfOxXHtnY/F/OiNsRv9Tez9noNizzcuV+TI2LEhT4vnalFnDYd/N76w89jCRt2uwadiyrXXxK9/c3vcVVnDuw7cIzZZoYzEmBrNZ+PR266LS6++Ou78/dR4dG57DZtuH/u+912x/VqjhvbNddO7n3ld8C0w+ayFfcvr0NYYsq762UZb/aIPDxoOwzqs2umXPteSevRV0qcybTM/yxjTiIG1GB+8PFYPfzln8qlh9MGA5DsWi7k68lgbY+3li8Ecn1UyJ+i5D9pmP+ple/Swg5CrIxbyjKW+etipg28ac+Vieheoi51+xajO0f2Td0mqW77J45v80J7/Llm8/vCp3xw348xXD77xDjd23bmW1S8M21/Efj5c1tJoDMZJ3x+IE8c24oaDemN821a/4jGXBx62kOPsg7GUbeRpi4y1uA595B4sMbRnns8FfDDBMg542lbt0VU/22iLPmMx6IfDMO6qnX7p3Sux1C3A0xd9IlcX28zPMnGIgbUYH/w8Vg/MnDP59V1S3yXURq5l5tYQY4h6sc81hh6NGqzqFAbDYGkjHrZ5bG2iJyZy5uoVg8r3N86L69BH7nPc2iPP5wK+d4NxqEtvDPLQVf8VvUse6I/1frX4s6MxbTm2Efu/pSc+tFEnr6/Xu4ScUBOsv0rspfWFXB147Km1o5366sFXxzpgrlxM/Ft7yCH9ilGdo/fnnkueevy0+PbcRwq8EnT7+Pi6fxurDj7fa5zyDOcY9JvjZpz5jGna0Q83dt2ewYzRCbKz9ufDJZfaqlPYz5wYR8/4bRtqzdh7jcNim2U6saCLLeRY+7wm5MaPXNIWGWvp7u6KjhSjzrMzdmJoz/yF3CXaVu2tIevG2O3RZwzZD4eR84+ednnsXomFTEzXQ59t1cU287UTg54YWI/xwWPc/+Rt8etfXhAX3jhl6DX01jvvFfvutUtsMKZcF7rFc8m8R+P231wZV119d9z5AK+HI3pXWCe23HbPeNd+28QbypfQQ3uuL+JbNP3uuOqiy+PqW2+PqTP7sYy3fvKbceSOKxZxsE9VMif4J3bXqZ71oZ58evPBGHnWMQ/Gl/WzHnIa+tooF/MF3yWD/TFtyg1xxeXXxS13T2nnYHSsvunm8Y79PxR7bbzcUPj4tG5f8GuchffH2V8+PiY+tnkc/u3Pxi4rdOoHPONmTD7zmq0FeehUx9rnWlanUG5/EZt+OFzyWNXRXr95Lg+bBU/eGddddnVMuueemPpYUX0xdu0tYod99o93vXXNGF1+1lHsGRiNe8+N9x97sXDD9HvFcWcfFBu09xlftDLueXH9SZ+M7y/8eJz0uR1jhbQnAnW1FsTDv7s2fn3NNcV7SuX7MWNjnU23i7323zt2fENnT60h6wYfuem3iDvtj77owTD/6mlXxlzG7l6po5+MxTjbqott5mOrTJznu0uG9FqzY+qTk+KaeffGQ81novwxzb4Y17NWbLLMNrHJ8uvGqiPr90vcJ3vzR/5pzotB2q88R+/PPZe86LukUn/uO37xZ7yMrY/WwLx4cPIlceE1N8Ytd5TfG2K598YxJ+0bm7btXJP21vIQRnvNrk++/rWnpz3vXfKHc+Og4y+J2PtLcc4H1i/gtGECHrZ5nH3oF7k+M09bZKzFdegj99iJUThsY7on8sAEyziMTSz16NFVP9toi43x2ldjwN64q3bMxXCvjEfdHA9j9fVHj22VX8X5s3dJeg7KOTOO53u/pPiND5zbDIyFw+MTE3qIIARUbqD06OVEMKYREDLs1SOgrtZgLJj1+/jF6efH9ELSKST0sYPwiT96Y5n+v9+Nf5v4WNuq8wAGA51Z1/8ovnz67UPyYjD3sbjr2nPjrpvuib/7+udj5xXKnxZD1rz35/HZb1a+CS6YE1NvvDi+c+Ot8cAxX4lDNujETzzP/u4H8Q//eXXMG/LSH7P/cEOcfcJNcdcnvhKf22HFYv3mzTUU/prNmHb1dzpraBcBsZvjZyafHcecfusQejFIazjia0fG21fq5Lxryi+HX8NNF8d3b7otph7z7/GBdReHY5bzjG958IndnLt/7jF8eawtk2sGA33k1fW7r9jldbt+ezAYG4d48CDjEadgpi9ZL8eZ14aOMvwYDzp+Sq5/oMWE59qIk7pGXx1kVT/iEDc4YjlGjkw9esfagAvP/GLLGFLfuApmOp/oItMvcuaSOPDwx5yxD9nwjANZxtE3vX6wZb5U75J2nlmD8eATondNxkSvPI+1zxjo0eCpy/rZVxrrAx8eRM8cG2QQY2MgjxkfHefoZj/mDszSZ5Qv7tt7CDp8Y9ReO7GsYeTIsHGsbzCq/OHWkH9VugBJX1yjfhHBo+VzwBjSH37kEZ/EGD54YKAPj2bc8BhrB5b+qz0Y8NDRfxVL3+o4p8cWMg5leW3o5FiMBx33IWOLCQ87GnHWd8nizyXmhjzVd0l517+8u6Q8V+TVGqSuya/1aS0zZ0yzhql9bLFxLA76VT489CHG1PjSukv0oT/j+4vdJcWqh/9yy+xW3HJFf9z8TE+cuNVznxdcAzmjkePX6l1Chlib5NqZUy8QPGqLOWPqUR588oPMWsTG3Jk/9GnMX5m7ZHrcMz996FEE9du4beausWr7DWTiIWZigvLYuWuqrkdd1k/+aOCRB8+hOcMWGcTYvC7xu6Tw4JdWtIq7pcw58dKW7F3SWOyDj1bxwUfp3zXqFy48Grky59aeOYMvz5xhyxg+eGCgD48GD4LHWDuw9F/twYBnHOLBE6sYtPfMsX3W0x+yvDZ0lOHHeNBxH/SP7cC9P44vHn9JPKoT+rmPxeSLTo/Jl98YR3z1yNh1QokJxr0X/kt8bWJWjuifOTUmTzw5Jt/yYBx3/EGx0ajFn6FbrUUx9cKvxTE/vS/4uKND/dE/+Mq/xsE/35PIv/vn3hibuTN/5JTG/CXfJXOujzOOOT1u0UnRz49H77whfnTnTXH7J/49jtp55aFadL/dL3rihNxn+kI+OD0mnfzVSG+XDNUh+ujYsNGO9bOvNNZnnWODjDl2uaaMYYnfJX/2ueT+OP+fT4yLigz4pT9mP3hjXHTSjXHLPl+Orx28AX/ipIgdja7ymlV52L7J2a5IBufNjKnX/Sh+yK+WbV6eT9ZNI1dFzjl7958fnz+x+p7S7Jh608Xx/ZtujQe/dHwcsmH5vQs78g4GubWm4EHWYs61e1Xt3QPjEC9juSR1nNNnPf3Bz2tDRxkYNHjoDHeXiPns7Gvj3Cd/FX98Tu4XxKyBe+PaObS3xUc23Dt4qwo7YzQHYtErR6ae8RCzNsQK3/xil/OEDB3XhC28bK9fZFlPHHjoM2dMHuSJgyzjGCs9fPRpzPNdgk/k6iCXR88cHxJjY0HGvqhXvPf6Sr5fMv3GOO3r341Jjxtdu5/b+VNs5IU4WbtxmtclfpcYRqtzx5tzc2wNo4rM3DJGxxir/OHWsLRe47in5sxY4RMj+SM+5DlueNaR63Dd1d56ZV2QeOg5LwZL6LkEXHzR/7m7xFyzNuJ8Me+XlO/QGnnl0tMxi8UJvYnQxEAXLlw4dLjUR8aYRiF5EYA17/pvxxGnLv6mPvo0FqANMYiHHfOF95wdXz9teuy2984xceLVRSjo5M2N3vGx3Qc+G+/ZbsOYMGZ09HS1ojnngbj6J6fFf11za5xywS2x3UfeHD1DB22Z2GTvj8e7d94iNlx5TIzs7YrWs9PilvO+GV+77LG48HsXxrbf2i/e4J99WnBn/PgUPvRYLXb77GfjkDePjxGNgZh++7nxtf+4PG4969L4/XYfik26y0vJtbEGiIfKb5w+I3bfZ+e46KKrg4d0dCB0aM2elYo1vGub9WPVFZYr1tA176G46tyT45RJt8apF94SO35sy+ht/0pjxOjYdN/DijWst+Iy0dsd0bXoqbj1J/8RX7vs0bjwpItiu2/tF+ukS9R4zHGOkzE5ldDJMSLDvmqT18BYPfnUkPslJhjFmts+9EMt8A0AjNyU01NXkLjUCFjMveSx1T9jdeQRRyYuK/7sAb5p+DBWbLUzZnqoiksMxGi86DGm1wY748OHscBT35iRyQNbn/z6LTJ56GdM/aPvWExyZDz02g2HBU/dHHcRSOULflwLeTGH2BursRgXshd7l7BXOSaxwP5zd0nOJzGqTw6qsZkXfEGuTb49cmytE/jGB596Um4e0FFffHSqWMrwX2C29xN79NkfMDNWoVd5MBIXHGywNQb3HR5EvBBymjljDKFHMzblmc9YfWzQgQdhh8yYxMr2YqunneuFL6b2eY4+e8ta0M3NOOjru6S7+BOG5M46MFfk0JwyhswdOp4f9soGHxoOC5566KhbGFS+4AffEH7qu6S8Y17uXUJeaZ4vxuwDvWfr1XiXWD6ujd6xa2WdjuldL3zrXJs8B/vF3yVlRLtv3Rvf3bL8KTz8dA024u6bBuOw2yMu+H0zPr/1iFij/f2FmKx511M/l7xK75K598Yt5eOaW0kVxa3zp8Q+K28aXemNPc4b+87+U3/eq/A8m4IghwdZy9aMfPuMhz58ePKX+F1ikEXPHcP3/MWfnfFtvK6BNUGcR9dHDphDyod9Lik0yi/46unp3G05p2C4bvODFTriIzdH8LKNY3Qg9RjDW1p3CX6JkXzoh7sI/67DuNUxppxneH/yLok/xnnf4EOP1WKXw/4u3rft2jGmpxXRPz3uufDU+Novb4tTz7sxtv7038Qo38wbtXHsc/j+scum68caK5Z/PnnRE7fG2SeeGJc9dnF877Lt4rv7r1PEbywzrv1e+aHHchvH+w8/NN65xZqxfHen9t1z1vKafo0z2BPjt/9AHLnvNrHu2GVi+VE90dNYFA9ed25859RJcevpv47bdvhwbJnerbcmfc3CMxF5IrfUAK27uxl/+PGJcdoT74y9d7okJl5Tni10qBcwJMa5huC7T/LtwUYffxB8fcJf4nfJC3guGb3VnnHYXrvG1muNj+WW6Y7WwKKY8fsL4rvfOj/uveiHccVOx8cea5TPqdYVsW95xElx5PblryO5PtbAeiTmjcZ9cebBxy7+4UqjfR+186E9ds3m6OI9pXfttHlsMGH5GNHTiFgwPW776YnFe0oTT744dvjP/eMNbV/6M5dgwHspd4lxg0Ujfoj+L/YaZ95v40dP/Coe5m/sd28X75+wU6y37OggLdEaiAXPTo+H5twWk+eVd23BbufV2irX9UBcPOWH8fiYz8Vhq4xdrEbRY42sOZ8FeO5598LfxRmPTozVJvx77DW2/J5insCn5s2XOaMXk/NmPPTwIfEzFjx1xSiUh/mCT88bsefXOOJX4wL7r/r9kgX3xVnf4EOP3lhnlw/Ex/bdJTZadWSxTmKH6FnXK3aXvPHgOPesgwqfni19u1f07kWOMe+D9eC+uzfDPpekOkGP5vrxYw7k01tX+Mw1iS6y4Wy0F1s91+B64YupTZ6j/+Jf47z85xLi/pPPJUvovdfiT12xcJrJoScJJoI5cg4ivTKSp11h3C5i9ZGhQ1Fpp6yZvqloSw82i9cGnptXyKZNim994/IYf/hX44MrXx4T+QmTduzaYj922w/FZ9rrwr6gMW+It797j7j+mh/EXdNnx/xGI8YY80b7x/9dv7ykGo3yIDZGrxxbfvDQ2OuyE+LiGfOKn0hhHcW6HrwjJi2I6N390Dhky/HBv/JqRU+M3/LD8en33hb/8vPLY9ItB8TGb+1bLI/Fep66Jk78+q/LNaxyRVx0UUSju/y/J0P4XV0xZpsPxaeH8sQF3RWtZdeOt797z/jfSafHXdNnxdODgzG2naPYaP/4143KfPng0Rg1Id7y4Y/E3pd9JSZOfyYWcWjaD80eDnt8F/GlfSWn8NVBrp5jY1YXPgcs68GD1HXM3mDn3slXj56DIJY98RiTY30yR8/aYw5+rikvKzGobXjOtdcfWI7RscGTXywwXeTMzYn29Noqw971I0PHBt+cqMMcPdaTsbKtawFb39qhJxmDPPXFRQ8/xo2cBplD52I5FxO+MuyQL9G7JH1oBbb+8UkMed9dhzJ1iwW1Y8NGuWtQD/sqoaNcfXr5yGhg5n2Rn/dH7IwDr7Cf2R+fPK8Vl8GY1Yxtvr9Q9dh96574/prNOPTnzYjNu+PM7dp3GPs/fSAO+VkzRmzeFf+1TfnpeJGHhxbFvhc2Y4vtu+OYzUo+gF1zm3Hmlf1x1pMR9zUj1uiLOHCr7vjwmxsxtqfzk1+NRjNOOaUZ/zGuKybt1YhJVw7GmU9G3N+MWG+5Rvz933bFvqs0YsaUZpw0uRWXzh2I6V0Ru6zRFcfs0RNrdFfuklYr7r9jIM74XSt+wp8m5EXJhEb80zt6YruxZc2V3FZ8/+RFceK4rrjhwK649+rB+M/7Bos3ltZYthGf2rE7Dlir1DTHRf/sYFxyRTNOeqRZrGv90Y04cNNm3Dy5GZeu1x1T/rZzNtknbNxD8uV5Yx9zTXkO3LP6LinvF/JX1Fm6q+u7pFPz5KZK1ht864leflHHS+IuqdzJ+DMe/TJ3//TL3HrHhrE6OWZ1kEGcGcdVLGTwPF/6t0cGYe9YG3WQKyuU23N46sInrqqetvLp8YUdTR/wc3tRzyUG1V6Ha212t2KTt3bFfrc344w5rXhycDBWS3v/erxLyLd7lnPPnjCX92q6Sx6ZM2not9pTKcTAwnvi3oFNY+Oecm3Wm7W4YO7tceOsm+OmhQ/FrBZ/FKQn+rrWjA1GbxU7rbBZTBjZORsxOCsemHZDXDf/9nhgsP0nRBrLxqq9m8dWy781tl1ppaH8gT975m9j0qxr487+WVF+u+2Lcb0bxluWf2fsuMKYdN7+GBOn/PfQ/85Yc7mPxM7N6+KKZx+Ix5vE1BfjR74jDljlbbHqyHJ1Ux8+On7wbF7pw3HJ48fFJe2f+nzbSsfFvit17pJZsybH/z59Q9y9WCwbxFbLvSN2WnFcAeT9QY66FkyJKx+/JCYvml7E3tO1brx52VVjVnaZzpE1Y15fzF2Sz7x1iZtX+i7JPlkPcbGOobtkST6XzH4kHqUo3rRHvHuntWNc8SwUESMmxCYHHBy7/fK4mDh/XiyKiJHt+3uDd30hNmzfkZ7T7vGbxaGH7hGXnfCrmPbMwuLNFGTE3TXv5vjpj26L/r53xj+feGhstQy13Llv0XNtjD0bhW37+xB88+DewqNJ7pk89bOedwk2yMXy+5hzsZyLCV+ZGC/qNc6K28ZHP1k+b1pXzUZfrL3TfrHP/06KU++eFrOebkVrhcXjwycxEL8xkR94yJ6c9J9x/BXj4/ATDoo1Lr8kil/IKb6fdvLpGrK9ubNHR7n69PKR0fBJ/FU+MWmfMRmLp33OI3Jss577n310dW0Y7/qn9YawiKGruzfGb3pAvH/X8+P4ix+MaXPLDxEyZgHc/uIawMfeODo1mLU7Y/S7288o2hRr2mi/4v0YNIfWOGpC8Z7SPpedEBfNmB/96bV0NT/YGZNjfOGDNoQ5zHMJ+uiKia76jq0z5ugV62i/pwB+ril0ITFe/HNJf9w949LiQ49l+z4Sf7/mG6KvWF+J2Wj0RN/oVWO9kRNifWLh/LZjMl5zS8o43a3mQHGfELcNHYj15ByBMbSP7ZeS8LRjfczNw3B5A9cYIDMu4gAAIABJREFU0NUPGMzl4UceOGKZQ+diOdcevjJ90JNzZeBrVwSS9gY+DR33EDuxHDsXBz4xaIPcdShTtwBr5xkb5a5BvYd+fXrxm2YbHHJcHLvHakVc6ChXn14+MhqYnX25P87+4PFx0eYfi//86Pi48ac/j4m/uy9mL+iNsRvuHO/76Afi7WuOiFl3XBxn/88lMfneOdHfNyY22P6g+MyHt4sJ5eezxXriD+fEB469OLY8/Htx1E7Lt9c4Jc758HExcfOPx6lHbhUP/fK/44eX3VT8u4DR628T7//gR2L3DRb/dwfuJzmCiLccT4/rT/3vmPjA1Paf3PNfDmwX+x74vth+jc7/uHb9/JuCqVf/Is746aS4d2Z/9K6wdmy56zvjDVPOiPNu2zOOO+ug2KCd78LZ4Jy4+9Jz4yeX3lTo828ctt55/3jP/tvFWn1/odc4L/P9EtZFTtl78miN5LF1kmulyEf7i3ym7EfGAkf7xX7jIxtpmJ0aiI7ynMNiIcBnDunIscUxdqfPxdk7lIHNvfZb7d/+6LzBDgYNewOO6TfFKV8/Paa988vx1Z0nRPy+jIRfcEbHhZbc8vIzfrCQR/9A8aepeldeMZbFR1vZOOkh42z0jBCuiAcc6PGH7ik+CNlt8/LXJxvtjcJ+rQ3eEhG/iskPPxqf/Jt1h9aBXWPG7+LUb5Rr+MqOK0Xr3vYFyv+zb18IrttY9GkgrUX97TWMj9FcGMNc9IvZdHfWAKYNPPNWxJYKF3vzqb5xZV3saVXCZrEY8qEdZlzsTZuPrT7AAN8Y4DtWj08mJXW1Zy62OtobHzrUqz85A59azg+u+gLDvDCGj75Y+mCebeDDw5fnhLGkfT74yujB0i+6jIlPypjZtz7FUN+5mMyJB32ac3rnrrUQtvVzvGBJVV1k4mdM9fXB/MXeJdi4DnzQ8E+DXBNzZdoYE7KM4bgASHsnFnKJsfcdPH3rH7l+tBGHeZYZI/IcU4mr9XP7wueERmzbFXHitFbMabViTHsvpz3UjBswebAVM7ZtDP1fkOnTW3FXRBwyIb2wmDkY//TzVlzQWV48siDiW9cPxs/ua8XZB4ws3pgzniLDc5px4Nmx2Bs7989txf/55aK4ckzEBfndiGbEpIea8akrBuMnf9sVvE9SrHVwMH79y8H45LTF13bLtFZ8+Lz+OPHAEbFv+f5HR2F+Mz57RjNuKJ/JC/4jz7TiXy4ZiJHv74n9xnXOYGPWQHzxp804L+neN78VJ0wuayTa9VLfJeXDB8m0Lq1j9gkeJK+YVO6nbIuNc3rn2DtWXt8l5T32ytwlZf7dx7wXVZ53ITrIqvJig9s1IE7WwT7P1c+9uOpRZ9hB+qWnGY82yrMu45xH5lmfuYS9VB1XY0APHRoxignfMT20+F1SsNCKRqP8HiV2LGrF04hXbcQbyFU6M6yhfi55lT+XxCNx9/z2J/kR8ebl9o5n506MKUVJ3BY3PbVvbLrq6KEzQl10dS2KRx79Qfxg3uPtv4Fu/QzEguYDccczD8Tsxhpx2Korlvf0vNvjnEd/Enel79uFReuZeHzRdTFxxkBMWHGfWJvz25wVdzxyRvx8Ef/IMNOCmNV/e1z+1N1x14KPxGGrrxW96Wyo+fDcH8ZZTop+QUxfODFOfnh6fGTtvWPd3s55WkxtsUn7LmnOjDsefr5Y7ogrZt4Tdy84ND6+2prR1z77/U9fFz98onwTTciB5h/j5qf/6LTdc1ctndc4nvV8X+A0z6tjzzt87wjGtBd3l5T3jv7yXWkCqvGh86LukuVWjdX7Im6953cx+eFtY5+1RnbWtmBe+fpzlQnR/rcduh1aS349Uv5IdxFtIff7/NO3XB3XLojY+tMHxpajy/uTHJkTxq/0a5yhhbQH5M14q3kmx8Qqlee284ZNlqGT5+yFOYLv9yr3DX3GzebC6Ofq6BsfKy3D99GyVogl64JBg6ds2m9Pj6+dNj12P/rfij9Jdm8RaBmza8kxMYYvlvWKGWNjNLbsv7p2dMRhLC5jSFm5xnLP4TNHRq9eMWjLMg+fGWc4m4j+WMSnc7F+jB9T4osx9MO3lX3UHz2Ytoj14kPnnBUHFx8C3Bdnf+j4mFi8P9+Irhf4XEIeunr62u87lXvmaw/WkinPq2P3Bn5eN3N8ZDJ+9RZ/LnkF7hL2adE9cfNC3qfZLPZZdd0YtfhSF9tzY3ctnpO8rtK88yyYZdiz1lwfjDt3SaN4z4z/AcUPE1dzKJb5Mp6MCQ89bGnO6Z2j71j5S71LCgfpS8Z94XeJb8y/Qu+XtO6Pa89/LGL8++Jju63uz6e/5LukWP4fzozP/5/+9GcR+2P2vZfHacdOjcnrPxa33sn/9mnTgjkx5YpT4t/6xsc3P7B+jKicL945NY/NZvt9gMcujxM+dUZM5f8jt2n+fb+J/z7m2Rjx3SPj7St0bKwPMKivzvzpmHrd3TFVAHr+bcJNlxT/cuDJf/9qvHvt9FwyOD2uP/no+N5vO7H3z3wwJv/sjKEfNgFiCL85I6769hfitFvSH4cs/gTlyTH56hvj08d+JnaYsPgBc53gVMd/7i7Br74dO1+Sd4lr5Iws7fdeezzkbpzzfKhNFH/6xzE9AWKHLj/9ZjI4iOKgAx99G3Pk2OrXDanU5pC/rkX3x5lf/3Zct/LH4psHrFv8hoUnyQIGH99i4sM44PFrtz856dyY2rd5fGK3jcqD0C5aNtD46JkX63hiatzHrwX/7ebFn4gyzvkzH2QYI/p6Y2BgYfT19RX65GhwhZVj44i4+8nZ8WyjUTwcghkL7ouzv/Gd+N9VPhH/8T4OYjpE5VVcxA4uOTJProM18M/mzvveOcUaDt9zkxjZ/h6nPjo01w1/4KH7g4ee3t02L174sDYx6dkjfdLDww4yn+rQm2dkfjPBJ/Ns5xh940EPDHHRsXbEzYeJGNBHz1YElnKkbw8L+saJLr7BRo8e0pcxwlMODnzzYMwZCx34xErTtxj60Ib1godcHXOgjjEyV4+xBE8/xJfXmOd5H1wfuhA+4NHTiInfDqI3Rv3Ro8v6tJeHrTkQBwyIOLETE57+6KGldZfgUx+Fo/RFfo6TWLVhnON0f1xLtjOHwJMb9wUM8pVxmJtb9JhL6jlHtthdks5bY1x3nPR3zTj5lGacOLYrfnNwb0xo72cZT8SWawxGPNIqfutiiwYPdq249t6IjUdE3D27Fb+d0xXvWrGsw0em8a5AIzZbtSsaRU0046e/Kj/0OHCL7jjqLRHLd0f0z27FGZc241vTmnHa7f3Fb4cQNw8LxfsszYi+cY04Z/eR8VZ+dbi/GReePxifnVF+6LH7m7rji9t2xTrL9EZz1sI4+pzBOOv+Zty0Yyu2HVHe2TNvb8bR0yJ2fWNvHLtTT6zV1xWtwcGY88ii+NKFzfjslQOx83u7Y7miZqmhVsTCiIfHNuL0Xbtjp/ERLPfeyYOx922tOOOOiPe+g7uZXDdj0tXlhx67bNQdJ+zYHSv1tKK1qBn3392Mz/2mFXdH+aDM/rFX7id7S2O9ULVW4CHDhj2QrCVwrB96+J4lsdCxbohX32Logx4bawm5OvAYq1PuTzlXrxC2v8DTD3HlNeZ5Xhd8yPjxAY+eRmz1XbL49xpz4/6QL/JEg9gHc2hu3Rdk1IMY9Mzdf/TK+i6ghvTKWfnG+/PeJen7IPpgQ8bCnLFELMrzGliHMuTMxcj66NBcNzp5bciYI7dZZ8YhNrjmUx3rFz7NWMBlDoY49qzReNADQ1x0luxzCS9Syv9z0P5WXPhuzGvG+Vc046ddjThxp54Y0yjXZoysg9iIlf2Gbx6M2bWqA59c0nItIYfswWG99NjoxxxkXGSQesWk/QWefojPvUCc5+6DfHr3j5hcM2Nies3cJbPvipuGjtKbY+Pxm8fAgokxpf269d5n7oq58dZYPt0JTz/5k/ShR0+suexH4+BV14rRrUXx9OzL4pzin4aXeepqPBIX5w89ut4cB6z6rth4ZMTI1pPxm0fPiQsXRQzyvbDRiBlPnjP0oceyIw+II9bcIsb1RDwz88o4e9qV8XAMxOPzzo/Jz/xDbN/+/7vl7pcb3jfivfGJld8U43oa8eycS+OUmZOj+AilOTkmznhb/MNqE2Ldtf8tjp9xYXyp8s/Ntx7lOeTP0LZi+hNnD8WyXN/74rDVNytiWTDn6vjRE5eXscy/IG6c9/exw/Kcn4fi8mmdDz16ureOD6y6T2wwqhWNgTviZw/8LPzPjtSTHzJaZ9aYZ4gVWe/qWL/wadQ2RJ1bw+LYW7PqgSEuOkviLgHbcwa+ccJnPcRAjPQQvfEWjBd1l6wbB39hr7j1mIvj7H/5VFy0xa7x/j3eHlutPhC/+cF3YtJq74x/fvfGMaLBH2z7088lDz/IR3y9sfvm6xZ5IEbekL7/fv7U9fqxzsg/xIXfv6D9E7z8Q/S1Y8t3HBKH7rVhrNDoPHuRR9ec1+UeIHPd8Fg/7cXeJcSnPfk2p+DQIHWYE4t+9cn8Zb/GWTgjbvvFKXHmH3tjyyP2jk16S7/4xM9wJH/w3nPia9+5PsYfdkIc3P7fpP6Up2tDN9focOsbwluCr3GI27wV75fk1zipdtHTf46ZsVTW0vO8X7JwVky9+ofxvcsjVt/nkNh1lQZvcxemYIhyy2mfiYNPKxGpvS223bP4yem1R5Xn6fmeS0qLss6KT1hf6F3y6IPxB07EHlvFetRUez2uizWTH4j1Udd5n17IXYItdmIyL9bcfg0C3it3lzSi59lHyg/6R7wp1m1wY3T+eox7bG9t0LN+GjJzwH+5ZBcbXb2L5claKBLXzp1rZO3eHR05f/p48TvSfC2pu8S8E//LuUvAoQ4hsIiP9ZIj6wEZObJ23H/0bawv55UxsuFIvnjuhTbui9jujz66nngw7uRD2x2Wj2euPTe+NfHqmPwYb+6PjtU32z72PeR9scuafcW6xKBnna6DnLnuIsYF/TFiswPiCx/dKzZZuTcWPjM1rj/1uDj15vvi1jtHx8bvPjI+vvubYpXR3REzfxPf/8Ipcd3EG+LuAzaILflmVZyDcrVUkftd8Pky/cGYtul74shDdo0tV182umNhPPjrk+Ofz7w1/ufaB+Pt+61d5A8788OY1snP+nHImf8vPpheH7cWzY4/Xnl6HHvW7fE/10+J96yzYYHDHs3/3c/j1N/Oj96N9osvfvo9sclKPdHsXxjPPHVz/OyEk+LS9j/ARhefT111cvGhxzLbfiyO/cRusfYyzWgMTI87fvG9+MovborTfnZLbPWpt8Sodq3k/QMj75O1Ay78xXKd7hDXWGZu6dwlYLPf+CJmc0rMkHXnOSJWGnPitx7RdW+wsZbcH2RDf+oKIU0nCF0sYwB0DB+9zDMwwHnB4lwMnRsQetJg+9O25kB/lM/mZYGCD7UGpsVV3z4+Loy94/i/3zUm9LQvw/Y3DB5uxfdhA1tiHBh4Kq765j9G+X/Oe2ODPT8cxx21S7xxhfJSdQ3YGys9BdFozogrzjkn7u3bPA7fa5Po5gVl++E3XxVguAmsq7u3K4rfsZg3r/hVxiKXrOGkE+Ki2CuO+/TOMb79tzrxVVD7cnfN4IBZ5mtO/PqEz8R/FU/05RqO/qftYsNxFET5K67knDXQsAV3yO+PfxxTWMOem8SIRomLT3yhaw+vsEmHuAyuU0jkBRsaZB3gz9qBT+zuCXNwxaaHzDm6xABGHqMjLrrY+WKYMTbwIebKxVaHXpxCOT24aqdfdY0NO3GyrTkmBpty8mC89Ojqx3wxh+iRsy79KDMnxGAc5hgdeMYBlheAOOiiA6mLjD3MPGO0hgphOzZkEHa0TPiGwMaX68SGpv+8DmODx1hbc6gP5uYFHxkDbO2RGQdj9hFy3RlPPjwaONgatzx68J97l5R/2xMcbCF0R44s/2YlNjRk+LcVd0m6T9HRL7pgQOgjYw00dLIcPVp7R4dsXCtbvd7KEfFQK+6f0Yi3rNIVMb8/bp0dsc/bI7a9KuKGh5qx9/L8U+FG3MdvV6zRiDX5sJa4H2/GmXMjVlqrEV/epmvoJyxHjGvEp/aLeOTMZpx1z2B8erOuGD8USyti+UacedCIWItfQW51RbM3Yt8tmvHZy1ux+9/0xklvLWu8CHhMb+z/Bj74aMWshSOiq4/8D8SVd7Zi+hrdccpuI6K3ffehP3rV7vjHTZpxwR2tuGewK7btJec8+jYjxnTFWQf3xpoFcESrqxUbbdGMD93WijNnNWPmwECM5V6ZPhBnPh4xfu3u+O4ujRjdTb4b0d89GOutHbHGbyLubnTFyJHlb8aZZ84D5B6wN0X+K3cd+8QeaFffJeV9Rt4kcuPcPCmjJ4cQeazvkvJ78ityl7TvKfaG3Hfuks79RRw094n6Zg8hzojfT9g35saNjt9TwM/nRF/WAj24EPbo2sNDjg18a0U+ffW5BJ4+iAvSllhcj/7RZQyZC88xsjxGBx646GLnuhm7fvTE728VP3Yal93UjA1v6jz7Fg4j4oNbd8UuY8oYjQVb/TKGb2zquA5wXB8y+DZ95HjBQd/4kKHPHKJHzroYZxljfNiQm2PG8LGlh17fzyUDcc/cG9t/SiqiZ8RGsW70xODoDSLmlL/zEf2/izvnviW2Wdbnkplx+9wpnd/06N0nDllznVi+yG1fLDtmjzi01YoL+su8L5hxXfxmqKT6YvuVDojNly33rNlcI7ZZ94iI+68t/sRto//uuGZe+5V0bBh7rbZljOOHAFqtGD12h9hu9pVxXlGq0+O2Z2bHDsuPK97TK6ui2M5YacTqseKIsu6XXWHX2H3u5Ph5+0Oc6c/eH8/EhFiW+ijVh77yz839IAJmc9Fdcc28GW35hrHb+I1jxRHlPTNy+e1im5mXx8PtWG6fNzveNmrZaM2eHDcOrXVcbLfS3sWHHsTf6F22eLGvQ/6nCD/RSy1Ss/RQrlF58umrd4lnAx/WOXY0zhHY2otND3lePcdg5DE64qKL3fPdJehylpCLjb5nU5xC2L4P4KFD0y9j+MamjuvAnrX1bHBQnHBMTxx9zAUx9dZL47RbLy2h19grPv/F98WWy5W5BAd9/Zgv5jF9Upz1k/uid6uPx54blN8vyngXxOyiDO+Ln5x4oiEXffHTrj/9Sky+bs849tgPxPojX7m7ZLFA2nmAZ25dJ2umsVZkrIk+57K6L8zlgckYPPeTOfazr/lWfOaM8uO73o32io8fd1Tsst7yQ7XHPhoTfZHnNl7Bn3ZVfP2EiRH7HhtHvn2VaPg9s30g+VPX3d1l3fwlXuMQI2ugsX7y6BqsIXOJzLFrdm4+4YMDXoHzh3Pjfce1/6n4am+ND372P+Ltm42NLp4D0hnrPJ2CUBK1d+PEU+LGK26Iw0/4XOy84vM9l2jR+X5HDJLrec5dsuiJuOqsM+Pevi3iiD02KmLiPSXzwJqgnAexzAXrtFbyGDty4x2FzvPdJeJbe+4BNsgyDrjEB087/aprbOq4Dm3n989kGONGTIhRvZ0PLOARr/7p8aWfxe6SoeeS8gfuWs3yWRNdyJwQg3GYC+Ms1sFaCn3+73B5N2KLLnYQvXH4fCvPGMkdYwkfzo1fGT14EDj4Eh8bmv7zOsAxl/LRY0xDDjEGz/1UF19gZ13jwI59hNCDMp581wIOtsYNHx49+M+5S2Y+EQ8Acvnp8e8Ful/mx6N3/DpO+cKk+O0R34ijdlyh8E8MNPINpnPXVmRv40/EV7+4S0xox9w1cvXYafd3xKk3/yo2/ugx8S+7jB9aQ2PFbWP3d/DBx/SYOacZMb5yl/CDSG2fXV18KBoRG38iTvjnHWOcd0nX6Fhj+x1jhzNvjWsfnhHzWmtF70t5jTNibLxht/3inWfdHpc8/EjMjg1jXPFc8lRce8kN5Z97POrA2KT9YWuz0R1jV9sk1lmdD2PKvJV3yQNx7UX3RfS9Mz73yXfEOiOp01YMNlaIN733yDj8kSPipOuvilsOeUvsMHbJ3CXu8dK+S1gl+4E/98XasnKsP+TUhU05Z8N46XOtem7A7EEI6QBACAOdF4x0KJjjMJO6BsYDGjwdo+sYXxAY+isYxQNaBxt9fjJkynnfiFPu3iQ++Y1D4o2juSjbF3BXicOTeanbeZOqwCtB/UGHEuuqn8UvusbGx96/RfF33/Rv/NrxYcu1J/1rnHrz+Nj7S/8Q71yFJHY+VWqnabF/So5tmcd2XHaNgZjy0xPjv+55Uxzx1YNiQ/64IZ9ac7jbuSh+GjB9Y8kbSmxDauTjqp/F+bFcfOTAzWPlrjIXbrbxF/3g9Lju+0fHf90yPvY5+h/jHStzuXcuOPfcfTEH2beXcRlDeRlhR4Pgo2P+5SPLY7EzX556ztVhnmODT2zWrPrYqyvv/7d3HuB2VlXeX+eWFJJAAglFBEJVgtK7fUBUFGbsUmdUdEYdPwuOvYA6+o2Oio4F6yDgWEDlUxBFR0EFpAmJFCkSEGkJJUAg5ZbzPb/9vr97Vl5uKJpQ3/U8++691/qvstde7z7vOeeec8BCzuldF2N17FkD49zgQejBJ5asy1g5PXMbuuq5N+ZIDDbVK4P6jzG49oxRR7xzbDLGp/bV1162IybbkadN9GnaFmuf7cJzX8aLQ9tZ1zExZxKr/wdzlqjrGrSNLSjHbK7kWcfqum85NsbZB2NtM85y9eQr0y56+KIXo2+wjI1fW5RMfazIGlsTNmZu2Indz+vGJQtGI9bvj7v+1I3j+zrxnc07cddlo/G6q0fi3dsOxIx7RuKSxRH7bdOJSbXBBQv45EPEazfrL296jDlgMKUTe0yPOOHWiOs7nVivXHM1oi9ich2ra+pOi9iDNdRPsECSX2LccO2I+FM58arYl0SJJRaPxFafu3sFt71JNxbyb6Uz6vwjqP0SPnZpnTU65aYolkQsrffjrhu7cXpZF2/mVNiizlnSN8r/fRQ3Rb89S6o8tmdJr6bqc9pr0eud69Pr9dF5ltz78cc1cS14LnldeB6ZB/h5LI6LybFnXbnAxvmT/SF2jt2xs2TsyUl1owvOs0Q/9uhLnufZrmMx6NEyX562nIthnmODT7w+/olHX2ztovgZ78/x547E8ReMxhdeOhDPndG7P2EN5sQenj7huU/6w6dyeuOhR5dYwbo36GccMudlUP+BT3PtGaOOeOf4ZIxP41AffsapC05Crp5Y9GnaFmuf7cJzX+A349B21nUMNpNY/T+g+5LRq+KP5Ss+sDQQW0/Zqnx91MS1d4pt77iy/nTCn+N3ixbE7lP5r4WIviXz49Jqi8t8o8lbxhTWXO8L65kyc784oN7bvyy9rPcmSWwbW06v9pw4oW5Mj902f1F1zSz+c/0VW0iuiO/Nf198r6Du/efG5bfGyMiaxcIK0jqPFW9yzBicFNX38fBKyi3B/1NM5VpeQYlJ/Rhd73vfPdeVT9NXsCvi+9cdEd+/l07FuHHo9ujvXyvmL7k0rXXL2IzwarI+8tw9JxeM3UP21v3lmpAvhp4GIQNjPrNMjDiwkPxsdzwM8hwbGOKyZpv6OdbiqI5PnOtiTgy5R9fY7eHpEx6xqHPzbz4b7zl6bmz4D++KzzyjPy4/8/T45c/Piiv+8pP45McWx1v/7TWx27r3cZYsOCs+88GvxoVr7xtHvuGZMat/xeu6KpBZsc9hb4kX7r5xzJxQ1evwgnn1D6KfGsefuVccudesEqNxsUbGNHPnegDCt3fMHIx6jCH085oLM/3JdmG7L/CbcWhbdX0wB5tJrP5XPEt6yKHLfx7fOSlirYMPiO3X7a0bfe1rG1vlWyX+42tx8ZzXxVGv2rJ8I8RIja2XHLwByWsZEOvRTs9r7zEDGb6K7fvILRiJsXbRwwZ9xohFZvyZxzjjweVYkNHkY0M7WS9uOC9+8KOB6J9yUDx3iyljOiW+Jx1QfuTYtXVGh+OeW66Mk7/y6Tjpirnx3z/9Yzzt4CeVsLIf11TF23t8Y56vT+NVN0YWxm+++IH40gW8pvTmePZMctY7Z8BJro+5fHnNuRjkOTbm5MSazfpi5TX9qos+Y3zm/sGeJUMjvR98yvukf+zBx0+unYir4+TLj4lzDDD3dx0VH0pfSVREk18dH95o0xIr886S8+Jr159SflskqzL+yy0fjHN8370WbjTtLfGGjdZbIeeIjFMb5sOcwCf3tMwTT48OTXJf4JlndLXBeDwyf8rAqYfuimdJ75zL/rM/dI1L29iBxtORx56BU9d9M66xFy23fUm876Bnx5PWnx6D/K7n8J1xzS+/Gh84dm5c+M1T4uLdDo45A7215nUzruz2Vw8XE4L/1g/ONOOL6bPKt/FM6J8wdgYYw7obbudwrDdeP/GBjzGfEyImNs6SvqkzeNkh4p7FsazbHfvKLHSwda91gx25J66fd1acOffSuGj+LRGLbohrbqv/O6S+5sn16OJr40q+UmivbWObidjrnWMjI9TSWNhVXd15Y1xJze69XWw10LwvWSOesv12EefOjWtu7sTT+fHnRu26dtfcnIOHh9y9NTfEa81mfbHyKq+9awY+ujTG2rf3LNE3fHgQOsyJJesyVk7P3Lbys6SHG8AoRE/DEWThY0ynBi6+AOs/OqXHDhcf7yZqN9s0efrqr9/A4Hcy/E8EfUZcE+eefENE3BBfevOB8aXstB7zUcVXfiVi+9d9Lt63V/UDfuhXvmfEXu86Lp7DnAvuV1+LDx77qTj8tjfHl9+8W/kaKn0Ze/mkB28YzJsVL37ve+Jl9UdFjbespS7I6r+YegdayeHykVgEaI2p5SLqdK6Oc0+p1vDltx4SXx5nDRd97a1x4Ncitn/9f8W7n1VVLHmq8rpm7PWu4+Pv2Nzli2L+L78WHzruqHjnojfHF9+wU/Bp9B62yv/o0M1xxtFHxFfmzYp/eM+74oDBb2SLAAAgAElEQVQn937nAyxxQu4PPb4getYKz8OtCOo/6jDNuVMHvnvMONtVlx5diLEY5vC1BT9jc+zI/M8D/WgHG+jJp9dmYaa1i8ly7GQbyJjDZ5xJPjKa64HPdUDMjGn6omeOLXQg9cokyeG7Fn1nX/DIg/a1rR311QWnzyYGvjExZv9zzo0RmTFpS/vZH76MC5y+9YF/7RgLOBuyB3OWqEePLn70qS9kUvYN3wMXPu+ww0OfuVjn2mBuvetL/+h4EIMXa67kaTP7YSyuZ68XO7rG5Do763Zi975uHPWXkTjiqZ24+NpuzNq0P3Ye7I87thiK+G03LlraF8+6eSh+GhFve0Jf+a+XEndVnjF9Mh8d7NVyFZurLU7HJtUVVk2Nnb47MaJ6yeTeZ8nYCso+dKKzfOyfGsbsrmxAHqDytzaEP2KEuOTH7Nf5Xlb9s3WsNZE9rPYAbFXX9aLr/37J+daXe1P81v7BmfvKb68+0Mty5tmGeyUOfQkcfFvJZa3fniXtWbJqz5LePQD1Zz1bn7n2lIHjurE+GVuzyKjRPM9YbHgdaLtp1zm9DV8QvdcVecBWJvHywGQdbSvPdtWl1y5jMejA1z/8jK3Okt79xr3vSyqv++zcF5/fqfckAG7fUDd+99uReOvl3XjTqcPxq4MGYuN076JPsPg1h0U3Pb6BywQOvM31wH+kniWu0XUQs3GzPtfC3uaci0HOONsxL9piTg5o4syVPuBrp4Dq3Osf2QO5LxlddNnYVy9FzIltpk+onuMMPrl8FdW8ZZX1hfdcEQu661Zv2rMGnfLTL4NT7vu+JL0VEAOzqifp6V4DU66vOzI09umT5GIlw+p+qNPhnwN6xAsG5pR8rDnAC9PX9QDmLivVUuIYy+vI8IOIpX68zmvtnxk8U8Je3vdeIFUAyG3gIHrWAP/+zpKx3CUd9DJlu/qiRxdiLIY5fP3Dz9hc18jyWeKZpg30IG1rszBrvxmT5ejk/UDmWvsW/jI+f/T5MbTX2+P9L51Tnseu/5InxzP3f00smPvt+ORn/jeO+uTM+PeP7R9bTBznOc5Np8dnjvxGXLT2fvH+9728fGqDmJp5iNggZm+7caxX/tO1WsvEDXaI17zhZXHRB06MK+deFXfsvW7MeBw9x5nxrMPj28/ulK87WfTnX8fXPn5c/Md7F8Xhn31j7Dqt2mv2jkY+877FtedF9XLJV+NNB33VMkj93Pjym3kNYtt4/WcPj+eu99A/x7EO7Ikfcj3Wa7N3ndZQrl30x+41tnpVfPd/Dir2+Hrz4z/1qfjmR66Nez76sfiHjavrfwybrr1O/2BMWX+bePlbXhs3vOnoOPeMS+Kag58Um6/k9ZIS9AM9S/he/i9+IL48l9dj3h0vr19TYi2uM9tr5gMM64Vcv3j45Ea+9uDf11liDWEn5xI+pE39YFfbYLKcebbhXombOuEJ5THi9uW3xPLR9aL/wdyXGMAD6ev9NE5+e+XBkutkDRDrMifaEuP66Gmr674Ev67J3lj0TY/sgdyXuLambt43fYKRsm/4rFfcyl4viY22iadsWL8KTz77p8Wmz39T/Mvlr4//Ouf0uOSag2LrzavYsY9N47OG+USGOwlvJL0m05k0WO4DIr1pYC6qeCvbxjlmKN1blj0GUC81nw+8Jl3YdR7u9znOgrPiqCO+HOc135QrmWIjqwGxdZbdE+WXPSZNKT/fQNysvcoDNVUFBZ9hZ2R5pT5pavkGIt4AyjrNekdWLKTrAtusF2Ishjl8/cPP2NV9lpSA6vOUOPAN5Zq0LsSWfXswZ4l7uGzZsvICH5uZE8AicwHiSJ4JITACYc7HnJD7MSUDzsEbLDrY1o6bxZyP7aBj6+ur3+lT+b76bvVRL+xAxkZf4powM2bvc0Ac9Ju5cczZF8Qlh+0efOcsZKI7Sy6LEz726fjhzZvEK973nviH2VVe8sd8uBGdss4m/FpwDA8R74ovXvfdsbD8sM3g+jNizZLHseup+LrPP6PVd7cSMzkgp9BYvgbXis2ef2Accubc+MbZ58elr96lfESe+MCWNd99SXzvo/8ZJ9VreOnmE8f0saVN1kxzjj/04UGMbeSUGMQiB68NxsizLvOsX4zWf9wjfYJ1TH4hfFGX1BaELXjKCzPdMCHHBrZzAwcfwo8yY4OPH3VdA3PG6EyYwBPW6g0j59hh3IzHOO2zPXQk7OsTvnPk4rANX9/wlWUdxtQAWNYCnqYtbYAjZsj1G19h1r7BwUdPLGN4yGh+tFGb9Fxn+SzBB4RPx8yJDR462KUh1y7yv+osSWdLtq1910BekeOHPsfHnHWST8aQsdEbF3JwzCGx5k2fypSjhx3k7q/1Z37RaeqjMzJSXRvKwTsu9vv6YscNR8s7CdcuHY4z/xKx/7MqX2tv0Rev/O1InHnNSGx6ZzcW9nViq/W4xt1j+m7cfg/rrs+SdC0VR3zJFDVvXirvVb4aZ0k59epcErutv3zHK+sjLpIb5UfOY/O+uHyv3jXh+qt1Uz+VTrc74r1D8W5eK3y1FgDs7ShvCNaxLu/yIm31XxfYRD7c9b8wqtVhS7/0zHMDBR+yfpG7NvjuJfy8P4zRac+Sqh6tdfLUniUPx1lSnb/WdK5V9kQ+Y+o2XxdcO5DXQJYVQX2dcNaB5frAjg0814n66GiTOGjOtW18XmvaxIZY7ICHwDNGzlg95o5dZ1FIZ7g+wTr2cR5fxP6g7kvK1+t1g3/uwZ5+GfNvubv9XTfe9peReO9d3bj0zk7MXrt63Hw8niXsBfvjfue9IW/uqzhyCM/aeuScJXfERXfNNfyImBffme8vUCQ2w5HT44JFT4/nThsuv23Vu0uMuH1kWXQ6k8r6WOe97kuC36Co7wtG7iy/t7HWSu9L+NyJ6G3jVZu9LLbu791Tknfyad0z7nSqaz1HDA4i53cMpTc9OgPlPyLL3uVFFDTXZTpLOjmW7eJVm720xFL5rO4Dip26Hqp1pyi6S2OIc2rsLKm+wkSEdYENzwd4ubYY21gL6xaLnWyDMXLsqcPcMfqZnOvTnIL/a84SbKOLPWznZqz0+FFmbPAfzFly2x/nlk8G7bDF5uUFGeONTn/M3P4l8Yo9/jc+c/YFcfVtL40nb1S9+W0Md19yQnzk0z+K6zd+aRz5b/vHZmtwn1vFS+w0qPpWs6EYXc7XHjWe46y5ZvBS6YKR6rmfa6YGGLMW9sm9Yr3wmTMmB5Drt44Ks65bcPCNB6xk/h7es2RirL35c+PQV/0mLjzmrPjdxYfGLrtPKWvKe0z8tr7yOOMq7rtn7fc6S+p72dX5HIeoyC9E3OYdHmPXpty9A5v1GIPVBr31oI3B9baLQw7eO077xC/ijHnXxUtmb1LwrBss/rBjw8bAjPWifMZo6bLC1yZx0JzXCyg8noVhy2ZsBXvPpfHdj/5n/PDm2fGK974r9t+kd++EPXWI2TH6mZy71rxur018Pej7kofgLCHWCdM2ia1uOSeuWH5pXLbkSbF19ZS5LJE1E7v9ivu9WbxwyyPjhXUywAwPXxk/+dOxcdO0t8brNli77Cdi/KBLPrBHrrpr7BqHbblL0SaHJb9Lzoujr/txrD/j/fGC6b2zpHZR9txach+RFd2H6b4E/2U9j6bXSzoD5bFjqFu9RsI1x/5Ur5cMxLrlIhuK5cNcPdUZRo4h8m7No9fXV73OEfV57WMZ9vKlkvUZa8P8ldryh8zTGcSwXHHd6j7S/UePb8nxaiw1UD9+aXPFs+TuOPdE3vSofpLgVXvtGJus0RcDkyfHYP9V8T+HfjRO4TUUzl7OEoxA9de2lfhSrVXpqNbBVxRGf/0P7EvvjuW8ftV4juNrHX7NZzMHuDInrBH5I+UsKWlIr2eRi3J2rIbXXgd4EYZE4IAklIsrPWk0cWLowdAg9OCJc+OaOPjwIPEubGjEF+/Y4OqFfw/CbneLOOhbx5UfiimxpQep7uXfjgM/cmpsf9hn4/Cn17/Clw4I/ekTf/xozN31O3F8WoOQsIu/5df9Ir7w8ePivGl7x7998uDYYXpvndhCHyxrXX/DLWMwro1fXXRFHLBN9UPpyGjzLz+vrHO3jTesX4zePA751nFxaHrgLgBiveLb8cojfxI7vP7z8c5nrllygy8bPvFHfBD5Hl62JBbfqYWq5yAAu+San62whu34QcD6BV41XEv24RhfNAh7kOtiDC4TceEbPm+i5TjRp6EvnzH2rTdsgdE/cg5G5/Tw8tz45BkXc/zQS1mXMWTP2JsGbMqnh8+64BMfvXaZI4eHP+JlPfBdi3NjVBfb8ozFvRNTgqzjxL5xybfXF3pgjBc58cEzbnpjQm4cxoycBmkX3/LQxY83xGAyFpy5B8scH9rKsWBHe/BpkDx0wejD9YnTJjrIwMNDn2bczbk2sWPNwoNyvPqFDxaMOH2CMY4m3jzojx47xi+fuX6zXbH06iLnAZZUzeJ7JLqdWFLbRUYMlb3+2GqD4fIPmHMvjThxtBOf2qySj06K2H1GxNuuHo2dUXpiJ7YaHY6R6tstY9a6EdtExI/nR7x9625MqN+ALHEsHomz+BjbzIhNuObRLy+2UAfVXvHfB+akyxNd8ldwlX+GJcay38jJa5TfCNlmYsSP/hJxcWdC7DBwf2dJbbRT7Rs/gk4eodHRkfoGpoqFel1v1mjMitH41Z+H4i2b9vaT3Pptiegyt2fsPhZmoxZYB2TPuD1LqmuCvejtR3W2e02SJ6/z9iypao5rxuuGXqK2rEHqUQx8604+8wd/llR20MOONvGjPWJB1mxg0CM+iD31MZG5tnxs89qAjy3wjNXXj2sEk8f4okHwIfT1A75J3ts+Iu5L0tnikzxzWtYwGnFXee26ExMHH79nCXvo3ltjed+RPWrOkuVXxrwV31dvlmiaL43z77wuXjBj4+hO2zKe1BdxXX0UzF8yP5Z0nxwT8tmw+Ddx4t1PiZetv3ZsNGlOxJL6DZXuH+NPd+wVT5haXT+Vg6Vx2bW/iIkb7xuzp20WW996XvyhCC6NS29fEnNm8TOYvbxTj8tvPzVOGnpaHLABv/HRe+JfgCvclyyMa+pPrSAbmDg71vcsmTgjNoiIG4sSj9W8UJ3OkqmbxpyF59SfiLkkLrtj/3jqupPudZYsu+0ncdLw0+OA9afHrAkbRSyt32gZvS5uWhYxc4JniT9dXDms6qjy97ecJdSb94sP51nCqjhHiYe1SexX2SPzns5fdei5jjwv6bHlcwavNe362tD1t1ZfMbbic5yhWFx/I+lI+a0G93R5XP+LL8WHjjk/pu/z9jjqgG1jen/vuYl7UMW9ZmzylE0ifn9ZnH/54thr/d5/BCMfuuHPcQmDDdaJadzX12szXkTEzzpYF3HT87iCH8i8MHd993eWoGeetEOvfXOPn4xDnmNhDkY+Mkgeusj00cTpE53ld/e+/hV9mmdgc97d6sD4zrcOKLG4fmzTrvj2ofGhU7aL1x31tnjmdHJU1VDGlSDTWWAcxokcvHlwDc345YM1T+jCl5Dpmx6qnuOs2vuSJXfdXmznU+w+70tuvKb6OsA5T4x1+IfIxr1IlZPhKnvpTDZHrguny6/7eXz+34+Nc6ftHe/61D/GjjN6a16dZwm+yTWN/Od5HruPBZCuGfTcE3sw3sflPUV+n2cJr5cMbBJzBiOuGJoXpy7cJbbceHZ5PLO+qGPHxo0/bDfnAwP+M3S1vhw768nxKqMfs1/vWV/fQAwOVrlZHWcJca+q5zjE7564PnIG78GcJeLJRfPsaM7BgsOfj3/wIPcfOU1aYb822SKeExGnnXdhXPZKftS+Okcr/MKY/0e05sQTZ7Fn1V4iwwd2XKdxFM+eJ+mM8jUGXhxRF8ucJZ42nfoxs9iszxrwvWvDmqrvg+q1I+/v76tfIYng8Y7fQ4WMb8Wz5Lq48uyI2PqQeOOrnh4b1P9QXRT4PeYyqPJaXi+Ztl5sPCniwvOuiKte8eTYrK5Hc+raeNOj5H6tJ8SWsyIu/O1FcdmB28eOk/Nrr8vikrn8o812scksXqNsX3slZyVvjbOkTwG9RcfemPhqw6pi8EJzw8HAo5cnfrxeX+BpBuRjITYsRGPgQNKvNtWzKOCrW8muipM+fHScctY1seDu5cUP/GW3zI9ffePLcQLfkbbbdjFnUi+GRed/I9733uPikjmHxn9++NCxNz3Q05/+iXHwybvEc/hq29OOjW/PvTVGun3Bd0Qu+P2x8bkTFkZMenbs9tQ1ior6xKg9e23mNWC/270yTjqyWsPNd1f/9YIOP77162O+Et8ra9g+tpncu3nKa/jUR/5xbA3ZB+McjzHp3x6Me+tegYWYuyfEKt+bsQJKB4P68LHLHFJPeTMu7WS7YHLL9aJ99ZRlvOPsX7w89ZybI3Wbc3DqgEHOnD6vTZn+tEPvWBl9E5/zhkwMfHOEHXzrX3s5DjASdrItx+PZUYauNuy1Y68/elomMNaP+mCsN3lZpznOfvQFRl/YcE/k3+dZUl+bYNXFh6Q/++wTXp5nG9iyqatNemNE5ty9G88usEn8t8wd3fjZ/OrGJ9vF16z1+mJOdONrF3Vj4Qadse/P7HY7sfuWfOJ4JD52XcTz1u+LyXWdotfdsC8Onhax8M8j8Z6zRuPOkSq+oUWj8aUfd+PEiDhk6/7qv6HyIuqcFRv1OnolVp157m3JU9HNZ0nE87aOiGWj8S/fWRan3zwSw53qTbfOcDf+Mn84jj5xtPz+SJXn2nl3xf2GyycGM5XcP7EvXtEXccnlI/Hf19Z1MdqNO25aHl89dTTqn+wc2wv13RPmeZ/Mtz1y/DQJnnpizJG6zTk4dcBog94ay7r61A69Y2X02pKHLShjwcBvz5KqhnKO3BNyBv+xcZZU67QGrCt6a8Oe9dOUiUUuD3muP/NXjNV1nTHy7bWTbSBjbg9mhbMkPUHHn48r4ulzPWc+eH3SG6/+lIsxLmxA2mUMJjfWmalOaWEpE7900XD86OSR+DgvIE+PeMqU9iwxNzm3jNkD8mcdKS+JbdSKMm3Ru6f07re6yK2fXAPWmzzx4/X6wvatt50fV48HWglv6ZKL48/l0psVO665Vf3PBRHDy06M7950XdzdrdZ+16Iz45ib/7d8nS7++tfeJZ42Vm4L49cL/1/84Z7qE62jQ7fG3Gu/GCfUb050BufE7mvwnxPQcMy7/Zg4+ZYFMVT/9l8suzHm/eXo+MSt5wT/H4Z9KFfk8Gj1n5vd4bviuut/GGeM3d5Njd2nb9P7GpOO/yCBheti7h0LV9i/bv+TY9cUy9xbvx4/Wrgg+AfQsr/Lboo/XF/HUn6oPGLqWjvGpiUi/lwZP1vwh1jU5fsth+P2Wy65V769ZsfW8VecJbnWvOatBXvriqjwZW015TkOZehoV31wNvxn0gY8ZWJzjzz70AY89cTAy7rTN906+F3VBSd+MY4+/ZpYNFT7WrowLvn+f8UxvM/2hF3iSet7X7Iozv3KB+Idx1wa27zmE/GxQ7aL6Xyfe22X3rFxbLjds4Lb0YuO+1Qc//uFMTRSPbbeM/+MOOa4X8RQzIp9d9piLJ/mCDvET2MsuQesI/NdF7g8Xpkd7WnDXl17/dG73+qCeTBnyZUnfSQ+f8rZcc3N95Q8lFiXLIr5Z3y9ej0hdo7tt67eoNTXld85NA7+x1fHQd/hS+IfwH2JwaVzlDgl12Xv+pDDy3N45o/epq426a01ZJJ7N55dcdjUnj368O2tg9t/+6X4xHfOiItvWBTLhys/3eV3x4KLT4xP/vcFETErnvPU2WPriLiqvL7yk7OvjVuW1m9ijQ7HHdf8Jr78mW/GFRGxwzN2GPsRZf0ZUwmg/iPPxwnzdMf5X4/3vPvYuHjrQ+ITHzootl+repHa+HM9a59efcbmZzx5zpM2wWFXMm/27kWWO1YmNvdgsg914KknBl7WreZTYsd1XxgbRcRdS74e//Gnn8W8uxbHUP0NL32d0Vi2/Ja49qafx3FX/jSurs+/7FO79FRAr5qqaPCZ8eTRmJBB9PxXPPrVNw6svrNEn8aQe2S5uef0xl0CrmM2dtcHxnqTJ368Xl/aNzZ9YSPvI/y/+TnOwNax6z6DEQt/Eh//4mkx/06vywXxhxO+GMdxbG23Z2w/84GfJeU/P1NOiNlvrOC/KInbtVU5q7LB+sxBlps7+nKq1LhKN702VifVT2xrz/zV4ujrmxhT+STL/Avi0ut7384xdNsNceEPT4hfamfs8XDj2OYZgxG3/DiO+clVcc9oFefS266L3//gC3HcRZWCcY6ObhR77LtFxNJfxKe+8Iu4ZnF1FvaP3haX/eDT8eVzIgb3eGZ57RfNnA/Wbbw9e1W+zEnJQ3pM9YzCVs4f41wvyqtoVzzzm3pg9C/ePts0lqwPL8/RUwc+cub0rl08PGmA4uYdK4GVYvXuEgpcXCowzocqc0g5DtGBwOkYuU3ebad/Kv716yt+7PvkDx8SJxftF8SHjz8gtqj9Y9cNw6cLLdD6D/7wgZwY7r7qd3HCVb+Lb2WQ40nbxutftUdM7o5Wh2CnEzdfeUZcj/ycY+Md5xwrcsX+hR+I7xy4VfEzOrB1vPiftotfHT03Tvv0O+K0FZCDsf2h+8Wua1Asvf9CIT7XwRjyhTr+GwGZm4b87qvOjlOuOnsla9g+/vmAPWNydySG65wsvKq3hsNXtoZ93x/fetUWxY++ckzkzjgzX2wVc3WxkHP3G6x1BEY8+4FMu/TUnLrq06vDWD6xmCv59MaW34lWB//oYM8aNW56SJvNXpn1i5ymHcaukxhcH74gYhDDnHedkRkbsjyXDxZ72tFW5uFL38gl/ZV3uOv/Msg+wJFzCGz2yTzvBTLm8CH8w8MePOZZBhYitvHOEnRtYNRlrK769Mpz/OCMA7lNnrbA4QtCn4Ys+4eHHoSMueTasIMPdZXTa4veWDMfHnaa+2Ss9PgEZw8Pco5t8YyVIedjl9vzLXu3d+Pjpw7Hx4s0Yp9d+uOL5WMcPCHtxPP6Ij6zLOKQLfpjLX4Qvd7PWZv0xbPPHS0/9v3GjfgPzCqf+OMHD1/8vE6c9YNu/HjeSPx4xeM5njirL167TVXLYzEW/1UNDebzbWCo+tHw+sfEXWPJT70mVF3nE3cbiC/dMBxvWDAarzlx7JWUenV0fbEHeVvhxqY6S6Led3NVZaxX692BgTh015H43u+68bFTl8fHklX+lYP7lIXpEx7Y0RZQ94p6kFyP8vF6edYvdmjaYWydYA8+PfsMEYMY5u1Z0p4l1IHXjLVCjXh2wIOcU0PirWlkNOsNffUY66MM6jrUHnIx4qxTMdiiYV8e1wANyv7QNUZk4NXJMelD29oRyxwZOP1o12uMuXjXrl361XtfUu3LaeeNxObn9c4R4h6j/ogv7DNQzqNuvQ8514wfD2eJe8JaGduYmw/32v1knmXWAPv88NyXLIiL7+59BdTApEPjQ5tsWeqP/SYuaOiWE+Pjt82rvqiqe06cvXDv2GBGJ6au+7I4eNmX4vglt8dwDMf8xV+PTy0eq5Qy4EWkQp2NYp/1Xxg33nhKXN2NGB69MH5wI00Aff38YmAgNtnon+Pl878cJyzH4I1x7m2fj3Nvy1jH6d5DFhqLPx8f5JXBFWggNpp2WDx/OtdRVeudyXNi18GfxXVD1b3ndXd9Lj5weaW028yPxL4zOrHxhq+Ll1771fh+ieWGOOeWz97rB2fR6NZfAdyZtGO8eM3fx+fuvK7kbPGy78dnrx7/J9Gr66V334odeNbXAz1LwEPgH86zhBiod4m1MLeWjDHLGXtd2Mu7z7Nk9j7x5ldeEB/47lXxq6+8P371Fa3W/aQt4oB/3a/8vkd1X3JLXPFrfscy4txvvDPO/UYDX09f8N6vxyFb12tYb+9442EXxTu/Ni9O+fThccoKKoMx++//OV62VfWdOMRO7lf3cxxCeDjOkr5lV8WZ378qzvz2CkmoJ4Ox3WtfEU+bxv6n5zi+jlN/1TZ1Si1QE6wBct6zWtWyZyly61sMc1uumczL14J68MDQey7bGw9zyBi1KQ8+MYHHt3rG4Rw8utrvjC6Ji075Rly0YhEVX/zZcL83xX6bdaI74n3JyH2+vjK442HxT3tOK48dvdj+FMcfeGT8eMwq3174jfiXg6pi3/6wo+Idz1irxE1cN195evWa0rnHxTvPPS5r9cb7HRHfPaB6PYY1unbWxpz+r70vIQbza964huTRS/gy9/LUYW7+m72y+zxLfH1xjV3jwJm3xbG3nB03Dv82vn/Tb3XV6HeLPWuOcRlr1ddx12+Gq4yMmFkHRC49r8XQc9nQKnz1qQxzJY6cF+wj5PUSYjEHjFmb8dHn+N0L8OTPRm7goQuGpk30acjgiYNnHSBjLsHHNnbo1VUeMRhzXv7ueNHFH4mTzzk23t98TXLaTvGmf3pGrMmerfDJiN69vPtZ1lAM916/Ihb4Xb+2od5/YMho1foqHdfhscnXQcmrvhoKzV6+XAev0VYVV621vz6X0DUn5qG/f/PY+xXbxw++cFF89b2vixV+ZWnaGlH9K3x+vaQ/tt3/sNjhN1+KC0/4aLz2BL3SD8bgpIhYWu0HHHyu88zXxev/8P74ygXHxDtfd0xWiJi2S7z5lbvGmgOr9iyxJujN2cN6lvyNr5cMELwFxOa5KIoZmd9xyZimHCxzqCquXv7BcHBoF4lj9Iru/X0XJQdxp1O+D92kU2SQNjq1jU5/9X2f+KxkW8UBR30onnj6aXHmhZfGFdfeEXzifI0nzIntd3lm7PfCPWPzafzGQO8Cu9fbx73l9Eb1gQCD/KzzrHfGF2b+JL55wslx7uX4GIzpT9ol9nvJQbHvNr0HTeInLvW8ILmJi/o/lLsjfM9p9YYA8r6+reIVn/lAPOH0n8dZF102toYprPh5M5UAACAASURBVGHXZ8aL9t0zZq/BBVE9YBUfvUhXPqq/Sox43Ddjc26e3TP5zI0RHeaQcnjWBzzkHoqM4Yl1bM9HAsVQc9k2NsTBxw9NnnLitga0RXyO87rgMyde5Njwo6fGDEZf4sBC+mYMDxzXA7pgafCMzRhYGzjnroN+4sSJJX50IXKiHfCM9SsG+/m6RE+dYqReg/rmADvw0FcG3njyGB3XAt8Y4KGLf3jknjl8mnGIWV1nCXliHfiE8Gt+jIXerz4hVvOQ5fC1Yx0pR8a4SawNHf2C0754c0IviWOufraBLusCx1qIB2L+xF3748Rlo/HvV3TjwpGIWYMRm0/urYkH8SevGxE3Rew+mz2q9gLdzsxOvGBqxOn39JWPTLq32MZn3zr98Z+vGImdzujG8TdHXDUasdGkTrx8p/44aJtOTOP3NTrV4wAvcFSVWq2ZmwPX7D119XWCvRcziaGi8o7IWL7JzfNf1h9nXDYUX71wNM5YVP1cKmt79gZ98YJdB2Ln/r4YLTWH18qzOcFu1aL63sz6h848S9befiBOmjwcnz27G99bStIjXrFlf7x922588Huj8ZeJVW7ZC+yQF2uA2IzbsfXjnjJnn5hjoz1L2rOEOuB6sI4Y06glr5P6YiidtcOEWqrquapF8WAYW3e5/hk/2LNEu+hhE5/lvqRE1DvrlYMxNnT1R/3TtGeM2DNWrkXx8LHjY1fOETJIW87zNYdMPvbRx7Z+0VcOz5jhg89YcGId26+y+5LGJ9HKAus/m69RndOv3ak/Npry+L4vcd/YH2sNXt5vx9Zbrin2zRp4WO9LFl8W54+9vzUQO03dstQgdeh6iHPCjG1izm3z6q97Go5LF/8x9p+xdUzsTI4tNjk83nPXvDjrlvPi98uvi9u71T3AQN8Gsdnkp8Xz15kZfX31WTJt93j1lCfFn276XZx5z7yYP7K4/tWPSTFjcE7sseYeMbt+XOt01oynbPJvsdGi8+KcOy6IS4cWjtmOztSYMbBZ7DztGbHTzJn8TwHZX+Hp0YyJT4/NRi+KuUP4GIhJ/ZvGLmvuG3vPnFHW5t51u2vFUzZ4bQwtOC1+uWx+LK4f+gc6M2JSX3UujI5Oj6du/I7Y+I7z4rw7L4xLli+4Vyw7Ttkzdlh77XKNUhMzNnh9/HPfD+PUO+fF1aPkZCCmDm4bz11n87j2phPi9yWK3tllvum9zh+NZ4nr8KwkF67HcV4XeObUHHL25YHfl/THpn9/RBy15S/jlFP/N8665NpYtDRicO3ZscOe+8aL9989Npta+ccuR/a9746JYEXqH5wY3e5wiQnJE/7unfG5J54WP/z+L+LMP9wQd/Mcequd44UvPiCev3X1ySTs+zihNdbE9SN5zcM3B+TGddPna8+8occYHe3Jg6/d1X2WzP77T8QR6/8mfv67eXHJVVWuY9oTYpttd4rn7PvCePrsKWOPWay5rLN3C1ziJNb7eo5TPf3olBcZ+Ycn6wg910zfJHOoX/LSzBkYdOklcczZw0zu38qe4xgHetjE1n3dl6z9jDfGJ6f9Nk4749dx6RXXxvV8XG3S9Jj9lJ3j2XvtH8976nQu/uAfCip7m8dLPnF4rHfaGfHLSy6Na27kJ4YHY/om28We++4XL9tz85gUIzE05GtK1Mm9P2WQ18SPK1fXQnXQ+XrsCpjmJL2QSFzom8ecP8f293dfghtyjE3s0dQ1RmreGjDH6Dn2OmIOMdcmNh74WdI7iyettU+8ceouMe/WM+KCuy+PP48urR6nyuPO5rHdGjvFjjM3jRl9lc74r5eUcKKvv/qafmKCyIl1RcyMXbMY4uarsjKpI8/8wzcH2MEm+toGb17zGB34YCFj0O5fc5Zgx33ADja0XQb1H2JmT8GCgxwzp5EnYlOODg0SQ39fZwly1qUd60h9ZIxjja3i4I98Oub85H/ie7+aG9fcNhQxbcPY9Zn7x9/vt1t5DZM3FsxZjtf1wis5LBFWZ4k7SNxdPjWErL/3GjXxNMm9G3ujpP5nimp/RsZey8Bv9bpFtYYVvuqK5zl1XllfwTae40zb8//E/x36nzj6xDPiytuGYnDtLWPXfV4Sr9y7L0497ONxavmK7+rNlJKjdZ4W7/rk9PjhN78ZPz7/hrgn1ogNd35BvPrQPWPB1w+Pr9wwJSYSk89xBjaIvd52VKx/6rfiOz89L64wp8/aP168/x4lp3yayb0xRtYJVev19ZIV3/jz9RJx2BCPnby/8JWzf9aA/rDh2OuIOcScvWOODc4SqeQk1aI4dY0HPDzwXA/YAUuDZ2xg0MlnSefWW2/t5qAA8EbC3XfdWcBeRBjORjHGHLwBMJfQw7GLgM/YZvDqGyx2XUDTLlhixQY4yPiMx95YmNPQycnmova/R7BjHNpGB8IOPjysjFu79GCyP8bitA0ur0u+fouztJHK6YlJ0jb21KWHb74znzF8iLH5k4dePkTNkzaY54YdYwDjjYu5BTt97XXirjv4QYAewQdPQ5/4m3ZBI3NPxeYDGD1If6yDBhaecn2ZJ2NGF17mwzM++IyxZY6Q55jH85PXAjbbRKZ/cq0v7DgmXnxnwj+5QBecBFYyXubZlnNxyowj6+EHPg0+9uExJkb42tNOzi88GgQe0o4y8O5re5as+F835MrmPphD5uYaHmOw7llJdnowc66++4Ie5Jyxtt0reODgYx+sevQ0+OKsX3noreqzhBiIL5NxGStyeDaxxGPNib3XWXLt8njRyaOxw559ceR21YMnWNamX+Y082Te8AMv8+EZH3zG2DJHyNHPMsaQflwHPVhIm/LAtmdJ9aYrOaKRG3LJmPxAzsukvl+wtuWhZ3MP1M920WPetAvWa8G9tO70b5/14eEXXfjM2/uS6nwhH3/LWcI9yOI77xjLrftLjjPBd8/dA7H0EjL3FDzze50l7X2J6Ro732DkHDsXqIx8ktcZ68yMOxdV38nu9ea+IIfHHnrNaE877qXXlnsIHoIPBr467mt7X7Ky+5L58f8u/XqcU2/axmsdHoett9bYdQObnJJb96yGroCR596oR+8+MbYW3Ctx8LHvvsm3Lpx7FoOF0PtbzpLxnuMQA/FlMi7isWbh2cQis+bEPpCzZMq0NeOO228b84suzTxhlzkEL/PhGR98xuTJHCHPMSMDB+nHddCDhbQpD+yj+b5kzekzyuOGa6Y3X6wRas+Sqibcf/JjrVjb1EAzh+LWmDpt7IyHZ92Ch8x5e5b89a+XTF1zrZJj94WaJc/klEaOx7vGwSNzT9gP902+++4+cV1gqz1LVt99idcMuc7XjPvDfkk8trAXnlfuF3Ma+2ZDhq520dOWfsCAZ4/FwfMxTJx91oeHjvXHvH2O8wDvS0b/HCf92wfje1u+Jb7xr7vElHRvxH48Uu5LrA321lqBx5yeeqCH4GU+PGuS52x8AOChOEtKpDk4gpC8IJhbuMrQWZkeGC887NG8GLRPvzJ9EqMcDGSfZdpERkNHuclWz7jB0LSZdbJMuXZZjxtGLmjKtJ11GGsv9/CJjWasxsDNgnnTJjIIfxw0ec3a0T5zYtKuNujhK0OeeRnHWH3wkPYzDlmuCefq0NvQM7ZsTyxrZuzamjkQh262aVzmARmx570STy/edYA1F9jI6wZvrOrqX3/M0WEuvoktRhr1C4aGLr368vWrvyYfvRyr8bg+bWqXHkLHGjPH6qKjvzKoY2aPIWxLeZx9IXdObzzw8aNerht1mnr6ojdW7bke7dGvTD/nCYz+6LNMm2Bo2FSOTH4xUP8xHm1mnSxTrt1cn+SCpizbzz61l3uwxEYzVmNwn5lLjvH3aDlLiNk80Ltmx8jFICO3yNxPa8ccqMf/bi1dOBSf/0312yF7bFY95phPcOQ07xU8m361C5YG5f0QD9846SFk+mOOPnP4yjO2MNuzpOTIvLRnSXtf4nXhNUNNSFxL+Xz1evQay9cbNUVT9sDPkva+hLx5BppDz7acV3nkmDGEno9XzMFnHDz3xLF7DFbKY+3rwzm98aCHXL32LGnPEmuJnlrJNeHcGqK3WUvMIWvM+ao4S4yJ66W9L+ndO5Fjr/N8lpAj9qE9S3rPj6whckZuyJc5gme9liJOdaxe1mFMk9SHl+uTa4imT/Ha1Kf2cg/G/TNW5HmfmUuO8dc+x2nvS6wVa4das56Q0TLPMfWUa+zhPkusb3piNE56a16Msbo+z0Zxec1N/ZwnZPqjzzJtgtGGcmTyjYneeLTJXJ0sU67dx+VZsmRBXHLSsfHDhRG77rhNedPDXJKXR9J9ifvNXua9sgbcR/ZYAkuD0HesDnzw6jJnDJYGoaNv5foAKzkGz5hWfuNDAclEyPdI8qBRAAMDJcnMXZRONKIDdNXz3SgLGqxBw8tPdNB3EfoRqw/m6PFuYZZ5kRuTi5OPDjYk14AN+Dk+scr0SazIpOZYHHJ9VXnsK58qAc8c33k95DvbUi6Pj+Y4NibjJ0/wsAvRMzcWYmaMD/1oCyw8iK9Xgg/W2Jhnu+BcFzgJHnOw6qiHDJ4YemXoI2MNNPj21k32owwd48YGeuQDnvhmPPLNrXNjsFdOnMYOFp8QcubI9JnXBC43YlJujx34rAcbrNWP76ILz498Mc6+2U905RMLdiR8wCMnYuFB5p0em/DFu0b4ytGBTyM+fGITOXpi3Rfw8JnTQ8SqX3g043L9Tbm66CPTnjWBX+M3PubYJUYJXeT6EWsczNFrz5LqhQ7yRE7cD/NnnsgvY/aU5j64T/Cg1XGW4Ms42D/G9MaKXzCsgQbf3rpBJ+YPxVY/pTZ7H6ksQUfE7nP64vnT2rPEfJhncuk1Cw8y7/TkHb549wm+cnTg09qzpHrsID/mzpxzfpEz8kQ+M0asMnp47A291ByLQ573Dz/sBXjG+M776DWuXeXafzTcl7hm12g9mhNrlh6ZBP5+z5Ia7DmDjmcgInMKD38QvTHQyze3zsGaZ3rl7g88sGKQM0fOGJ95TeByy/KMg896sPFw3peYK9dI7OYty9qz5KE9S8h9j3qPBezNY/0soRatQXrH1ijXkdcgMonaXZVniXab8TCHPCucwyMGe+XES0MGVgxy5sgY57NCG2BtWY6Oa3+knCXExHpcI3G7d6xHWT5LSrLqvIH1jIePPeb0EOt0zfBo3i95ljbl6qKvfXjeq5pbeMYHD7vsiYQucv2IRU9d9B6Jz3FYA7FBxAqxHlp7lqyas6Qkta5Rx+TX65p6gejhsx/08sFZR+q7Z/TKrTd46IpBzhy5PhnjAwKX22PxLGGtrJl1Mv5bzhJzRm/O6SXtw3s8nSW55swHuaA9es6Sy+O4A4+of9/aHa36wU0OiJfsOvle1yJrZe2s0/pybE7E0COTwFOL1qO9dYO+pAwdrlEJe17X4pvxyPescI4N7NkrZ06syMCKQc4cmT7zmsDl9kDOkvJFcU0lUwTfYJvBYZxESWBNDONMBJmJOUUJKcsx8MTahfOAT5JpYOHnmBjDV18Z88zHV7bBWAwyN914lGOPddHDA+cTf7AWhmsBh12IMXJ04LkhyMgn9sBAjp3DY+2QPHS8AcI3Y3rsao+5caGLX3GMafgyFsbgMzHHp361SW9MjLmpwp5+eOETPtRcj36R4xs5MUPGj4x8wcc3OuSOMTLjUUZPHSGzuR50tYMP5rbiNN34ooss44hJQoYvG3x07PPNJTzwyvVpfPrCvusmTv1rCxy50I7xeN2wD9qmF0uM6Ngj0z4Y+OoZa1lIvSYw5NCGH/XRzWPsQPgzTm3TE7MYevQhbIinB8c+S+oyV1+ZenluTpShY2vPkipTXrd5D9xb8sbYvWB/vI7gURMQORVnfsGxf+DUcW/o4eNTv8xtxsR8ZWcJMuxmG/jWF74ZEzPE3PoibsbodqZ24pVTu3HBPdXvloDdYXonXrR9xMFbVbXZniXVdUPeyDt5yz15J5/0YEpe62uNfMKX0APD3tisN3Doaks76KJHg8DZ2Fftqw/GvVYXXHuW9HJvXnKOGbM3j+X7EtYNUSvel1BX1CLrpymHh+wBnyXtfcnYNUrOIB+Duca9Zukf7FlSjLVnyVh9+vhFfZrXXLuZT+6sZTCM0QEDcb0zdq4cLPuoDrgVn+P07oWLofSjsug81s8ScgjRP5xnCTG4R+679WF81kgJuH2OU9Lg/jEhb/d1XwImXxfq5uvGHNNz3YihZ3+g9r5k5a+XkB9yRU7Jl/lrz5JVd19Cjq1Fc0zfPsd5dD7HKYdKfX5x5rTPcXrnOLl5dJ8l02PDnTeJ2VffUP0GCr9HvcHWscOz9o8Dn7d1rNUdjqGhB/baK3ng8Ytr3euf8xUeMmqHMY9PEHMfq3hc9H4CHWoMG+YWPHNk9Kv6LME+sRGTpC/80SDisff1UmXglTN2Do/GHPsDDLISc4heWR5r1GQRKIQNdQuj/gMfHX2Ap+VAMh4bBEYPrmkTGbpNO/CQeSAgZw7pyzE2bfpmbqzqogcZg3PXri5+jBVZ1uGJIDIIff0y1h885tov4HRzwFz7jNXLvBx/jheb2T+66iGzeI3LtYgxNvRoUI6zORajPX0bE/qOtY0NG3J15GFTP9o1Dubgja/pXzx9lqFvfTjO++r69WNPHPqEl8l4jR9Z9pHXgEw89vJYm9mOPHGsJa9tvLG+9ZttgB+PXDc6YKznpt9sU9/wco7l44dxjpmxNsy76xXXjE8degg8zdjwkYk5OaB3XVmODN2mHXjI2rOkqgFyZo7JlXP2wbwiX11niT70nffZMb0x2hOnOt1ZA/Hxf+y9SYMMHWsJHebg4dnEIctNPXiQ15pja5q58TPGj332WZjpj2swfkTZh3b0L555Hmsy25EnjrXktY031rd+sw1jkGfvutEB054lVS3kXJpPc2TuzSFz9gc5+URXHfPuPNcc+mDdA3OvzmP9voT1mxd6r1fzQQ+ZjzyGh05uyNWR776oqy3kjMGDsWUccpuxqW99gGec99X4keHHPvsszPTHeI0fUfahHf2LZ57Hmsx25IljLa5rZb2+9ZttOG72rhsd7FrPTb/Zpv7h5RzLxwfjHDNjbZh31yuuGZs69BB4mrHhIxNzckDvurIcGbpNO/CQPfT3JZvFvlseGS9qvJHiuh7rZ4n1wB4xzvvsHiIzH3kMD53ckLO3kHxrSF1tIc8+mOsffrNlGba81hxb08xz7WEXMp7sswjqP8qNH3b2oR30IfHM87g2N5YH51mHtTTX15zrW7/aYW4M8uxdt5h8loDRb7apX3g5x/LRY6yuY22Yd/Mmzpjs4Wcf4GnwaNjNxJwc0LuuLEeGXtMOPGQP/VlSRedazL3ras+SVXNfYg2QV3NrzqkF6swGVlzukSuj91pzbE0zz7WHH4g++yzM9Ec5ulL2oZ0cv/bUVYZ+tqM9cawlr228sb71m21kP/L1icy4rOem32xT3/ByjuVjl3GOGZ42zLvrFZfjYgw/+wBPg0fDRybm5IAeXFOODL2mHXjIHo6zBL/Gau6N+9FzlqwTf/f2f49n1WthT9wfevaRJt89QyaJY24+6CHzkcfw0MlNXXr51pC62kLOGB/GZ4zwmy3LsMW+SYzdO+waP3Lm9tmnuvbI1JWXfWjH+AdkCM7JclFZpnEMWHTIDR5+XiR4fTg2KeC0J0YZvr3AsY9cPBh5ZXAfcvTA0+sDnRy7trL9/F8hxpTl2qKHT7zmLsfEYSCGHozxEINrQQeZdrXFXD0w+ILko69NZeZNDL0+GYNjTuPFSshDIq8FecZqDz5k/MyVFUEqWGNTTt9cGzr4QaYteMzxkWNAzvrEg9Ne5mmTHtJ/vsD0h019aIN8ZD3HhdnwSa1kOXal8cbE4DqbcteCvmOx5hsZcSJHBmGHxlyedeBcGbqQfMauX5vaYy4eXI4h2xAPTzJ+5k07zNGhJw7simdsjvQNJvtwnNekPXpIGXbNBXzk2KUHI68M7kMunp4m5di1le23Z0m1x+TEPTGH5t+6Yq7M/Jpra0U5vTUjD52ce3Xp8ZFjwBd1IR5d7WWeNnM82EMX0rdr04c22rOk9xhGTiT33Lm1YD7l07svjrMdZOjQYyNfj4zbs6T3xJL8kavH+n2J62zWEnNriFpRTm+NyQPnNSxWu+1ZUj2+kqt8HZMvr0NzBYb80SAfi50r85qWDxYec226N8zFg8sxMNeGeHiS+8y8aYc5OvTYwK54xu1Z8vg7S6gDWrOWmFtDWW79IMs61CtzscqpK+tcX9SZeH3QZ13m+RrQF7qQc23qQ7vtfUl7X2I9NuvF2imFtIpfL9Gm56pzfD7W70u8Fpv5ZQ75uKOc3jzJA+c1nM8D5J4lYPS1srNEG8Vxe5Y8ou9L3CPro70vqR7fqGFy4jVinrgW2rOkuof13KA3T/LIl+fAys4SzxH61XmWGMtDcV8ywKJZDI2FMYdIDMQF5oLBKLPgcgLVIbkmSNvIeJGdFwGxSVFig4Z9iB5devA5FsbwcjFjDyyJwg89mHz4M4ewy1hfYuDbsl9swYeM1zG9selXPFjtiMMvzTVgVwxj5dggP8ho2EJmfOpjF7kxMCcOceSIj6rLF5/96gMZfAhfxKBd+MSjbeyi51qQ5f0Qhy1s0IzJOboQ2GwLv5Lx5D0CC6HPGH1sggEPT1/aoj6QQ8jVY25+Ml+/2MUP69MfOviElJdJ+poHcsFHr9DDN7rOjc89zX6xB2lfDPo0+DT3Aiz2WScxo09DzzWiRzzNNYlFjgwb6JgP5+DAaNN4mSvThjjXQKzg9VUW154lJQ3kj32BGEPkCSJv5N99NffkVxxjmnvAHpJreIyVY4N6yfsmBpz62HWvipM6DjA0YrU2iE88Mv3qAxl8CF/E4NrgW7/aVR8MMnyhxxxf2mJOY05zDhay3tTFr6QN65Y5fiHwjNHHJhjl9DRttWdJe5bkerV+qBvqKNcutQKW2qG26MFYg+rSU2PWIXMx1h999osteGLbs6Q6o3KOOEsg8sr+tGfJo+e+hH1jz6hz9tTHHudeb1wnyG1eN+w5zesKPkQN0MBjgyZpSwx8a0c7zOXTwwePHfXAcO1Tf9jk2tQXfiF6dOn1oV2w8NqzpMq1e1US196XlDRQOzSuB6i9L1m19yXWmtci1yP5pm/Pkt49ePMMezD3JeRYvGcv+YVy3h1nX+4FeGxw1nJO0LDlfoFTH7uPt7PENZMP1u5jFTkyn/S09iypvnqbx13ykeuQGrKOzBX5fKjvS4iJPWQ/iYdYGNMge/judXtfUt1PmTN68sP+OaantWdJKaOx+uecsM7IlzW2us8S94ZznX3RN7UMeS2Wyd/w2mv5xIfGdVRdStXFpEMd+eBigPRZf8xGfaPAnGKDwGGP3gUgo6kHjkXnAkWGXrYDDhv6Zg4OHqRN9cAht8FnDGmHufZYJ2PnypiDRx+Cb06YM+YABYeMNh4hx4b2MsY1ZJ9NW8zNETZo5oebYddkTGKb8agLTptg0WcfjFH/ea0+UKiHDWPHhr6yXDtgwdCwSa8+c+MSoyzra4MePIcX/tHPPOPAFmsCAw88eozRga9feMYkBp7y4qDxRBYeuYe8mdCOetrQtrHAVwaWvCODiFkeevDpwauf6xE+c/q8Lu2bJ2OiNx7GOX/6Mg7s6hscNmmQ9vMYe2KMsYDra0Ude/Dqy6PXV44Te+DNATJj0057llQ1ZC7zfrgPyMgbMpt5bs+S9ixpz5LqTGrPkkfPWcLZxlnmOcZjBOTjA2PPPcfMxYDjMSfrM8/nY5ahq7426MH7eIt+5onHTntfUuXJ/OQ8y8v5a+9LerXsPRk5sw7pPbfJH/lSTg/lemaOjnkHj758sNYr4/Y5Ti//5sjzwD2AD49GzpST25x7MeCRZX1t0EPtWVLVKTmyvslls77Nk/VMb/4ZowMxRlcZPPcDH+DyfjBGB3LMXIzXTAG0z3HG8mteyBPk82Ty254lq+cssSbNOXm3zqlZr5F8LcATD7a9L+nliZzZch5z/vJZQu6oe7DktD1Lqntkz23qsXluwyNP5pk5uXMOPp8l5lS99ixZPWcJeWcfPBvId74GVsVZgk32GR/Ztn6tAXAQc3D0kI8pxAJpRz3m6gxQRExgWoSd/t67YhrVkEEUy2nxma+tnCz85ILVHr3+tWmvb5OQ+fA8pJv6zGn4z2Rc8NA3ZvHZjvrKtIXOeAQ/Yx3TQ/qyV46MMXwPUHj6U99cijeXyF2LfjhwjSfnDp62877rAzl+tEc8+lGm/2Ko/oM+LcfYxGkTvmP1jHVl+sadfTbt57n2XJc9GGTag08s+KUxZ73wPHz1mW0YvzLmypu+mSt3bBzowNM3c3lg9GN8xMZYH/pHp7lP2gFrA6+PJl5ZxsLTFz2+JX0aO/aaWDCQsTiHpx96ifVmmWPXrw6+cvzi6PXFOJO+9aEMPrz2LKlyZ82RH/L9cJ8l7ps9ceUYHSOnETO910neZ9ckL/fZPnzn2nNury3k4onFWgVHjcJrz5KSorG9IWfkSTJX8Bybd7HmnV6Z+sxt8sg7lPmM3R/57VnSyx05Ib/NXD9W7kvyunKdsG6oPUvu/XhvPdA38+S1xDXE2Poxt+jkx2mvb3C5gdePY+Tg8xyexNiYxIk1Hv03sfDFKst24dGk9iypMmGuyJ97ydh8mjf7LGMMvz1LquvE2sq5k5d75fKc571AJp+x+ZdP/bJf7hnXB7z2vqTKqrmkh6xRctqeJdUZ7GOjuSI3NHPG2PpyTC6VV5nu/c12sh666oGxwVdGD999Ao8NSAxzMPJ8HELuWpCBaZ/j3Pu+rySuPUtKPVEz1g/1kmuNuXVmPVmf4nINwtMeehnLWKyywqj/NH1Rx1DmM8YHTT6x5/jVodd/MZT+GIs+FMGH175eUuWuPUuqyrBeqDnGzu1BWY+M4ZM7a1UcvIfitPdMcgAAEINJREFUvqS88UEgBKDDgf7qP+HhGbCBOWcRBJkJHgTWByUXy4VikWAXDDIXnnXBSuC4aLHHAxQ2aPK1z1ybjrUhRl/GSK8tdCDjwKd4MIyVgWWuH+Tg6SHfeUIOT71snzFyZPQQ69MO9iUwNrHkaGUY9IyPsTHkeOAxF6d98uza0YWvPbD4RQ++e8zcVsC1HjxIfJ7D17Zj5+LU1Y84YweXZcSHjazvXCy65gNZ9pn19C0GmU1Z9qcuPTrIoKY/5sQMRmwBNj7KCM89NkbXih52IMfGiV9k+ldObYnPPTZpue70VxTqfZLnTSJ4dfABicE3NuGDoTceMOLVged6sk/GYF03OBp5Ac8Yu2AcM2esLlgJHPFgrz1LevtgnZkn8meDZ44Zm3dy6ZieuTh1rSv4kPvCnIZf9849Zm5DRzn9yubZtmN9qaeufsQZO7gsIz5sZH3nYtE1B8iyz6ynbzHIbMqyP3Xp0UEGNf0xJ2YwYguwPUtMQ+nzvrjH7kV7llSpMkfMrCXr8NF6X+JaXEdzXePN0cm5sE60RQ+hay0xB8f1CL8py9d2pV3hM7Z5bRuDGPX0bVzK6ZVlf5mPziP9LHEN5JbmPYZrKous/5gDpu19SfX4Q57cY/c+1yW5srbIrXgwOcfoMqenIXcvsPF4f45DTsgjPTTePOfasblXT932LKnu2c0D+aHmzA9jr3fq0nrNcs4A57lvz5JH1usl7E17llTnqnW6Os4SrxeuFa4nmtcXfj3v81lkHGLRzdcecmPOevL0icymLPtTlx4dZFDTH3NiNi79g6WGsq7PY8W4VnxgB3IMRl1k+lfeniVVrsgxeSQf7g05MvfkkDktj0uy63sN85xzjBx76jIHB2EbLM29UQYevnrIwdND7X1Jbx/IR94X5/Tm07Fz8BJjryFxec+yjD3BRtZ3rh10afBt2EWe9eSJUS6GPvvLfHSQQU1/zIkZTPmqK4CCNQIIouDh6YweGXhk9GJ1Ro8DPnbkmF4/9F5Qjg0YPWSQPH14QRgTfsFIOQ758phnPOsQg/28ifDh5XXnmJA7N051XI828WnLNrGNT3oJm85z3MYpT92mPeyojw5jGmNtgHFf5Pl9hWDxweFB7wOJ8WX/jpXZowOZT3D4wSa/d4EP4gYHHxy99hgTj7lgDmkHXcc5f65Vv+hp1zEY5frDHnJjQk59ER94iTE6+oaPjvGI0566TTk41pZjAisevoQufHOqzHjBES+NPfXQxz487YI3bnW1Cd8YwTOWmIPHloRtdNWDr476eQ4OPuR1K45eO+1ZUmWYfLtH5JF807MH5MoGj/zZ3O/KSlVjyCB0IG1nHhh0m/bAqI+efrINMA/FWWJdsw78t2cJma+oPUt6N8LUB3XcniVVbXitkhPa4+0s8fwiGz7etWdJ9ZhAPfi4UB8lj4j7EmPxWqZnH4lXYk5tt/clvXtjckNOyBc9ZJ4Yk7+cLzDwwJhfzgcIGc155qFDe7ydJSUx9Z+H6yzBPfvrPrpP7jlz9lI5fIj9QkZP7Mjb5zjVZnqNmDO41Hb7HGf1nSXk2Hpsz5Lq9ZJVfV9Cjj3XPR+ocXjK8lnRniWP7NdL3DP2kmumfY5TynjsXoWctGfJ6jlLPD/Ir+PVcZawo7z2y2Ov51Sue33Dc7/hSfC8BxKT5fB4bAfTf/jhhx+B0FaKZ2Agli9bVuzlADQK1ptixmDoTYw3xermgMBhRwIjTrvK9accHTA0CHkey8v64rHBZmWZa9AP+saDHmNlbgZzbZQg6j/6QWZyzQe9OQAHRl5eW/avb3n0+mBsDPbGnfHy6NHNeuSCGMxBEdaFkfWyDnyIHr88WKuvLfwMTpgYy5ct1eSYjnroZh/M5blGfcGHN94cPnLJsbayD/UzFn33hXXomx5SX7vMGfOg47qZ04yFvGZd7CuDrx58Wib9ZZ5jZOoaj7GLoccXWEgfzOHnpg190rsWevnaZo5/9eDDk+DjL/tgnu008czBuy7G8rSFTDv4Ymx84Jvx6EO7ytVRji0wNAh5HsvL+uKx0Z4lvTNodZ4l7kPZpPoP+aexN3lfm7y8X9qBB645h+9eK7PXX+6LgfoPeuhbm9SsvukhdfXBnHF7llRJJB8SefH6N4+eAeLs0QHPHGx7lpjFqjd/5Ijc5NySU2sWnDJznS2RXxs4yD3QBzxl9upkvDx6dLPeqjpLJq8xpdyDsBavx+ynOG1cl8ScY2MuzzUi1w688ebwXb9Y+2zfcTFY/0EPfffF2PUPTD19MGf8WDhLJk6aFMuWLhlbo2tjfTTXbs6YW9eZ5xgdcmn+zG22w1jSBzjsQozBqKssXyfulzjsSNmXusr1l2MAQ4OQ57G8rC8eG+19Se8MWlVniXXAHns9ug9lk+o/7jN7k/cVfubl/dIOPGsArHN65tDESZPLtaGO/nJfgPUf7Vibxq5/YOrqgznjx8JZkteU1wmfJs+cMZ80eXIsXXKPrLE9gYEOuTR/9MyzHcaSPsBZQ4zBqKtMO+i6X+KwI2Vf6irXX44BDA1Cnsfysr54bKyus4Q6Hlq+rMSCb3JDb27pzQHxKIOX10b85oPedYhxLa4z9+ppw15+M0+PtrOEOuZxlJywFtZlLlkrZL7oXXfua9gYFn33pT1Lemd6zp85I4/WdeY5RodcklOb9Y0uZM+4OvuXFmx7lpjFqjd/5NScm1t6GjJw5t1cZ0u59sFB7oE+4CmzVy/j5dGjm/UebWeJOWC9rMU1uf68Nnh57Y5LAuo/2nFfPEu49/fRUz19MGe8qu5LOjfccEPX/24gLl7MHpw4KcfZjtsMtBloM9BmoM1Am4E2A20G2gy0GWgz0GagzUCbgTYDbQbaDLQZaDPQZqDNQJuBNgN/WwZGq2+w4Y0OyDc8GPPGB2+W8M1BjH0DifcvfFMEnG+kgPVNJ/jg4KE39lVXvqPlu4nLly4pSvAxSuNrTXjHReMYgAgOvWXLlhXDjP2EhHIcQthhjI6LY65fbOZ3lcDAE+tYjLawzRj7EHjjBuubO3yUBhv4UxcsY22irx/Xwrpp6sDXB31TluMhb8TCm0oTJ04ciwsePo2TGCX8YxM/+kImVj15xCUOPWJSlv2AY47c5rwo1H/0Mx4PPfxji7UxN170Jq0xJYaWVe9OI4OQI0PPAjSXFLJysK5F38wh42V92IKQ5VrLa1eGT3TRwY+2XINz8y0fffSY04yRMbZcm36Yg/GTMNYccwg99gg8+jb0si344KgVdJlDxAeBNSZsGRd8sfoRb68uOuhC2FIXH82DxbrCtmvXr3tn3sG6bnjGZrzYoLVnSXuWUAfWI/U03lmi3BqlXnNNtWdJe5a0Z0l7ljTPkgmTJkfUN9E8DmV5e5ZUX1X5SLwv6Xb6Ynh59Wlz94m9a+9LqvtoHifJB+Q9G3Ny5X1X+xxn9T/HeTjuS/oHJ8To8FC5FvAPUQ/uu/XA/ZH1QV2Acc51xD26fGR5LfneyjMTXf2ABfNYfY7TNzAY3ZHq8YI1s9b2Oc6qfb2EHPP6gLVHPVpj1Bz3c/TU2OPh9ZJ8/TGG8nX41zzHsY6x5/2POcaefpA59hrPj7vEAYHxzHDeniUP3X3JwISJMTK0vOwF10veF+bta6/V41h7lvReG/S6/lvPEq937K3Os4TnbJz7EDF75nDuuAb21zMLuQ0M5Oul8Hkcyc9xsE1D1v/ud7/7CG+cOPhofXz0sPFuCWDIwBjjTIcegh6q4uixqa4ByWOODeYGpS90lCNTbo9MPtjsG74XATht6hef2qaHD14c+sZcBikW/CgHnzeJuX7x4Yt58LVtztDL8ehPPvjxsPDRyzYZmwv8I2cOn3i1TW+eCjN9/7U50Cdy9JnTGEOOm3bxW7DcyHR7+SQOZMaTY5VnHrQPPzd9omuDp0+w5M2YsIMM0g5jdEuMdc3lOfxM+qHPF7z7rVw/rAEZ/ow3+9QOPDDKcnzmwbUxR06vH3Xl0zf3lLrL69EuPo0fPcbGSnySa2OOHKx+zDn8vF5ioMHHnz6xBU/SD/Yk5GLas6TKF3lyz8nN4/Isqc8d8kA+qBnG9MzlMZdn3VFb5E2ZPTx17eFZ1+Co6/Ysqa7O9izp1ZrnFXWTa8s6tJ6sNfCezfK8psWCsWatTXv41j44bOSesbHgRzk8z3lt6Zf5Y/0s6fAYVD9p97rOeSA/5AoZvXvB2AbPfSHP6Cuz16b69PD0Ca49S3r3Ffd3lvT1D5R9I2c5t6Xo61onx839oPbNOXrok3vGyGiM2U/31L3KthmjJ6FDg9r7kva+JNcY9cOcnpphTM9cHnN51h21RE0ps4enrj08fXKmDdXfgW19IoO0wRhd9Gj4zHN4mfRD3z7H6ZbXPvo6vf8aJV/tWVLVq3VET11Z+9Zf7hmLb96XUMfd0d75bg2T68f6fUnOkdc16yZX5pNrmTE9fJrXt7z7PUs4l6Kn717oEzvtfckDvy9xDx6u+5LqNdnqTShqiJqhQe19SXtf4nW9Ws6S+7kvWVVniY8L1LTnHv3quC8pr4h7c1SuovqPCWRRkItj7EWnHsFB4/Xo2ZSrl22LwbaHPjwPmiw3Nu3R07SH3HGOHV5+wFCvBJ+e8IDLNrIt+OORsWAffNZhLB9d1886jQcMtjOu6Uc9femDHp62lKPvWAw+9Atef9oCj5weHnhtYE+csakvxvwYizEgR4Y+MnxoD162m32K1w662sZmtsPclu051j9zGlhjKIOUL+f2YLUDzzk816xdbvS0Taz6kqe+fdMWc2xywUva1pZ7mG1me4zBynPt5i7zGXOdYQu7jJXD0wf2vB6RM8cets0Bc/FNG8ajHeTqqqfueD16NuXqZdtisM16nBu7c31jS3uOtQfGsWvGDjx8S+o5V4c+25APDv54ZCzYB591GMtH1/VbD/DAYDvjmn7U05c+6OEhh5TnsRh86Be8/rSFLnJ6eOCzPXHGpr4Y8GCsR2NArgwdfEBgbdrMPpGBh7DBOM+zHeQ29CTH+tcfWEg5Y3nq2sNv4rSDXch5e5b0npy4Hzl/5Mn6IHc09lQsuWTc7M0vvXL14EEZg13qQ157lpQUlT/mzTzm/MHL15haGcvY/IK1mWt0wDyYswQd42KMfexZK9rUNzLw+QzI/rWR4wavHWN2nu2gY8Om5NjY9Jd9iJXn3B6+duA5h4ddSLvtWdKeJdaK9ZHn1pR149zeGqTWrSllzOXDYwye64AxpM+MU99ePX3l+OBpSzl6jsEyJn79gteftsAgpzcmbRin8dCrL8br9SE/S+q1EoexG6drMzbmNGNWDl6euvZNm87RtSa0+1g9S8iFj+2MWS/7z/rNAfOcQ8Y280xvfairnrrj9eaXXrl62bY4bFPLzo3dub6NjzU51h4Yx64ZO/DwLannXB36bEM+OPjjUV4b+KzDGL/yXL/XNPaQYTvjmn7U05f26OEhh5TnsRh86Be8/rSF7qPyLKlzQPw010MOHLunzGnmSXnOF+NMTZvO0bUmtPtYPUtYn9cjuWFO/bB+c8DcvIJhbAOvnr266qk7Xm9+6ZWrl22Lw3Z7lvTuz0vy6z/mzTzm/MFDDinPY/NvfsHazL34x/NZYg7oM5FT8w3fOTyvI/P4QM+S/w8YMgUMMKvAuAAAAABJRU5ErkJggg==" alt="Alt text"></li>
</ul>
<h4 id="C-I-hate-it"><a href="#C-I-hate-it" class="headerlink" title="C I hate it"></a>C I hate it</h4><ul>
<li>改了改update和query</li>
</ul>
<pre><code>  1 #include&lt;iostream&gt;
  2 #include&lt;cstdio&gt;
  3 #include&lt;algorithm&gt;
  4 #include &lt;string&gt;
  5 #include &lt;string.h&gt;
  6 using namespace std;
  7 const int maxn = 1000000;
  8 struct node
  9 {
 10 int left,right,value;
 11 }tree[maxn];
 12  
 13 void build(int n)
 14 {
 15 int i,k;
 16 for (k=1; k &lt; n ; k = k&lt;&lt;1); // k是超过n的最小2的倍数
 17 for (i = k;i &lt; 2*k ; i++) // 完全二叉树
 18 {
 19 tree[i].left = tree[i].right = i - k + 1;
 20 tree[i].value = 0;
 21 // cout &lt;&lt; &quot;node : &quot; &lt;&lt; i &lt;&lt; &quot;,left:&quot; &lt;&lt; i - k + 1 &lt;&lt; &quot;,right :&quot; &lt;&lt; i-k+1 &lt;&lt; endl;
 22 }
 23 for ( i = k-1 ;i&gt;0;i--)
 24 {
 25 tree[i].left = tree[2*i].left;
 26 tree[i].right = tree[2*i+1].right;
 27 tree[i].value = 0;
 28 // cout &lt;&lt; &quot;node : &quot; &lt;&lt; i &lt;&lt; &quot;,left:&quot; &lt;&lt; tree[2*i].left &lt;&lt; &quot;,right :&quot; &lt;&lt; tree[2*i+1].right &lt;&lt; endl;
 29 }
 30 }
 31 void update(int l,int r,int value,int step)
 32 { // tree[step]存储左子树和右子树中较大的数
 33 if (tree[step].left == tree[step].right)
 34 { // 叶子结点时赋值value
 35 tree[step].value = value;
 36 return ;
 37 }
 38 int mid = (tree[step].left + tree[step].right) &gt;&gt; 1;
 39 if (r &lt;= mid)
 40 update(l,r,value,step&lt;&lt;1);
 41 else if (l&gt;mid)
 42 update(l,r,value,(step&lt;&lt;1)+1);
 43 else
 44 {
 45 update(l,mid,value,step&lt;&lt;1);
 46 update(mid+1,r,value,(step&lt;&lt;1)+1);
 47 }
 48 tree[step].value = max(tree[step&lt;&lt;1].value,tree[(step&lt;&lt;1)+1].value);
 49 // cout &lt;&lt; &quot;node : &quot; &lt;&lt; step &lt;&lt; &quot;,left:&quot; &lt;&lt; tree[step&lt;&lt;1].value &lt;&lt; &quot;,right :&quot; &lt;&lt; tree[(step&lt;&lt;1)+1].value &lt;&lt; endl;
 50 }
 51 int query(int l,int r,int step)
 52 {
 53 // 查询l - r 中的最大值
 54  
 55 if (tree[step].left == l &amp;&amp; tree[step].right == r)
 56 return tree[step].value;
 57  
 58 int mid = (tree[step].left + tree[step].right) &gt;&gt; 1;
 59 if (r &lt;= mid)
 60 return query(l,r,step&lt;&lt;1);
 61 else if (l&gt;mid)
 62 return query(l,r,(step&lt;&lt;1)+1);
 63 else
 64 {
 65 return max(query(l,mid,step&lt;&lt;1),query(mid+1,r,(step&lt;&lt;1)+1));
 66 }
 67  
 68 }
 69 int main()
 70 {
 71 int n,m,grade,a,b;
 72 char cmd[3];
 73 while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
 74 {
 75 // 1. 创建线索树
 76 build(n);
 77 // 2. 输入数据并更新线索树
 78 for (int i=1;i&lt;=n;i++)
 79 {
 80 scanf(&quot;%d&quot;,&amp;grade);
 81 update(i,i,grade,1);
 82 }
 83 // cout &lt;&lt; tree[1].value &lt;&lt; endl;
 84 // 3. m条操作依次执行
 85 for (int i=0;i&lt;m;i++)
 86 {
 87  
 88 scanf(&quot;%s%d%d&quot;,cmd,&amp;a,&amp;b);
 89 if (cmd[0] == &#39;Q&#39;)
 90 {
 91 cout &lt;&lt; query(a,b,1) &lt;&lt; endl; // 查询a-b中的最大值
 92 }
 93 if (cmd[0] == &#39;U&#39;)
 94 {
 95 update(a,a,b,1);
 96 }
 97  
 98 }
 99 }
100 }
</code></pre><p>但是看到有在build部分修改函数的：</p>
<p><a href="https://blog.csdn.net/xp731574722/article/details/78423559" target="_blank" rel="noopener">线段树 最大最小模板</a></p>
<h4 id="D-just-a-hook"><a href="#D-just-a-hook" class="headerlink" title="D just a hook"></a>D just a hook</h4><pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;cstdio&gt;
 3 #include&lt;algorithm&gt;
 4 #include &lt;string&gt;
 5 #include &lt;string.h&gt;
 6 using namespace std;
 7  
 8 const int maxn = 1000000;
 9 struct node
10 {
11 int left,right,value;
12 }tree[maxn];
13  
14 void build(int n)
15 {
16 int i,k;
17 for (k=1;k&lt;n;k=k&lt;&lt;1);
18 for (i=k;i&lt;k*2;i++)
19 {
20 tree[i].left = tree[i].right = i-k+1;tree[i].value = 0;
21 // printf(&quot;结点：%d,左边：%d,右边：%d\n&quot;,i,i-k+1,i-k+1);
22 }
23 for (i=k-1;i&gt;0;i--)
24 {
25 tree[i].left = tree[2*i].left;
26 tree[i].right = tree[2*i+1].right;
27 tree[i].value = 0;
28 // printf(&quot;结点：%d,左边：%d,右边：%d\n&quot;,i,tree[i&lt;&lt;1].left,tree[(i&lt;&lt;1)+1].right);
29 }
30 }
31  
32 void update(int l,int r,int value ,int step)
33 {
34 tree[step].value += value;
35 // printf(&quot;结点：%d,左边：%d,右边：%d,value:%d\n&quot;,step,tree[step].left,tree[step].right,tree[step].value);
36 if (tree[step].left == tree[step].right)
37 {
38 return ;
39 }
40 int mid = (tree[step].left+tree[step].right)&gt;&gt;1;
41 if (r &lt;= mid)
42 update(l,r,value,step&lt;&lt;1);
43 else if (l&gt;mid)
44 update(l,r,value,(step&lt;&lt;1)+1);
45 else
46 {
47 update(l,mid,value,step&lt;&lt;1);
48 update(mid+1,r,value,(step&lt;&lt;1)+1);
49 }
50 }
51 int main()
52 {
53 int t,n,q,a,b,c,x;
54 scanf(&quot;%d&quot;,&amp;t);
55 for (int i = 1;i&lt;=t;i++)
56 {
57 scanf(&quot;%d%d&quot;,&amp;n,&amp;q); // stick number &amp; oper number
58 build(n);
59 for (int g=1;g&lt;=n;g++)
60 update(g,g,1,1);
61  
62 for (x=1;x&lt;n;x=x&lt;&lt;1);
63 for (int j=1;j&lt;=q;j++)
64 {
65 scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); // a-b 修改mental kind
66 for (int k = a;k&lt;=b;k++)
67 update(k,k,c-tree[x+k-1].value,1);
68 }
69 printf(&quot;Case %d:The total value of the hook is %d\n&quot;,i,tree[1].value);
70  
71  
72 }
73  
74 }
</code></pre><ul>
<li>区间更新 = 循环+每个点的单点更新 = Time limited exceed</li>
</ul>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-贪心算法（Fatmouse’Trade、今年暑假不AC）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/贪心算法（Fatmouse’Trade、今年暑假不AC）/">贪心算法（Fatmouse’Trade、今年暑假不AC）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/贪心算法（Fatmouse’Trade、今年暑假不AC）/" class="article-date">
  <time datetime="2018-08-20T18:06:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Fatmouse’Trade"><a href="#Fatmouse’Trade" class="headerlink" title="Fatmouse’Trade"></a>Fatmouse’Trade</h3><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：FatMouse&#39;Trade
10     用时：tomato *
11     思路：贪心
12     坑：一直显示没有通过所有的测试用例
13     1. m设置为double，所有的float都设置成double %lf 类型即可 
14 */
15 
16 struct goods
17 {
18     double catFood;
19     double javabean;
20     double w ;
21     bool operator &lt;(const goods &amp; g)const{
22         return w-g.w &gt; 0; // 降序排列
23     }
24 }buf[1000];
25 
26 
27 int main()
28 {
29     double m;
30     int n;
31     cin &gt;&gt; m &gt;&gt; n;
32     double result=0;
33     while (m!= -1 &amp;&amp; n!= -1)
34     {
35         for (int i=0;i&lt;n;i++)
36         {
37             cin&gt;&gt;buf[i].javabean &gt;&gt; buf[i].catFood;
38             buf[i].w = (float)buf[i].javabean/buf[i].catFood;
39         }
40         sort(buf,buf+n);
41         result =0;
42         for (int i=0;i&lt;n &amp;&amp; m &gt; 0;i++)
43         {
44             if (buf[i].catFood &lt;= m )
45             { // catFood足够充裕买完这个room所有的bean
46                 m = m - buf[i].catFood ;
47                 result += buf[i].javabean;
48             }
49             else{ // 猫粮不够充裕仅仅能买一部分
50                 result += buf[i].w * m;
51                 m = 0 ;
52             }
53         }
54         printf(&quot;%.3lf\n&quot;,result);
55         cin &gt;&gt; m &gt;&gt;n;
56     }
57 
58     return 0;
59 }
</code></pre><h4 id="今年暑假不AC"><a href="#今年暑假不AC" class="headerlink" title="今年暑假不AC"></a>今年暑假不AC</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;algorithm&gt;
 4 using namespace std;
 5 
 6 const int N = 100;
 7 struct show
 8 {
 9     int start ;
10     int end1;
11     bool operator &lt; (const show &amp;a)const{
12     return end1 &lt; a.end1 ;
13     }
14 };
15 
16 bool cmp(const show &amp;a,const show &amp;b)
17 {
18     return a.end1 &lt;= b.end1 ;
19 }
20 
21 int main()
22 {
23    int n,i,j;
24    show show[N];
25    while (cin &gt;&gt; n &amp;&amp; n!=0)
26    {
27    for (i=0;i&lt;n;i++)
28    {
29     cin &gt;&gt; show[i].start &gt;&gt;show[i].end1 ;
30    }
31    sort(show,show+n,cmp);
32    int sum = 1;
33    for (i = 0 , j = 1;i &lt; n &amp;&amp; j &lt; n; j++)
34    {
35     if (show[j].start &gt;= show[i].end1)
36     {
37         sum ++;
38         i=j;
39     }
40    }
41    cout &lt;&lt; sum &lt;&lt; endl;
42    }
43     return 0;
44 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-搜索+DP专题（背包问题、N个数选K个使平方和最大且和为X、divide by three, multiple by two、全排列、组合、N皇后、jugs、掉石头迷宫、斐波那契、最大连续子序列和、最长上升子序列、非常可乐、导弹拦截系统：最长不降子序列）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/搜索+DP专题（背包问题、N个数选K个使平方和最大且和为X、divide by three, multiple by two、全排列、组合、N皇后、jugs、掉石头迷宫、斐波那契、最大连续子序列和、最长上升子序列、非常可乐、导弹拦截系统：最长不降子序列）/">搜索+DP专题（背包问题、N个数选K个使平方和最大且和为X、divide by three, multiple by two、全排列、组合、N皇后、jugs、掉石头迷宫、斐波那契、最大连续子序列和、最长上升子序列、非常可乐、导弹拦截系统：最长不降子序列）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/搜索+DP专题（背包问题、N个数选K个使平方和最大且和为X、divide by three, multiple by two、全排列、组合、N皇后、jugs、掉石头迷宫、斐波那契、最大连续子序列和、最长上升子序列、非常可乐、导弹拦截系统：最长不降子序列）/" class="article-date">
  <time datetime="2018-08-20T18:05:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试-搜索专题"><a href="#机试-搜索专题" class="headerlink" title="机试-搜索专题"></a>机试-搜索专题</h3><h4 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h4><p>堆和栈的区别：<br><a href="https://www.cnblogs.com/myblesh/archive/2012/03/14/2396409.html" target="_blank" rel="noopener">https://www.cnblogs.com/myblesh/archive/2012/03/14/2396409.html</a><br>定义全局变量或者自己malloc，栈的空间是有限的。</p>
<h5 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h5><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // 输出背包问题的最佳方案
13 const int maxn = 20000;
14 int n,v;
15 int w[maxn];
16 int c[maxn];
17 vector&lt;int&gt; tmp,ans;
18 int maxc;
19 void dfs(int i,int sumw,int sumc)
20 {
21     if (i == n)
22     {
23         if (sumc &gt; maxc)
24         {
25             maxc = sumc;
26             ans = tmp; // the way of vector assign
27         }
28         return ;
29     }
30     if (sumw+w[i] &lt;= v)
31     {
32        tmp.push_back(i);
33        dfs(i+1,sumw+w[i],sumc+c[i]);
34        tmp.pop_back();
35     }
36     dfs(i+1,sumw,sumc);
37 }
38 int main()
39 {
40     while (cin&gt;&gt;n&gt;&gt;v)
41     {
42         for (int i=0;i&lt;n;i++)
43             cin &gt;&gt; w[i];
44         for (int i=0;i&lt;n;i++)
45             cin &gt;&gt; c[i];
46         dfs(0,0,0);
47         for (int i=0;i&lt;ans.size();i++)
48             cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
49         cout &lt;&lt; endl;
50         cout &lt;&lt; maxc &lt;&lt; endl;
51 
52     }
53 
54 
55     return 0 ;
56 }
</code></pre><h4 id="N个数选K个使平方和最大且和为X"><a href="#N个数选K个使平方和最大且和为X" class="headerlink" title="N个数选K个使平方和最大且和为X"></a>N个数选K个使平方和最大且和为X</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // 从N个数中选择K个数，使和为x的基础上平方和最大
13 const int maxn = 2000;
14 int n,k,x;
15 int maxsum;
16 vector&lt;int&gt; tmp,ans;
17 int a[maxn];
18 void dfs(int i,int num,int sum,int psum)
19 {
20     // i 代表第i个被选择的数,num代表一共挑选的数的个数，sum为其和，psum为平方和
21     if (i==n)
22     {
23         if (psum &gt; maxsum &amp;&amp; num == k &amp;&amp; sum == x)
24         {
25             maxsum = psum;
26             ans = tmp;
27         }
28         return ;
29     }
30     dfs(i+1,num,sum,psum);
31     if (sum+a[i]&lt;=x)
32     {
33         tmp.push_back(a[i]);
34         dfs(i+1,num+1,sum+a[i],psum+a[i]*a[i]);
35         tmp.pop_back();
36     }
37 }
38 int main()
39 {
40     while (cin&gt;&gt;n&gt;&gt;k&gt;&gt;x)
41     {
42         maxsum = 0;
43         for (int i=0;i&lt;n;i++)
44             cin &gt;&gt; a[i];
45         dfs(0,0,0,0);
46         for (int i=0;i&lt;ans.size();i++)
47             cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
48         cout &lt;&lt; endl;
49         cout &lt;&lt; maxsum &lt;&lt; endl;
50     }
51 
52 
53     return 0 ;
54 }
55 // 1.127s
56 void dfs(int i,int num,int sum,int psum)
57 {
58     // K个并且和为X时才判断
59     if (num == k &amp;&amp; sum == x)
60     {
61         if (sum &gt; maxsum)
62         {
63             maxsum = sum;
64             ans = tmp;
65         }
66         return ;
67     }
68     // 其他情况直接return 
69     if (i&gt;n-1 || num &gt; k || sum&gt;x)
70         return ;
71     if (a[i]+sum &lt;= x)
72     {
73         tmp.push_back(i);
74         dfs(i+1,num+1,sum+a[i],psum+a[i]*a[i]);
75         tmp.pop_back();
76     }
77     dfs(i+1,num,sum,psum);
78 }
</code></pre><h4 id="codeforces-round-479-D-divide-by-three-multiple-by-two"><a href="#codeforces-round-479-D-divide-by-three-multiple-by-two" class="headerlink" title="codeforces round 479 D divide by three, multiple by two"></a>codeforces round 479 D divide by three, multiple by two</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 
13 
14 int n;
15 long long a[101];
16 bool visited[101];
17 long long f[101];
18 
19 bool dfs(int &amp;k)
20 {
21     if (k==n)
22         return true;
23     long long x = f[k-1];
24     for (int i=0;i&lt;n;i++)
25     {
26         if (visited[i])
27             continue;
28         if ((a[i] == x/3 &amp;&amp; (x%3==0)) || a[i] == x*2)
29         {
30             f[k++] = a[i];
31             visited[i] = true;
32             if (dfs(k)) return true;
33             visited[i] = false;
34             k--;
35         }
36     }
37     return false;
38 }
39 int main()
40 {
41 
42     int k;
43     while (cin&gt;&gt;n)
44     {
45         for (int i=0;i&lt;n;i++)
46         {
47            cin &gt;&gt; a[i];visited[i] = false;
48         }
49         k = 0;
50         for(int i=0;i&lt;n;i++)
51         {
52             visited[i] = true;
53             f[k++] =  a[i];
54             if (dfs(k)) break; // 只要找到一组就直接break，不用继续循环了
55             visited[i] = false;
56             k--;
57         }
58         for (int i=0;i&lt;n;i++)
59             cout &lt;&lt; f[i] &lt;&lt;&#39; &#39;;
60         cout &lt;&lt; endl;
61 
62 
63 
64     }
65 
66     return 0 ;
67 }
</code></pre><blockquote>
<p>return true / false / break 是为了在找到正确答案后立即输出而不是继续循环到末尾</p>
</blockquote>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 
13 // divide by three, multiple by two
14 int n;
15 long long a[101];// 8B 2^64 = 1024^6 = e^18
16 vector&lt;long long &gt;ans;
17 bool flag,visited[101] ;
18 void dfs(int i,int sum) // i: the i th number ; sum:selected number
19 {
20     if (sum==n)
21     { 
22         for (int i=0;i&lt;n-1;i++)
23             cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
24         cout &lt;&lt; ans[n-1]&lt;&lt;endl;
25         flag = true;
26         return ;
27     }
28 
29     //4 8 6 3 12 9
30     for (int j=0;j&lt;n;j++)
31     {
32         if (i!=j &amp;&amp; !visited[j])
33         {
34             if ((a[j]==a[i]/3 &amp;&amp; a[i]%3==0) || a[j] == a[i]*2 )
35             {
36                 ans.push_back(a[j]);visited[j]=true;
37                 dfs(j,sum+1);
38                 if (!flag)
39                 {
40                   ans.pop_back();visited[j] = false;
41                 }
42             }
43         }
44     }
45 }
46 int main()
47 {
48    while (cin&gt;&gt;n)
49    {
50        for (int i=0;i&lt;n;i++)
51        {
52          cin &gt;&gt; a[i];visited[i]=false;
53        }
54 
55         ans.clear();
56         flag = false;
57        for (int i=0;i&lt;n;i++)
58        {
59            ans.push_back(a[i]);visited[i]=true;
60            dfs(i,1);
61            ans.pop_back();visited[i] = false;
62        }
63 
64    }
65 
66 
67 
68     return 0 ;
69 }
</code></pre><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><ul>
<li>10 min</li>
</ul>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // 全排列
13 int n,sum;
14 bool visited[101];
15 vector&lt;int&gt; ans;
16 void dfs(int sum)
17 {
18     if (sum == n)
19     {
20         for (int i=0;i&lt;n-1;i++)
21             cout &lt;&lt; ans[i] &lt;&lt;&quot; &quot;;
22         cout &lt;&lt; ans[n-1] &lt;&lt; endl;
23         return;
24     }
25     for (int i=1;i&lt;=n;i++)
26     {
27         if (!visited[i])
28         {
29            visited[i]= true;
30            ans.push_back(i);
31            dfs(sum+1);
32            visited[i]= false;
33            ans.pop_back();
34         }
35     }
36 }
37 int main()
38 {
39    while  (cin&gt;&gt;n)
40    {
41        for (int i=1;i&lt;=n;i++)
42        {
43            visited[i] = false;
44        }
45        ans.clear();
46        dfs(0); // 选择0个元素
47    }
48 
49 
50     return 0 ;
51 }
</code></pre><h4 id="组合-递归"><a href="#组合-递归" class="headerlink" title="组合 递归"></a>组合 递归</h4><ul>
<li>15min</li>
</ul>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // 递归 求组合
13 int n,r,num; // num:selected numbers
14 vector&lt;int &gt; ans;
15 void dfs(int i,int num)
16 {
17     // 判断第I个数是否要被选择
18     if (i == n)
19     {
20         if (num == r)
21         {
22             for (int i=0;i&lt;r-1;i++)
23             cout &lt;&lt; ans[i] &lt;&lt;&quot; &quot;;
24             cout &lt;&lt; ans[r-1] &lt;&lt; endl;
25         }
26         return;
27     }
28     ans.push_back(i+1);
29     dfs(i+1,num+1);
30     ans.pop_back();
31 
32     dfs(i+1,num);
33 }
34 int main()
35 {
36    while  (cin&gt;&gt;n&gt;&gt;r)
37    {
38        ans.clear();
39        dfs(0,0);//
40    }
41 
42 
43     return 0 ;
44 }
</code></pre><h4 id="组合-非递归"><a href="#组合-非递归" class="headerlink" title="组合 非递归"></a>组合 非递归</h4><pre><code> 1 #define _CRT_SECURE_NO_WARNINGS
 2 #include &lt;algorithm&gt;
 3 #include &lt;iostream&gt;
 4 #include &lt;iomanip&gt;
 5 #include &lt;cstring&gt;
 6 #include &lt;vector&gt;
 7 #include &lt;string&gt;
 8 #include &lt;queue&gt;
 9 #include &lt;stack&gt;
10 #include &lt;map&gt;
11 #include &lt;set&gt;
12 
13 using namespace std;
14 
15 void permutation(int n, int m)
16 {
17     vector&lt;int&gt; combine;
18     stack&lt;int&gt; buf;
19     bool pop = false;
20     int top;
21 
22     buf.push(1);
23     combine.push_back(1);
24 
25     while (buf.size())
26     {
27         if (combine.size() == m)
28         {
29             for (int i = 0; i &lt; m; ++i)
30             {
31                 printf(&quot;%d&quot;, combine[i]);
32                 if (i != m - 1)
33                     printf(&quot; &quot;);
34             }
35             printf(&quot;\n&quot;);
36             pop = true;
37         }
38 
39         top = buf.top() + 1;
40         if (top == n + 1)
41         {
42             pop = true;
43             buf.pop();
44             combine.pop_back();
45             continue;
46         }
47 
48         if (pop)
49         {
50             buf.pop();
51             combine.pop_back();
52             pop = false;
53         }
54 
55         if (top &lt;= n)
56         {
57             buf.push(top);
58             combine.push_back(top);
59         }
60     }
61 
62 }
63 
64 int main()
65 {
66 #ifdef _DEBUG
67     freopen(&quot;data.txt&quot;, &quot;r+&quot;, stdin);
68 #endif // _DEBUG
69 
70     int n, m, PS = 0;
71 
72     while (cin &gt;&gt; n &gt;&gt; m)
73     {
74         permutation(n, m);
75     }
76 
77 
78 
79     return 0;
80 }
</code></pre><h4 id="组合数-判断素数"><a href="#组合数-判断素数" class="headerlink" title="组合数+判断素数"></a>组合数+判断素数</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // 递归 求组合
13 int n,k,num,ans,ans_num; // num:selected numbers
14 int a[21];
15 bool visited[21];
16 
17 bool isSu(int x)
18 {
19     for (int i=2;i&lt;sqrt(x)+1;i++)
20     {
21         if (x%i == 0)
22         {
23            return false;
24         }
25     }
26     return true;
27 
28 }
29 void dfs(int i,int num)
30 {
31     // 判断第I个数是否要被选择
32     if (i == n)
33     {
34         if (num == k &amp;&amp; isSu(ans))
35         {
36          ans_num++;
37         }
38         return;
39     }
40     if (num+1 &lt;= k )
41     {
42         ans += a[i+1];
43         dfs(i+1,num+1);
44         ans -= a[i+1];
45     }
46     dfs(i+1,num);
47 }
48 int main()
49 {
50    while  (cin&gt;&gt;n&gt;&gt;k)
51    {
52        for (int i=1;i&lt;=n;i++)
53        {
54           cin &gt;&gt; a[i]; visited[i]=  false;
55        }
56        ans = 0;ans_num = 0;
57        dfs(0,0);
58        cout &lt;&lt; ans_num &lt;&lt; endl;
59    }
60 
61 
62     return 0 ;
63 }
</code></pre><h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // N皇后问题
13 int n,num;
14 bool visited[11];
15 vector&lt;int&gt; ans;
16 bool flag = false;
17 bool isok(int i,int j)
18 {
19     // 判断第I行皇后能否放在J个列
20     // 1. 不可能同一行，因为I从1-n
21     // 2. 同一列
22     if (visited[j])
23         return false;
24     // 3. 对角线
25     // i,j / k, l |i-k| = |k-l| 时两个点在对角线上
26     for (int k = 1;k&lt;i;k++)
27     {
28         if (abs(k-i) == abs(ans[k-1]-j))
29             return false;
30     }
31     return true;
32 }
33 void dfs(int i)
34 {
35     if (i==n)
36     {
37         flag = true;
38         for (int j=0;j&lt;n-1;j++)
39             cout &lt;&lt; ans[j] &lt;&lt; &quot; &quot;;
40         cout &lt;&lt; ans[n-1] &lt;&lt; endl;
41         return ;
42     }
43     for (int j=1;j&lt;=n;j++)
44     { // j : column
45         if (isok(i+1,j))
46         {
47             visited[j] = true;
48             ans.push_back(j);
49             dfs(i+1);
50             visited[j] = false;
51             ans.pop_back();
52         }
53 
54     }
55 }
56 int main()
57 {
58    while  (cin&gt;&gt;n)
59    {
60        ans.clear();
61        for (int i=0;i&lt;=n;i++)
62         visited[i] = false;
63        dfs(0);
64        if (!flag)
65         cout&lt;&lt;&quot;no solute!&quot; &lt;&lt;endl;
66    }
67 
68 
69     return 0 ;
70 }
</code></pre><h4 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 using namespace std;
12 // 走迷宫
13 int n,m;
14 int a[101][16];
15 struct point
16 {
17     int x,y;
18 };
19 point s,e,t;
20 
21 vector&lt;point&gt; ans;
22 void print()
23 {
24     for (int i=0;i&lt;ans.size()-1;i++)
25     {
26         cout &lt;&lt; &quot;(&quot;&lt;&lt;ans[i].x&lt;&lt;&quot;,&quot;&lt;&lt;ans[i].y&lt;&lt;&quot;)-&gt;&quot;;
27     }
28     cout &lt;&lt; &quot;(&quot;&lt;&lt;ans[ans.size()-1].x&lt;&lt;&quot;,&quot;&lt;&lt;ans[ans.size()-1].y&lt;&lt;&quot;)&quot;&lt;&lt;endl;
29 }
30 int dir[4][2] = {
31 0,-1,
32 -1,0,
33 0,1,
34 1,0
35 };
36 void dfs(point p)
37 { // p：当前位置
38     if (p.x == e.x &amp;&amp; p.y == e.y)
39     {
40         print();
41         return;
42     }
43     if (p.x&lt;1 || p.x &gt; n || p.y &lt; 1 || p.y &gt; m)
44         return ; // meet border return
45     if (a[p.x][p.y] == 0)
46         return ; // meet wall return
47     for (int i=0;i&lt;4;i++)
48     {
49         t = p;
50         // 四个方向即四个分支可以深搜
51         t.x = p.x+dir[i][0];
52         t.y = p.y+dir[i][1];
53         // 已经访问过的点再往下深搜的过程中不会再次访问，可以设为wall
54         a[p.x][p.y] = 0;
55         ans.push_back(t);
56         dfs(t);
57         a[p.x][p.y] = 1;
58         ans.pop_back();
59 
60     }
61 
62 }
63 int main()
64 {
65 
66     while (cin&gt;&gt;n&gt;&gt;m)
67     {
68         for (int i=1;i&lt;=n;i++)
69         {
70             for (int j=1;j&lt;=m;j++)
71             {
72                 cin &gt;&gt; a[i][j];
73             }
74         }
75         ans.clear();
76         cin &gt;&gt; s.x &gt;&gt; s.y;
77         cin &gt;&gt; e.x &gt;&gt; e.y;
78         ans.push_back(s);
79         dfs(s);
80 
81 
82     }
83 
84 
85     return 0 ;
86 }
</code></pre><ul>
<li>本地运行正确但提交不正确</li>
</ul>
<h4 id="jugs"><a href="#jugs" class="headerlink" title="jugs"></a>jugs</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;vector&gt;
  5 #include &lt;stack&gt;
  6 #include &lt;map&gt;
  7 #include &lt;string&gt;
  8 #include &lt;string.h&gt;
  9 #include &lt;algorithm&gt;
 10 #include &lt;math.h&gt;
 11 #include &lt;queue&gt;
 12 using namespace std;
 13 int ca,cb,n;
 14 struct node
 15 {
 16     int x,y;
 17     struct node *parent;
 18     string word;
 19 }s,e,tmp,cur;
 20 queue&lt;node&gt; q;
 21 vector&lt;string&gt; w;
 22 int main()
 23 {
 24     while (cin&gt;&gt;ca&gt;&gt;cb&gt;&gt;n)
 25     {
 26         while (!q.empty())
 27             q.pop();
 28         w.clear();
 29         s.x = 0;s.y = 0;s.parent = NULL;
 30         e.y = n;
 31         q.push(s);
 32         while (!q.empty())
 33         {
 34             cur = q.front();
 35             q.pop();
 36             // ÅÐ¶ÏÊÇ*ñÎª×iÖÕÌ¬
 37             if (cur.y == e.y)
 38             {
 39                 string t = &quot;success&quot;;
 40                 w.push_back(t);
 41                 struct node *p;p=&amp;cur;
 42               while (p-&gt;parent!=NULL)
 43               {
 44                  w.push_back(p-&gt;word);
 45                  p = p-&gt;parent;
 46               }
 47               for (int i = w.size()-1;i&gt;=0;i--)
 48               {
 49                   cout &lt;&lt; w[i] &lt;&lt; endl;
 50               }
 51             }
 52 
 53 
 54             if (cur.x &lt; ca)
 55             {
 56                 tmp = cur;
 57                 // A is not full
 58                 tmp.x = ca;
 59                 tmp.word = &quot;fill A&quot;;
 60                 tmp.parent = &amp;cur;
 61                 q.push(tmp);
 62             }
 63 
 64             if (cur.y &lt; cb)
 65             {
 66                 tmp = cur;
 67                 // B is not full
 68                 tmp.y = cb;
 69                 tmp.word = &quot;fill B&quot;;
 70                 tmp.parent = &amp;cur;
 71                 q.push(tmp);
 72             }
 73 
 74             if (cur.x &gt; 0)
 75             {
 76                 tmp = cur;
 77                 // A is not empty
 78                 tmp.x = 0;
 79                 tmp.word = &quot;empty A&quot;;
 80                 tmp.parent = &amp;cur;
 81                 q.push(tmp);
 82             }
 83 
 84             if (cur.y &gt; 0)
 85             {
 86                 tmp = cur;
 87                 // B is not empty
 88                 tmp.y = 0;
 89                 tmp.word = &quot;empty B&quot;;
 90                 tmp.parent = &amp;cur;
 91                 q.push(tmp);
 92             }
 93 
 94             if (cur.x &gt; 0 &amp;&amp; cur.y &lt; ca)
 95             {
 96                 tmp = cur;
 97                 if (cur.x &gt;= cb-cur.y) // x more than capacity of B
 98                 {
 99                     tmp.y = cb;
100                     tmp.x = cur.x - cb + cur.y;
101                 }
102                 else
103                 {
104                     tmp.y = cur.x+cur.y;
105                     tmp.x = 0;
106                 }
107                 tmp.word = &quot;pour A B&quot;;
108                 tmp.parent = &amp;cur;
109                 q.push(tmp);
110             }
111 
112             if (cur.y &gt; 0 &amp;&amp; cur.x &lt; ca)
113             {
114                 tmp = cur;
115                 // B have water and A has place to hold
116                 if (cur.y &gt;= ca-cur.x) // y more than capacity of A
117                 {
118                     tmp.x = ca;
119                     tmp.y = cur.y - ca + cur.x;
120                 }
121                 else
122                 {
123                     tmp.x = cur.x+cur.y;
124                     tmp.y = 0;
125                 }
126                 tmp.parent = &amp;cur;
127                 tmp.word = &quot;pour B A&quot;;
128                 q.push(tmp);
129             }
130         }
131     }
132     return 0 ;
133 }
</code></pre><ul>
<li>char 型迷宫定义成int型导致爆莫名奇妙的错误。</li>
</ul>
<h4 id="掉石头迷宫"><a href="#掉石头迷宫" class="headerlink" title="掉石头迷宫"></a>掉石头迷宫</h4><p>应该是迷宫状态更新的问题。 1.5小时</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;vector&gt;
  5 #include &lt;stack&gt;
  6 #include &lt;map&gt;
  7 #include &lt;string&gt;
  8 #include &lt;string.h&gt;
  9 #include &lt;algorithm&gt;
 10 #include &lt;math.h&gt;
 11 #include &lt;queue&gt;
 12 using namespace std;
 13 // 掉石头迷宫问题
 14 int t1;
 15 char a[9][9],t[9][9];
 16 struct point
 17 {
 18     int x,y,t;
 19 }s,e,tmp,cur;
 20 vector&lt;point&gt; stone;
 21 queue&lt;point&gt; q;
 22 void printa(char a[9][9])
 23 {
 24    for (int i=1;i&lt;=8;i++)
 25         {
 26             for (int j=1;j&lt;=8;j++)
 27                 cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
 28             cout &lt;&lt; endl;
 29         }
 30 }
 31 void flush(char a[9][9]) // 石头状态刷新一次
 32 {
 33   /*  int x1,y1;
 34     for (int i=0;i&lt;stone.size();i++)
 35     {
 36         x1 = stone[i].x;
 37         y1 = stone[i].y;
 38         a[x1][y1] = &#39;.&#39;;
 39         if (x1+1 &lt;=8) // 超出边界的石头则删除了
 40             a[x1+1][y1] = &#39;S&#39;;
 41     }
 42 
 43     */
 44     for (int i=1;i&lt;9;i++)
 45     {
 46         for (int j=1;j&lt;9;j++)
 47         {
 48             if (a[i][j] == &#39;S&#39;)
 49             {
 50                a[i+1][j] = &#39;S&#39;;
 51                a[i][j] = &#39;.&#39;;
 52             }
 53         }
 54     }
 55 
 56 }
 57 int dir[9][2] =
 58 {
 59 -1,0,
 60 -1,1,
 61 0,1,
 62 1,1,
 63 1,0,
 64 1,-1,
 65 0,-1,
 66 -1,-1,
 67 0,0
 68 };
 69 bool judge(point tmp)
 70 {
 71     if (tmp.x &lt; 1 || tmp.y &gt;8 || tmp.y &lt; 1 || tmp.y &gt; 8)
 72         return false;
 73     if (a[tmp.x][tmp.y] == &#39;S&#39; || t[tmp.x][tmp.y] == &#39;S&#39;) // 移动后所在位置有石头或移动后石头下落砸到自己
 74         return false;
 75     return true;
 76 }
 77 int main()
 78 {
 79     cin &gt;&gt; t1;
 80     bool flag;
 81     while (t1--)
 82     {
 83         flag = false;
 84         // 输入迷宫
 85         for (int i=1;i&lt;=8;i++)
 86         {
 87             for (int j=1;j&lt;=8;j++)
 88             {
 89                cin &gt;&gt; a[i][j]; t[i][j] = a[i][j];
 90             }
 91         }
 92 
 93         /* 存石头位置
 94         stone.clear();
 95         for (int i=1;i&lt;9;i++)
 96         {
 97             for (int j=1;j&lt;9;j++)
 98             {
 99                 if (a[i][j] == &#39;S&#39;)
100                 {
101                    tmp.x = i;tmp.y = j;
102                    stone.push_back(tmp);
103                 }
104             }
105         }
106         */
107         // 清空队列
108         while (!q.empty())
109             q.pop();
110         // 初始化队列
111         s.x = 8;s.y = 1;e.x = 1;e.y = 8;s.t = 0;
112         q.push(s);
113         while (!q.empty())
114         {
115             cur = q.front();q.pop();
116             if (cur.x == e.x &amp;&amp; cur.y == e.y)
117             {
118                 flag = true;
119                 break;
120             }
121             flush(t);  // t是移动后的a
122             printa(t);
123             for (int i=0;i&lt;9;i++)
124             {
125                 tmp = cur;
126                 tmp.x += dir[i][0];
127                 tmp.y += dir[i][1];
128                 tmp.t ++;
129                 if (judge(tmp))
130                 {
131                     q.push(tmp);
132                 }
133             }
134             flush(a);//a t 同步了
135             printa(a);
136 
137         }
138         if (flag)
139             cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
140         else
141             cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
142         getchar();
143     }
144     return 0 ;
145 }
</code></pre><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><h4 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 int fib(int n)
15 {
16     if (n==1 || n==2)
17         return 1;
18     else
19         return fib(n-1)+fib(n-2);
20 }
21 int main()
22 {
23     int n;
24     while (cin &gt;&gt; n)
25     {
26         cout &lt;&lt; fib(n) &lt;&lt; endl;
27     }
28     return 0 ;
29 }
</code></pre><ul>
<li>n &lt;= 30 最简单的递归，内存超限： 大量的重复的计算</li>
<li>方法：通过空间的损耗来提高计算的速度，一维数组DP记录每个数的数值，未计算过则设置为-1。</li>
<li><strong>记忆化搜索</strong> 每个数仅算一遍</li>
</ul>
<pre><code> 1 #include  &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 int dp[32];
15 int fib(int n)
16 {
17     if (n==1 || n==2) // 递归边界
18     {
19        return 1;
20     }
21     if (dp[n]!=-1)
22         return dp[n]; // 先判断我们的缓存里面有没有，有的话直接取出否则递归计算
23     else
24     {
25         dp[n] = fib(n-1)+fib(n-2);
26         return dp[n];
27     }
28 
29 }
30 int main()
31 {
32     int n;
33     while (cin &gt;&gt; n)
34     {
35         for (int i=0;i&lt;32;i++) dp[i] = -1;
36         cout &lt;&lt; fib(n) &lt;&lt; endl;
37     }
38     return 0 ;
39 }
</code></pre><h4 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h4><p>？？？？？？？？？？？？？？？？？ 如何输出最大连续的子序列呢？</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 int dp[32];
15 bool flag[32];
16 int a[10001];
17 int main()
18 {
19     int n;
20     while (cin &gt;&gt; n)
21     {
22         for (int i=0;i&lt;n;i++) 
23         {cin &gt;&gt; a[i];flag[i] = false;}
24         dp[0] = a[0];
25 
26         for (int i=1;i&lt;n;i++)
27         {
28             dp[i] = max(a[i],dp[i-1]+a[i]);
29         }
30 
31 
32 
33 
34     }
35     return 0 ;
36 }





 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 int dp[32];
15 bool flag[32][32];
16 int a[10001];
17 int main()
18 {
19     int n;
20     while (cin &gt;&gt; n)
21     {
22         for (int i=0;i&lt;n;i++)
23         {cin &gt;&gt; a[i];}
24         for (int i=0;i&lt;32;i++)
25         {
26             for (int j=0;j&lt;32;j++)
27                 flag[i][j] = false;
28         }
29         dp[0] = a[0]; flag[0][0] = true;
30 
31         for (int i=1;i&lt;n;i++)
32         {
33             dp[i] = max(a[i],dp[i-1]+a[i]);
34             if (dp[i] == a[i])
35             {
36                 flag[i][i] = true;
37             }
38             else
39             {
40                 for (int x=0;x&lt;i;x++)
41                     flag[i][x] = flag[i-1][x];
42                 flag[i][i] = true;
43             }
44         }
45         int k = 0;
46         int max = dp[0];
47         for (int i=1;i&lt;n;i++)
48         {
49             if (dp[i] &gt; max)
50             {
51                 max = dp[i]; k = i;
52             }
53         }
54         for (int i=0;i&lt;n;i++)
55         {
56             if (flag[k][i])
57                 cout &lt;&lt; a[i] &lt;&lt;&quot; &quot;;
58         }
59 
60 
61 
62 
63 
64     }
65     return 0 ;
66 }
</code></pre><ul>
<li>运行错误？ 还是格式错误？</li>
</ul>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p><a href="http://codeup.cn/problem.php?cid=100000627&amp;pid=0" target="_blank" rel="noopener">http://codeup.cn/problem.php?cid=100000627&amp;pid=0</a></p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 
15 int main()
16 {
17     int n;
18     int dp[32];
19     int a[10001];
20     while (cin &gt;&gt; n)
21     {
22         for (int i=0;i&lt;n;i++)
23         {cin &gt;&gt; a[i];dp[i] = 1;}
24 
25 
26         for (int i=1;i&lt;n;i++)
27         {
28             for (int j=0;j&lt;i;j++)
29             {
30                 if (a[j] &lt; a[i])
31                 {
32                     dp[i] = max(dp[i],dp[j]+1);
33                 }
34             }
35         }
36         sort(dp,dp+n);
37         cout &lt;&lt; dp[n-1] &lt;&lt; endl;
38 
39 
40     }
41     return 0 ;
42 }







 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 const int maxn = 200001;
15 int a[maxn];
16 int n;
17 int dp[maxn];
18 int main()
19 {
20     while (cin&gt;&gt;n)
21     {
22         for (int i=0;i&lt;n;i++)
23              cin &gt;&gt; a[i];
24         dp[0] = 1;
25         int ans = 0; // 最大dp值的下标
26         for (int i=1;i&lt;n;i++)
27         {
28             for (int j=0;j&lt;i;j++)
29             {
30                 if (a[j] == a[i]-1)
31                 {
32                     dp[i] = max(dp[i],dp[j]+1); // 找到最大的
33                 }
34             }
35             if (dp[i] &gt; dp[ans])
36             {
37                 ans = i;
38             }
39         }
40         cout &lt;&lt; dp[ans] &lt;&lt; endl;
41         vector&lt;int&gt; p;p.clear();
42         for (int i = ans,j=0;i&gt;=0;i--)
43         {
44             if (a[i] == a[ans]-j)
45             {
46                p.push_back(i);j++;
47             }
48 
49         }
50         for (int i=p.size()-1;i&gt;0;i--)
51             cout &lt;&lt; p[i]+1 &lt;&lt;&quot; &quot;;
52         cout &lt;&lt; p[0]+1 &lt;&lt; endl;
53 
54     }
55 
56     return 0 ;
57 }
</code></pre><p>time limited 超时了！</p>
<p>用map存储：</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 const int maxn = 200001;
15 int a[maxn];
16 int n;
17 int dp[maxn];
18 map&lt;int,int&gt; m;
19 int main()
20 {
21     while (cin&gt;&gt;n)
22     {
23         m.clear();
24         for (int i=0;i&lt;=n;i++)
25             m[i] = 0;
26         for (int i=1;i&lt;=n;i++)
27         {
28             cin &gt;&gt; a[i];
29             m[a[i]] = m[a[i]-1]+1;
30         }
31         int ans = 0,k=0;
32         map&lt;int,int&gt;::iterator it;
33         for (it = m.begin();it !=m.end();it++)
34         {
35             if (it-&gt;second &gt; ans)
36             {
37                 ans = it-&gt;second;
38                 k = it-&gt;first;
39             }
40         }
41         int pos = k - ans + 1;
42         cout &lt;&lt; ans &lt;&lt; endl;
43         for (int i=1;i&lt;=n&amp;&amp;pos &lt;= k;i++ )
44         {
45             if (a[i] == pos)
46             {
47                 cout &lt;&lt; i &lt;&lt;&quot; &quot;;
48                 pos++;
49             }
50         }
51 
52 
53 
54     }
55 
56     return 0 ;
57 }
</code></pre><h4 id="非常可乐"><a href="#非常可乐" class="headerlink" title="非常可乐"></a>非常可乐</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;vector&gt;
  5 #include &lt;stack&gt;
  6 #include &lt;map&gt;
  7 #include &lt;string&gt;
  8 #include &lt;string.h&gt;
  9 #include &lt;algorithm&gt;
 10 #include &lt;math.h&gt;
 11 #include &lt;queue&gt;
 12 using namespace std;
 13 
 14 int coco,n,m;
 15 struct status
 16 {
 17     int a,b,c,d;
 18 }s,cur,tmp;
 19 queue&lt;status&gt; q;
 20 const int maxn = 101;
 21 int v[maxn][maxn][maxn];
 22 void pour(int a,int b,int c,int d)
 23 {
 24     if (!v[a][b][c])
 25     {
 26         v[a][b][c] = 1;
 27         tmp.a = a;
 28         tmp.b = b;
 29         tmp.c = c;
 30         tmp.d = d+1; // 未出现的状态才倒水，并加入队列
 31         q.push(tmp);
 32     }
 33 }
 34 int bfs(int a,int b,int c,int d) // d为倒水次数,a,b,c为杯中可乐量
 35 {
 36     while (!q.empty()) q.pop();
 37     s.a = coco;s.b = s.c = s.d = 0; // 初始状态
 38     q.push(s);
 39     v[coco][0][0] = 1; // 该状态已入队过，为防止重复入队
 40     while (!q.empty())
 41     {
 42         cur = q.front();q.pop();
 43         if ((cur.a == coco/2 &amp;&amp; cur.b == coco/2 )||(cur.a == coco/2 &amp;&amp; cur.c == coco/2 ) || (cur.b == coco/2 &amp;&amp; cur.c == coco/2 ) )
 44             return cur.d;
 45         //s-&gt;n:
 46         if (cur.a &gt; 0 &amp;&amp; cur.b &lt; n) // a has coco and b is not full
 47             pour(cur.a - n + cur.b, n, cur.c, cur.d);
 48         //s-&gt;m;
 49         if ( cur.a &gt; 0 &amp;&amp; cur.c &lt; m)
 50             pour(cur.a - m + cur.c, cur.b, m, cur.d);
 51         //n-&gt;s;
 52         if (cur.b &gt; 0 &amp;&amp; cur.a &lt; coco)
 53             pour(cur.a + cur.b, 0, cur.c, cur.d);
 54         //m-&gt;s;
 55         if (cur.c &gt; 0 &amp;&amp; cur.a &lt; coco )
 56             pour(cur.a + cur.c, cur.b, 0, cur.d);
 57         //n-&gt;m
 58         if (cur.b &gt; 0 &amp;&amp; cur.c &lt; m)
 59         {
 60           if(cur.b &gt; m - cur.c)
 61             pour(cur.a, cur.b - m + cur.c, m, cur.d);
 62           else
 63             pour(cur.a, 0, cur.b + cur.c, cur.d);
 64         }
 65 
 66         //m-&gt;n
 67         if (cur.c &gt; 0 &amp;&amp; cur.b &lt; n)
 68         {
 69             if(cur.c &gt; n - cur.b)
 70                 pour(cur.a, n, cur.c - n + cur.b, cur.d);
 71             else
 72                 pour(cur.a, cur.b + cur.c, 0, cur.d);
 73         }
 74 
 75     }
 76     return 0;
 77 }
 78 int main()
 79 {
 80     int ans;
 81     while (cin&gt;&gt;coco&gt;&gt;n&gt;&gt;m)
 82     {
 83         memset(v,0,sizeof(int)*maxn*maxn*maxn);
 84         if (coco==0)
 85             break;
 86         if (coco%2 == 1)
 87         {
 88             cout&lt;&lt; &quot;NO&quot; &lt;&lt; endl;continue;
 89         }
 90         ans = bfs(coco,0,0,0);
 91         if ( ans &gt; 0)
 92         {
 93             cout &lt;&lt; ans &lt;&lt; endl;
 94         }
 95         else
 96             cout&lt;&lt; &quot;NO&quot; &lt;&lt; endl;
 97     }
 98 
 99 
100     return 0 ;
101 }
</code></pre><h4 id="导弹拦截系统：最长不降子序列"><a href="#导弹拦截系统：最长不降子序列" class="headerlink" title="导弹拦截系统：最长不降子序列"></a>导弹拦截系统：最长不降子序列</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;stack&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #include &lt;algorithm&gt;
10 #include &lt;math.h&gt;
11 #include &lt;queue&gt;
12 using namespace std;
13 
14 const int maxn = 1001;
15 int main()
16 {
17     int n;
18     int a[maxn];
19     int dp[maxn]; // 以I为结尾的不降子序列的长度
20     while (cin&gt;&gt;n)
21     {
22         for (int i=0;i&lt;n;i++)
23         {
24            cin &gt;&gt; a[i]; dp[i] = 1;
25         }
26         int ans = 1;
27         for (int i=1;i&lt;n;i++)
28         {
29             for (int j=0;j&lt;i;j++)
30             {
31                 if (a[j] &lt; a[i])
32                 {
33                     dp[i] = max(dp[j]+1,dp[i]);
34                 }
35             }
36             if (dp[i] &gt; ans)
37                 ans = dp[i];
38         }
39         cout &lt;&lt;ans&lt;&lt; endl;
40 
41 
42 
43     }
44     return 0 ;
45 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（九）——搜索（百鸡问题、ABC、胜利大逃亡、迷宫问题、C翻转、旋转矩阵、字符串匹配、）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（九）——搜索（百鸡问题、ABC、胜利大逃亡、迷宫问题、C翻转、旋转矩阵、字符串匹配、）/">计算机考研机试指南（九）——搜索（百鸡问题、ABC、胜利大逃亡、迷宫问题、C翻转、旋转矩阵、字符串匹配、）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（九）——搜索（百鸡问题、ABC、胜利大逃亡、迷宫问题、C翻转、旋转矩阵、字符串匹配、）/" class="article-date">
  <time datetime="2018-08-20T17:56:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试指南-cha6-搜索"><a href="#机试指南-cha6-搜索" class="headerlink" title="机试指南 cha6 搜索"></a>机试指南 cha6 搜索</h3><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><h4 id="百鸡问题"><a href="#百鸡问题" class="headerlink" title="百鸡问题"></a>百鸡问题</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #define INFINITY 65535
 9 using namespace std;
10 
11 const int big = 5;
12 const int mid = 3;
13 const float small = 1/3;
14 int main()
15 {
16     int n,x,y,z;
17     while (cin&gt;&gt;n)
18     {
19         for (x = 0;x&lt;=n/big;x++ )
20             for (y=0;y&lt;=n/mid;y++)
21                 for (z=0;z&lt;=100;z++)
22             {
23                 float tmp = big*x+mid*y+(float)z/3;
24                 if (x+y+z == 100 &amp;&amp;  tmp &lt;= n)
25                 {
26                     cout &lt;&lt; &quot;x=&quot;&lt;&lt;x&lt;&lt;&quot;,y=&quot;&lt;&lt;y&lt;&lt;&quot;,z=&quot;&lt;&lt;z&lt;&lt;endl;
27                 }
28             }
29     }
30 
31     return 0 ;
32 
</code></pre><p>}</p>
<h4 id="abc"><a href="#abc" class="headerlink" title="abc"></a>abc</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #define INFINITY 65535
 9 using namespace std;
10 
11 const int num = 532;
12 int cal(int a,int b,int c)
13 {
14     return 100*a+10*b+c;
15 }
16 int main()
17 {
18         int a,b,c;
19         for (a = 0;a&lt;=9;a++ )
20             for (b=0;b&lt;=9;b++)
21                 for (c=0;c&lt;=9;c++)
22             {
23                 int tmp = cal(a,b,c)+cal(b,c,c);
24                 if (tmp == num)
25                 {
26                     cout &lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;
27                 }
28             }
29 
30 
31     return 0 ;
32 }
</code></pre><h4 id="广搜"><a href="#广搜" class="headerlink" title="广搜"></a>广搜</h4><h4 id="胜利大逃亡"><a href="#胜利大逃亡" class="headerlink" title="胜利大逃亡"></a>胜利大逃亡</h4><p>&gt;<br>提示内存不够：定义时不能多开辟数组空间，形成六面的”墙”，而是要判断是否超出边界的方式；提示运行时间过长，在把孩子结点加入队列后就立即判断是否是终止结点，而不是等到从队列中拿出的时候判断。这道题目的遗憾是1：自己通过思考做的方法就差一点巧妙的构思即可在本地通过编译；2.<br>牛客网的编译还是过不去，运行时间过长，不知道哪里的错误。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #define INFINITY 65535
 9 using namespace std;
10 struct node
11 {
12     int x,y,z;
13     int t;
14 };
15 int room[50][50][50];
16 bool mark[50][50][50];
17 queue&lt;node&gt; q;
18 
19 int dir[6][3] =
20 {
21     {0,0,1},{0,1,0},{0,0,-1},{0,-1,0},{1,0,0},{-1,0,0}
22 };
23 int mazePath(node s,node &amp;e,int a,int b,int c)
24 {
25     node t,child;
26     q.push(s); // 放入初始结点
27     while (!q.empty())
28     {
29         t = q.front(); q.pop();//队头出队
30         room[t.x][t.y][t.z] = 1; // 已经访问过则不再访问
31 
32         // 当前节点不为最终节点时，把当前节点的孩子结点入队
33         for (int i=0;i&lt;6;i++)
34         {
35             child = t;
36             child.x += dir[i][0];
37             child.y += dir[i][1];
38             child.z += dir[i][2];
39             // 下一个结点为墙
40             if (room[child.x][child.y][child.z] == 1)
41                 continue;
42             // 超出迷宫边界
43             if (child.x &lt; 0|| child.x &gt;=a || child.y &lt; 0|| child.y &gt;=b || child.z &lt; 0|| child.z &gt;=c)
44                 continue;
45             // 包含该坐标的状态已经被得到过，则丢弃
46             if (mark[child.x][child.y][child.z] == true)
47                 continue;
48             child.t ++;
49             q.push(child);
50             mark[child.x][child.y][child.z] = true; // 标记
51             if (child.x == e.x &amp;&amp; child.y == e.y &amp;&amp; child.z == e.z)
52             {
53                 return child.t;
54             }
55 
56         }
57     }
58     return 0;
59 }
60 
61 int main()
62 {
63     int k,a,b,c,t,i,j,m,n;
64     node start,end,ex;
65     while (scanf(&quot;%d&quot;,&amp;k)!=EOF)
66     {
67         for (i=0;i&lt;k;i++)
68         {
69             scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;t);
70             for (j=0;j&lt;a;j++)
71                 for (m=0;m&lt;b;m++)
72                     for (n=0;n&lt;c;n++)
73                     {
74                         scanf(&quot;%d&quot;,&amp;room[j][m][n]);
75                         mark[j][m][n] = false; // 初始化为false
76                      }
77            // (1,1,1) - &gt; (a,b,c)
78            start.x = 0;start.y=0;start.z=0;
79            start.t = 0;
80            mark[0][0][0] = true;
81            end.x = a-1;end.y=b-1;end.z=c-1;
82           while (!q.empty())
83                 q.pop();
84           int ans = mazePath(start,end,a,b,c);
85           if (ans &lt;= t &amp;&amp; ans &gt; 0)
86             cout &lt;&lt; ans &lt;&lt; endl;
87           else
88             cout &lt;&lt; -1 &lt;&lt; endl;
89 
90 
91 
92         }
93     }
94     return 0 ;
95 }
</code></pre><h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><blockquote>
<p>严版数据结构课本的伪代码</p>
</blockquote>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;vector&gt;
  5 #include &lt;queue&gt;
  6 #include &lt;stack&gt;
  7 #include &lt;string&gt;
  8 using namespace std;
  9 
 10 // 迷宫求解
 11 
 12 
 13 // 结构体
 14 typedef struct
 15 {
 16     int x;
 17     int y;
 18     bool foot; // 是否走到过该通道
 19 }posType;
 20 
 21 typedef struct
 22 {
 23     int ord;//通道块在路径上的序号
 24     posType seat; // 通道块在迷宫中的坐标
 25     int di;// 从此通道块走向下一通道块的方向
 26 }elemType; // 栈的元素类型
 27 
 28 // 全局变量声明
 29 stack&lt;elemType&gt; s;
 30 int a[6][6];
 31 
 32 // 函数
 33 void footPrint(posType p)
 34 {
 35     p.foot = true;
 36 }
 37 
 38 bool pass(posType p)
 39 {
 40     // 不可通的含义：不是通道；不在当前路径上；不是纳入路径上的通道块
 41     if (a[p.x][p.y] == 1)
 42         return false;
 43     else return true;
 44 
 45 }
 46 
 47 posType nextPos(posType p,int d)
 48 {
 49     posType tmp;
 50     tmp.x = p.x+1;tmp.y = p.y+1;tmp.foot = p.foot;
 51     return tmp;
 52 }
 53 
 54 bool mazePath(int a[6][6],posType start,posType end)
 55 {
 56     // 将从start到end的通道路径存放在栈中,找到路径返回true，否则返回false
 57     while (!s.empty())
 58         s.pop(); // initStack()
 59     posType curpos = start; // 把坐标封装起来
 60     elemType e;
 61     int curstep = 1; // 探索第一步
 62     do {
 63         if (pass(curpos)) // 是未曾走到过的通道块
 64         {
 65             footPrint(curpos); // 留下足迹
 66             e = {curstep,curpos,1}; // 1,2,3,4代表东南西北
 67             s.push(e);
 68             if (curpos == end)
 69                 return true;
 70             curpos = nextPos(curpos,1);
 71             curstep++;
 72         }else {
 73         if (!s.empty())// 当前位置不能通过
 74         {
 75            e = s.top();s.pop();
 76            while (e.di == 4 &amp;&amp; !s.empty())
 77            {
 78                markPrint(e.seat);//留下不能通过的标记
 79                s.pop();
 80 
 81            }
 82            if (e.di &lt; 4)
 83            {
 84                e.di++;
 85                s.push(e);
 86                curpos = nextPos(e.seat,e.di);
 87            }
 88         }
 89         }
 90     }while (!s.empty());
 91     return false;
 92 
 93 }
 94 int main()
 95 {
 96     int n,m,i,j;
 97     posType start,end;
 98     while (cin&gt;&gt;n&gt;&gt;m)
 99     {
100         for (i=0;i&lt;=5;i++)
101             for (j=0;j&lt;=5;j++)
102             {
103                 if (i==0||j==0)
104                     a[i][j] = 1;
105                 else
106                     cin &gt;&gt; a[i][j];
107             }
108         // (1,1) -&gt; (5,5) 最短路径 输出坐标
109         end.x = 5;end.y=5;end.foot = false;
110         start.x = 1;start.y=1;start.foot = false;
111         mazePath(a,start,end);
112 
113 
114     }
115     return 0 ;
116 }
</code></pre><blockquote>
<p>深搜</p>
</blockquote>
<pre><code> 1 #include&lt;iostream&gt;
 2 #include&lt;string&gt;
 3 #include&lt;list&gt;
 4 #define M 8
 5 #define N 8
 6 using namespace std;
 7 
 8 /*
 9 每次按照dir的方向进行深度优先搜索，可以走则走并标记，否则，
10 回溯并清除标记，直到找到右下角的出口。
11 */
12 
13 // 迷宫，Maze[i][j] = 0 代表ij可以走, arr[i][j]=1表示不能走
14 int Maze[M+2][N+2] = {
15         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
16         {1, 0, 0, 0, 1, 1, 0, 1, 1, 1},
17         {1, 1, 1, 0, 1, 1, 0, 1, 1, 1},
18         {1, 1, 0, 0, 0, 0, 0, 1, 1, 1},
19         {1, 1, 0, 0, 1, 1, 1, 0, 0, 1},
20         {1, 1, 0, 0, 0, 0, 0, 0, 0, 1},
21         {1, 1, 0, 1, 0, 1, 0, 0, 1, 1},
22         {1, 0, 0, 1, 1, 1, 0, 0, 0, 1},
23         {1, 1, 1, 1, 1, 1, 1, 1, 0, 1},
24         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
25 };
26 
27 // 四个方向，分别代表上，下，左，右，这里注意x和y的方向和笛卡尔坐标系的方向相反
28 int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
29 
30 // 节点信息，x代表横坐标，y代表纵坐标
31 struct Node
32 {
33     int x;
34     int y;
35     // 初始化位置结点的构造函数
36     Node (int x1, int y1){
37     x = x1;y=y1;
38     }
39 };
40 
41 
42 // 打印路径，使用链表，易于输出
43 void print_path(list&lt;Node&gt; path)
44 {
45     while(!path.empty())
46     {
47         cout &lt;&lt; &quot;(&quot; &lt;&lt; path.front().x &lt;&lt; &quot;,&quot; &lt;&lt; path.front().y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
48         path.pop_front(); // front()求链表头，pop_front()弹头，我感觉用vector也可以
49     }
50 }
51 
52 int DFS(Node cur, Node end, list&lt;Node&gt; &amp;path) // 当前节点，出口
53 {
54     Maze[cur.x][cur.y] = 1;     // 标记此节点已走过，设置为墙1
55     path.push_back(cur);        // 将当前节点加入路径栈
56 
57     // 当前坐标等于结束坐标时结束遍历，并打印路径
58     if(cur.x == end.x &amp;&amp; cur.y == end.y)
59     {
60         print_path(path);       //打印路径
61         return 1;
62     }
63 
64     // 从4个方向分别探索
65     for(int i = 0; i &lt; 4; ++i)
66     {
67         // 构造下一个要进行探索的点
68         Node next(cur.x + dir[i][0], cur.y + dir[i][1]);
69         //  判断下个点是否可行
70         if(Maze[next.x][next.y] == 0)
71         {
72             // 递归进行下一位置的查找
73             // 如果一直可以先向下查找，直到找到终点，最底层函数就会返回1，接着返回到倒数第二层，执行if语句，接着返回1。
74             // 直到跳出整个递归函数。
75             if(DFS(next, end, path) == 1)
76                 return 1;
77         }
78     }
79 
80     // 如果该节点几个方向均已遍历，而且都不可行，该节点出栈，回溯
81     path.pop_back();
82 
83     return 0;
84 }
85 
86 int main( )
87 {
88     list&lt;Node&gt; path;          // 存取路径，使用双向链表存储，Node为位置结点
89     Node sta(1, 1), end(8, 8);  // 记录开始和结束坐标
90 
91     if(DFS(sta, end, path) == 0)
92         cout &lt;&lt; &quot;no path&quot; &lt;&lt; endl;
93 }
</code></pre><blockquote>
<p>广搜</p>
</blockquote>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;fstream&gt;
  3 #include &lt;stack&gt;
  4 #include &lt;vector&gt;
  5 #include &lt;queue&gt;
  6 using namespace std;
  7 
  8 const int MAX = 10;
  9 
 10 struct node {
 11     int x,y,fx,fy;
 12     int content;
 13     bool visited;
 14 };
 15 
 16 node laby[MAX][MAX];
 17 
 18 void BFS(int sx, int sy,int ex, int ey) {
 19 
 20     queue&lt;node&gt; myQueue;
 21 
 22     node temp = laby[sx][sy];
 23     myQueue.push(temp);
 24 
 25     int delx[4] = {0,0,-1,1};
 26     int dely[4] = {1,-1,0,0};
 27 
 28     while (!myQueue.empty()) {
 29         node currentNode = myQueue.front();
 30 
 31         myQueue.pop();
 32 
 33         int m = currentNode.x;
 34         int n = currentNode.y;
 35 
 36         currentNode.visited = true;
 37 
 38         if (currentNode.x == ex &amp;&amp; currentNode.y == ey) {
 39             break;
 40         }
 41 
 42         for(int i = 0; i &lt; 4;i++) {
 43             int next_m = m + delx[i];
 44             int next_n = n + dely[i];
 45             if (next_m &lt; 0 || next_m &gt;= MAX || next_n &lt; 0 || next_n &gt;= MAX) continue;
 46 
 47             if (laby[next_m][next_n].content != 1 &amp;&amp; laby[next_m][next_n].visited == false) {
 48                 laby[next_m][next_n].fx = m;
 49                 laby[next_m][next_n].fy = n;
 50                 myQueue.push(laby[next_m][next_n]);
 51                 laby[next_m][next_n].visited = true;
 52             }
 53         }
 54     }
 55 
 56     int backx = ex, backy = ey;
 57     int step = 0;
 58     stack&lt;node&gt; showStack;
 59 
 60     while (backx != sx || backy != sy) {
 61 
 62         showStack.push(laby[backx][backy]);
 63 
 64         int tempBackx = laby[backx][backy].fx;
 65         int tempBacky = laby[backx][backy].fy;
 66 
 67         backx = tempBackx;
 68         backy = tempBacky;
 69 
 70         step++;
 71     }
 72 
 73     cout&lt;&lt;&quot;Path:&quot;&lt;&lt;endl;
 74     while (!showStack.empty()) {
 75         node current = showStack.top();
 76         showStack.pop();
 77         cout&lt;&lt;&#39;(&#39;&lt;&lt;current.x&lt;&lt;&#39;,&#39;&lt;&lt;current.y&lt;&lt;&quot;) &quot;;
 78     }
 79     cout&lt;&lt;endl;
 80 
 81     cout&lt;&lt;&quot;total steps:&quot;&lt;&lt;step&lt;&lt;endl;
 82 }
 83 
 84 
 85 int main(int argc, const char * argv[]) {
 86 
 87     ifstream in;
 88     in.open(&quot;laby.txt&quot;,ios::in);
 89 
 90     if (!in) {
 91         cerr&lt;&lt;&quot;file not existed!&quot;&lt;&lt;endl;
 92         exit(1);
 93     }
 94 
 95     int sx,sy,ex,ey;
 96 
 97     int curNum;
 98     int m = 0, n = 0;
 99 
100     while (!in.eof()) {
101         in&gt;&gt;curNum;
102         laby[m][n].content = curNum;
103         laby[m][n].x = m;
104         laby[m][n].y = n;
105         laby[m][n].visited = false;
106         if (curNum == 5) {
107             sx = m;
108             sy = n;
109         }
110         if (curNum == 8) {
111             ex = m;
112             ey = n;
113         }
114         n ++;
115         if (n == MAX) {
116             n = 0;
117             m++;
118         }
119     }
120 
121     for(int i = 0; i &lt; MAX; i++) {
122         for(int j = 0; j &lt; MAX; j++) {
123             cout&lt;&lt;laby[i][j].content&lt;&lt;&quot; &quot;;
124         }
125         cout&lt;&lt;endl;
126     }
127     cout&lt;&lt;endl;
128 
129     BFS(sx, sy, ex, ey);
130     return 0;
131 }
</code></pre><blockquote>
<p>虚拟队列 求最短的路径</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;  
 2 #include &lt;vector&gt;  
 3 #include &lt;stack&gt;  
 4 #define M 8  
 5 #define N 8  
 6 
 7 using namespace std;  
 8 
 9 // 迷宫，Maze[i][j] = 0 代表ij可以走, arr[i][j]=1表示不能走  
10 int Maze[M+2][N+2] = {  
11         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},  
12         {1, 0, 0, 0, 1, 1, 0, 1, 1, 1},  
13         {1, 1, 1, 0, 1, 1, 0, 1, 1, 1},  
14         {1, 1, 0, 0, 0, 0, 0, 1, 1, 1},  
15         {1, 1, 0, 0, 1, 1, 1, 0, 0, 1},  
16         {1, 1, 0, 0, 0, 0, 0, 0, 0, 1},  
17         {1, 1, 0, 1, 0, 1, 0, 0, 1, 1},  
18         {1, 0, 0, 1, 1, 1, 0, 0, 0, 1},  
19         {1, 1, 1, 1, 1, 1, 1, 1, 0, 1},  
20         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}  
21 };  
22 
23 
24 // 节点信息，x代表横坐标，y代表纵坐标  
25 struct Node  
26 {  
27     int x;  
28     int y;  
29     Node (int x1, int y1):x(x1), y(y1) {}  
30 };  
31 
32 // 虚拟队列中的节点及其前驱信息  
33 struct QueueElem  
34 {  
35     int pre;        // 该节点入队时的前驱节点在虚拟队列中的位置  
36     Node node;  
37     QueueElem(Node node1, int pre1):node(node1), pre(pre1) {}  
38 };  
39 
40 void print_path(vector&lt;QueueElem&gt; &amp;que)  
41 {  
42     stack&lt;QueueElem&gt; s;  
43 
44     QueueElem qe = que.back();  
45     while(qe.pre != -1)  
46     {  
47         s.push(qe);  
48         qe = que[qe.pre];  
49     }  
50 
51     while(!s.empty())  
52     {  
53         qe = s.top();  
54         s.pop();  
55         cout &lt;&lt; &quot;(&quot; &lt;&lt; qe.node.x &lt;&lt; &quot;,&quot; &lt;&lt; qe.node.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;  
56     }  
57 }  
58 
59 
60 void maze_shortest(Node start, Node des)  
61 {  
62     int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  
63     vector&lt;QueueElem&gt; que;                  // 用于记录节点入队顺序  
64     int head = 0;                           // 用于指向队列头部  
65 
66     que.push_back(QueueElem(start, -1));    // 初始点入队，其前驱为-1  
67     while(head &lt; que.size())                // 当虚拟队列非空时  
68     {  
69         Node cur = que[head].node;  
70 
71         for(int i = 0; i &lt; 4; ++i)  
72         {  
73             Node next(cur.x + dir[i][0], cur.y + dir[i][1]);  
74 
75             if(Maze[next.x][next.y] == 0)   // 下一节点可走  
76             {  
77                 // 下一节点入队  
78                 que.push_back(QueueElem(next, head));  
79                 if(next.x == des.x &amp;&amp; next.y == des.y)  
80                 {  
81                     print_path(que);  
82                     return;  
83                 }  
84             }  
85         }  
86         head++;         // 虚拟出队  
87     }  
88 }  
89 
90 
91 int main()  
92 {  
93     Node start(1, 1), des(8, 8);    // 记录开始和结束坐标  
94 
95     maze_shortest(start, des);  
96 }  
</code></pre><h4 id="2018-5-16-搜索"><a href="#2018-5-16-搜索" class="headerlink" title="2018/5/16 搜索"></a>2018/5/16 搜索</h4><h3 id="迷宫问题-1"><a href="#迷宫问题-1" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p>&gt;<br>这道题做的时候是自己独立思考出来的，但最后却花了更多的时间在调试错误上面，这个OJ用了两个月了，为什么这么基础的问题还要不断的犯错误呢？但调试功底见长是真的，耗时长也是真的，所有的耗时长都是因为练习不够。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;stack&gt;
 5 #include &lt;queue&gt;
 6 using namespace std;
 7 
 8 struct node
 9 {
10     int x,y;
11 };
12 int a[12][12];
13 int dir[4][2] =
14 {// 东南西北
15     {0,1},{1,0},{0,-1},{-1,0}
16 };
17 queue&lt;node&gt; st;
18 void printPath();
19 int mazePath(node s,node e)
20 {
21     node next = s;
22     int ans ;
23     a[s.x][s.y] = 1;//表示该结点已经走过，记为墙
24     // 先判断当前节点是否为最终节点
25     if (s.x == e.x &amp;&amp; s.y == e.y)
26     {
27         printPath();
28        return 1;
29     }
30 
31     // 当前节点不等于最终节点,最理想的状态是一直往东走
32     for (int i=0;i&lt;4;i++)
33     {
34         // 向四个方向走一步，递归
35         next = s;
36         next.x += dir[i][0];
37         next.y += dir[i][1];
38         if (a[next.x][next.y] == 0){ // 能走通则压栈，继续走
39             st.push(next);
40             ans  = mazePath(next,e);
41             if (ans == 1)
42                 return 1;
43         }
44 
45     }
46     // 如果这一层的四个方向均走不通，出栈
47         st.pop();
48         return 0;
49 }
50 
51 void printPath()
52 {
53     node t;
54     while (!st.empty())
55     {
56         t = st.front();
57         cout &lt;&lt; &quot;(&quot; &lt;&lt; t.x-1&lt;&lt;&quot;,&quot;&lt;&lt;t.y-1&lt;&lt;&quot;)&quot;&lt;&lt;endl;
58         st.pop();
59     }
60 }
61 void printA(int n,int m)
62 {
63     for (int i=0;i&lt;=n;i++)
64     {
65         for (int j=0;j&lt;=m;j++)
66             cout &lt;&lt; a[i][j] &lt;&lt;&quot; &quot;;
67         cout &lt;&lt; endl;
68     }
69 
70 }
71 int main()
72 {
73     int n,m,i,j;
74     node start,end;
75     while (cin&gt;&gt;n&gt;&gt;m{
76 
77         for (i=0;i&lt;=n+1;i++)
78             for (j=0;j&lt;=m+1;j++)
79             {// 四周筑墙
80                 if (i==0||j==0 || i==(n+1) || j==(m+1))
81                     a[i][j] = 1;
82                 else
83                     cin &gt;&gt; a[i][j];
84             }
85         // (1,1) -&gt; (5,5) 最短路径 输出坐标
86         start.x = 1;start.y=1;
87         end.x = n;end.y=m;
88         while (!st.empty())
89             st.pop();
90         st.push(start);
91         mazePath(start,end);
92 }
93 
94 
95 
96     return 0 ;
97 }
</code></pre><h3 id="北航机试题"><a href="#北航机试题" class="headerlink" title="北航机试题"></a>北航机试题</h3><h4 id="C翻转"><a href="#C翻转" class="headerlink" title="C翻转"></a>C翻转</h4><blockquote>
<p>这是一道找规律的题目。temp数组的设置比较巧妙。<br> 原矩阵：<br> 1 2 3<br> 4 5 6<br> 7 8 9<br> 顺时针旋转：<br> 7 4 1<br> 8 5 2<br> 9 6 3<br> 数组i=0的变化：<br> 11 - 13<br> 12 - 23<br> 13 - 33<br> 数组i=1的变化：<br> 21 - 12<br> 22 - 22<br> 23 - 32<br> 数组i=3的变化<br> 31 - 11<br> 32 - 21<br> 33 - 31</p>
</blockquote>
<p>原矩阵：<br>1 2 3<br>4 5 6<br>7 8 9<br>逆时针旋转：<br>3 6 9<br>2 5 8<br>1 4 7<br>数组i=0的变化：<br>11 - 31<br>12 - 21<br>13 - 11<br>数组i=1的变化：<br>21 - 32<br>22 - 22<br>23 - 12<br>数组i=3的变化<br>31 - 33<br>32 - 23<br>33 - 13</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #define INFINITY 65535
 9 using namespace std;
10 
11 int a[6][6];
12 
13 void reverse(int op1,int op2,int x,int y)
14 {
15     // op1 : 1 顺时针 op2 :2为4个数，3为9个数， 以（x,y）为左上角翻转op2^2个数
16     int i,j,temp[op2+1][op2+1];
17     for (i=1;i&lt;=op2;i++)
18         for (j=1;j&lt;=op2;j++)
19     {
20         if (op1 == 1)
21         {
22             // 顺时针。按照一行一行从左到右的顺序，依次放入temp中转置后应该在的位置
23             temp[j][op2+1-i] = a[x+i-1][y+j-1];
24         }
25         else
26         {
27             temp[op2+1-j][i] = a[x+i-1][y+j-1];
28         }
29     }
30     // 现在temp数组中即为转置后的数组顺序，只要赋值到a中相应的位置并输出即可
31     for (i=x;i&lt;x+op2;i++)
32         for (j=y;j&lt;y+op2;j++)
33             a[i][j] = temp[i-x+1][j-y+1];
34 }
35 
36 int main()
37 {
38     int i,j,op1,op2,x,y;
39     for (i=1;i&lt;=5;i++)
40         for (j=1;j&lt;=5;j++)
41             cin &gt;&gt; a[i][j];
42     cin &gt;&gt; op1 &gt;&gt; op2 &gt;&gt; x &gt;&gt; y;
43     reverse(op1,op2,x,y);
44     for (i=1;i&lt;6;i++)
45     {
46         for (j=1;j&lt;6;j++)
47         {
48             cout &lt;&lt; a[i][j]&lt;&lt; &quot; &quot;;
49         }
50         cout &lt;&lt; endl;
51     }
52 
53 
54     return 0 ;
55 }
</code></pre><h4 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h4><p>&gt;<br>这道题我的第一个想法是：把第一个矩阵旋转四个角度，看得到的矩阵是否和第二个矩阵相等，但是这样太麻烦了！判断标准有两个，正确旋转结果相同或者存在一个错误旋转结果，则直接否定该种旋转方案。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #define INFINITY 65535
 9 using namespace std;
10 
11 int a[10][10],b[10][10];
12 int main()
13 {
14     int n,i,j;
15     bool flag[4] = {true,true,true,true};  // 0 90 180 270
16     cin &gt;&gt; n;
17     for (i=0;i&lt;n;i++)
18         for (j=0;j&lt;n;j++)
19             cin &gt;&gt; a[i][j];
20     for (i=0;i&lt;n;i++)
21         for (j=0;j&lt;n;j++)
22             cin &gt;&gt; b[i][j];
23 
24     for (i=0;i&lt;n;i++)
25         for (j=0;j&lt;n;j++)
26     {
27         // 对所有的a[i][j]进行判别
28         if (a[i][j] != b[i][j])
29             flag[0] = false;
30         if (a[i][j] != b[j][n-1-i])
31             flag[1] = false;
32         if (a[i][j] != b[n-1-i][n-1-j])
33             flag[2] = false;
34         if (a[i][j] != b[n-1-j][i])
35             flag[3] = false;
36     }
37 
38     for (i=0;i&lt;4;i++)
39         if (flag[i] == true)
40     {
41         cout &lt;&lt; i*90 &lt;&lt; endl;
42         return 0 ;
43     }
44     cout &lt;&lt; -1 &lt;&lt; endl;
45     return 0 ;
46 }
</code></pre><h4 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #include &lt;string.h&gt;
 9 #define INFINITY 65535
10 using namespace std;
11 
12 string a[1000];
13 string lower(string a)
14 {
15     for (int i=0;i&lt;a.length();i++)
16     {
17         if (a[i]&gt;= &#39;A&#39; &amp;&amp; a[i] &lt;= &#39;Z&#39;)
18             a[i] = a[i] - &#39;A&#39;+&#39;a&#39;;
19     }
20     return a;
21 }
22 void match(int n,string b)
23 {
24     for (int i=0;i&lt;n;i++)
25     {
26         if (lower(b) == lower(a[i]))
27         {
28           cout &lt;&lt; i+1 &lt;&lt; &quot; &quot; &lt;&lt; a[i]&lt;&lt;endl;
29         }
30     }
31 }
32 int main()
33 {
34     int n,i;
35     string b, m, tmp1, tmp2, new1;
36     while (cin&gt;&gt;n)
37     {
38         for (i=0;i&lt;n;i++)
39             cin &gt;&gt; a[i];
40         cin &gt;&gt; b;
41         // b中可以有一个模式匹配，中括号内的字符中的任意一个即可
42         int pos1 = b.find(&quot;[&quot;); // 找到返回索引，否则返回-1
43         int pos2 = b.find(&quot;]&quot;); // 找到返回索引，否则返回-1
44 
45         if (pos1 == -1 )
46         {
47             match(n,b);
48         }
49         else
50         {
51             m = b.substr(pos1+1,pos2-pos1-1);
52             tmp1 = b.substr(0,pos1);
53             tmp2 = b.substr(pos2+1,b.length()-pos2);
54             for (i=0;i&lt;m.length();i++)
55             {
56                 new1 = tmp1+m[i]+tmp2;
57                 match(n,new1);
58             }
59         }
60 
61 
62     }
63     return 0 ;
64 }
</code></pre><blockquote>
<p>通过率大概百分之18，题目描述地不太清楚。</p>
</blockquote>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（八）——图论（畅通工程、还是畅通工程、最短路、more is better、Freckles、legal or not、确定比赛名次、产生冠军、最短路径问题）" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（八）——图论（畅通工程、还是畅通工程、最短路、more is better、Freckles、legal or not、确定比赛名次、产生冠军、最短路径问题）/">计算机考研机试指南（八）——图论（畅通工程、还是畅通工程、最短路、more is better、Freckles、legal or not、确定比赛名次、产生冠军、最短路径问题）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（八）——图论（畅通工程、还是畅通工程、最短路、more is better、Freckles、legal or not、确定比赛名次、产生冠军、最短路径问题）/" class="article-date">
  <time datetime="2018-08-20T17:52:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试指南-cha-5-图论"><a href="#机试指南-cha-5-图论" class="headerlink" title="机试指南 cha 5 图论"></a>机试指南 cha 5 图论</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h4 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 /*
 9 并查集
10 畅通工程：所有顶点之间均可连通
11 time : 20+20+20
12 */
13 
14 int findroot(int v[],int a)
15 {
16     // 寻找根节点的过程中，如果不是根节点的直接孩子，则修改为其直接孩子
17     if (v[a] == -1)
18         return a;
19     else
20     {
21         int tmp = findroot(v,v[a]);
22         v[a] = tmp;
23         return tmp;
24     }
25 }
26 int main()
27 {
28     int m,n,x1,x2;
29     int i,l,r;
30     int v[1001] = {0}; // v[i] 代表第i个顶点对应的双亲节点
31     while (cin &gt;&gt; n &gt;&gt; m)
32     {
33         if (n == 0)
34             break;
35         for (int i = 1;i&lt;=n;i++)
36             v[i] = -1;
37         for (i = 0 ;i &lt; m;i++)
38         {
39             cin &gt;&gt; x1 &gt;&gt; x2;
40             // 根节点不同，即不在一个集合，则连通
41             l = findroot(v,x1);
42             r = findroot(v,x2);
43             if (l!=r)
44                 v[r] = l;
45 
46 
47         }
48         // 输入完了以后，相连的结点会在同一个集合中,计算有几个并查集，并查集-1即为新增路径条数
49         int count = 0 ;
50         for (i = 1;i&lt;=n;i++)
51         {
52             if (v[i] == -1)
53                 count ++;
54         }
55         cout &lt;&lt; count -1 &lt;&lt; endl;
56 
57     }
58     return 0;
59 }
</code></pre><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h4 id="还是畅通工程"><a href="#还是畅通工程" class="headerlink" title="还是畅通工程"></a>还是畅通工程</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 #include &lt;algorithm&gt;
 7 
 8 using namespace std;
 9 /*
10 最小生成树
11 time :
12 */
13 int v[1010];
14 int findroot(int a)
15 {
16     if (v[a] == -1)
17         return a;
18     else
19     {
20         int tmp = findroot(v[a]);
21         // 非根节点a直接和根相连
22         v[a] = tmp;
23         return tmp;
24     }
25 }
26 struct node
27 {
28   int a;
29   int b;
30   int w;
31 };
32 bool cmp(const node &amp;a,const node &amp;b)
33 {
34     return a.w &lt; b.w; // 从小到大
35 }
36 int main()
37 {
38     int n,a,b,w;
39     int i,l,r;
40     node node[5000],tmp;
41     int ans = 0;
42     while (cin &gt;&gt;n &amp;&amp; n!=0)
43     {
44         ans = 0;
45         for (int i = 1;i&lt;=n;i++)
46             v[i] = -1;
47         // 初始化node数组
48         for (i = 0;i&lt; n*(n-1)/2 ;i++)
49         {
50             cin &gt;&gt; a &gt;&gt;b &gt;&gt; w;
51             node[i].a =a;
52             node[i].b =b;
53             node[i].w =w;
54         }
55         sort(node,node+n*(n-1)/2,cmp); // 不是n条边！
56         for (i = 0;i&lt;n*(n-1)/2;i++)
57         {
58             tmp = node[i];
59             l = findroot(tmp.a);
60             r = findroot(tmp.b);
61             if (l!=r)
62             {
63                 v[r] = l; // 两个根节点集合合并
64                 ans += tmp.w;
65             }
66         }
67         cout &lt;&lt; ans &lt;&lt; endl;
68 
69     }
70 
71     return 0;
72 }
</code></pre><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 #include &lt;algorithm&gt;
 7 
 8 #define INFINITY 65515
 9 using namespace std;
10 /*
11 最短路径
12 time :
13 */
14 
15 int main()
16 {
17     int i,j,n,m;
18     int p[101][101];
19     while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n!=0 &amp;&amp; m != 0))
20     {
21         for (i = 1;i&lt;=n;i++)
22             for (j=1;j&lt;=n;j++)
23         {
24             if (i == j)
25                 p[i][i] = 0;
26             else
27                 p[i][j] = INFINITY;
28         }
29         for (i = 0 ;i &lt; m;i++)
30         {
31             int a,b,c;
32             cin &gt;&gt;  a&gt;&gt; b &gt;&gt; c;
33             p[a][b] = c;
34             p[b][a] = c;
35         }
36         for (int k = 1 ; k &lt;= n; k++)
37         {
38             for ( i = 1;i&lt;=n ; i++)
39                 for (j = 1 ;j&lt;=n ; j++)
40                     if ( i!=k &amp;&amp; j!= k &amp;&amp; (p[i][k] + p[k][j] &lt; p[i][j]))
41                     {
42                        p[i][j] = p[i][k] + p[k][j];
43                     }
44         }
45         cout &lt;&lt; p[1][n] &lt;&lt;endl;
46     }
47 
48     return 0;
49 }
</code></pre><h4 id="more-is-better"><a href="#more-is-better" class="headerlink" title="more is better"></a>more is better</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 #include &lt;algorithm&gt;
 7 
 8 using namespace std;
 9 // 求并查集的过程中在每个集合根节点中记录该集合的人数
10 
11 const int num = 100001;
12 int v[num]; // v[i] 为第i个节点的双亲节点
13 int sum[num];// sum[i]当且仅当v[i] == -1 时有效，数字代表该集合的人数
14 
15 int findroot(int a)
16 {
17     if (v[a] == -1)
18         return a;
19     else
20     {
21         int tmp = findroot(v[a]); // 递归得到根节点
22         v[a] = tmp;
23         return tmp;
24     }
25 }
26 int main()
27 {
28 
29     int n;
30     int a,b,i,r,l;
31     while ( cin&gt;&gt;n )
32     {
33         for (i = 1;i&lt;= num ; i++) // 这个地方不能设为2*n,因为如果n很大时，2*n可能会超过num
34         {
35             v[i] = -1; // 只知道N对好朋友，但不知道男孩的数目，最多为一对儿两个不同的男孩
36             sum[i] = 1;
37         }
38         for (i = 1 ;i &lt;= n ;i++)
39         {
40             cin &gt;&gt; a &gt;&gt; b;
41             l = findroot(a);
42             r = findroot(b);
43             if (l!=r)
44             {
45               v[l] = r;
46               sum[r] += sum[l] ;// 注意！合并集合时要把两个集合的sum值合并
47             }
48 
49         }
50         int max = 1;
51         for (i = 1;i&lt;=num;i++)
52         {
53             if (v[i] == -1 &amp;&amp; sum[i] &gt; max)
54             {
55                 max = sum[i];
56             }
57         }
58         cout &lt;&lt; max &lt;&lt;endl;
59     }
60 
61 
62     return 0;
63 }
</code></pre><h4 id="Freckles"><a href="#Freckles" class="headerlink" title="Freckles"></a>Freckles</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 #include &lt;algorithm&gt;
 7 
 8 using namespace std;
 9 const int num = 101;
10 int v[num]; // 点集合
11 struct edge
12 {
13     int v1,v2; // 每条边的两个端点均在v[num]中
14     float w;
15 }e[num*(num-1)/2]; // 边集合
16 
17 int findroot(int a)
18 {
19     if (v[a] == -1)
20         return a;
21     else
22     {
23         int tmp = findroot(v[a]); // 递归得到根节点
24         v[a] = tmp;
25         return tmp;
26     }
27 }
28 bool cmp(const edge &amp;a,const edge &amp;b)
29 {
30     return a.w &lt; b.w;
31 }
32 int main()
33 {
34     int n,i,j,l,r;
35     float dot[num][2],a,b;
36     float ans;
37     while (cin&gt;&gt;n)
38     {
39         for (i=1;i&lt;=n;i++)
40         {
41             v[i] = -1;
42             cin &gt;&gt; dot[i][0] &gt;&gt; dot[i][1] ;
43         }
44         // 初始化边edge数组,n个点有n(n-1)/2条边，进行二层循环
45         float ans;
46         int size = 1;
47         for (i = 1 ;i &lt;= n ;i++)
48         {
49             for (j = i+1 ; j &lt;= n ; j++)
50             {
51                 a = dot[i][0] - dot[j][0];
52                 b = dot[i][1] - dot[j][1];
53                 ans = sqrt(a*a + b*b);
54                 e[size].v1 = i;
55                 e[size].v2 = j;
56                 e[size++].w = ans;
57 
58             }
59         }
60         // sort(edge),合并并查集
61         sort(e+1,e+size,cmp);
62 //        for (i = 1 ;i&lt;4;i++)
63 //            cout &lt;&lt; e[i].w &lt;&lt; endl;
64         ans = 0;
65         // 从小权值边开始选择，每次要判断这条边的两个端点是否在同一个集合中
66         for (i = 1;i&lt;size;i++)
67         {
68             l = findroot(e[i].v1);
69             r = findroot(e[i].v2);
70             if (l!=r)
71             {
72                 v[l] = r;
73                ans += e[i].w;
74             }
75         }
76         printf(&quot;%.2f&quot;,ans);
77 
78     }
79     return 0;
80 }
</code></pre><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h4 id="legal-or-not"><a href="#legal-or-not" class="headerlink" title="legal or not"></a>legal or not</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 using namespace std;
 7 struct edge
 8 {
 9     int nextnode;
10 };
11 queue&lt;int&gt; q;
12 vector&lt;edge&gt; vex[100];
13 int visited[100];
14 
15 void findrudu(int n)
16 {
17     // 找到入度为0的点（未在邻接表右侧链中出现的点），放到队列中
18     int i,a;
19     bool rudu[100];
20     for (i = 0;i&lt;100;i++)
21         rudu[i] = true;
22         // 一个再细微不过的知识点，都有可能成为决定成败的事情！
23     for (i = 0;i&lt;n;i++)
24     {
25         for (vector&lt;edge&gt;::iterator it = vex[i].begin() ; it != vex[i].end() ; it++)
26         {
27             a = (*it).nextnode;
28             rudu[a] = false;
29         }
30     }
31 
32     for (i = 0;i&lt;n;i++)
33     {
34       //  cout &lt;&lt; rudu[i] &lt;&lt;&#39; &#39; &lt;&lt; visited[i] &lt;&lt; endl;
35         if (rudu[i]&amp;&amp;visited[i]){
36             q.push(i);
37         }
38     }
39 }
40 int main()
41 {
42     int n,m,i,a,b;
43     edge e;
44     vector&lt;edge&gt;::iterator it;
45     // i 为顶点 ， vex[i][0]为与该顶点相邻接的第一条弧的弧头顶点，vex[i] 为一个向量,记录与该顶点邻接的所有弧的弧头顶点
46     while (cin &gt;&gt; n &gt;&gt; m)
47     {
48         if (m==0&amp;&amp;n==0)
49             break;
50         // 初始化vector
51         for (i = 0;i&lt;n;i++)
52         {
53             vex[i].clear();
54             visited[i] = true;
55         }
56         // 初始化队列
57         while (!q.empty())
58             q.pop();
59 
60         for (i = 0;i&lt;m;i++)
61         {
62             cin &gt;&gt; a &gt;&gt; b; // a-&gt;b为一条弧
63             e.nextnode = b;
64             vex[a].push_back(e);
65         }
66         findrudu(n);
67         while (!q.empty())
68         {
69             a = q.front();// 从队列中取出一个入度为0的结点
70             q.pop();
71             vex[a].erase(vex[a].begin(),vex[a].end());// 删除所有的弧
72             visited[a] = false;
73             findrudu(n);
74         }
75         // 如果队列为空时仍旧有顶点为true，则存在环
76         bool flag = true;
77         for (i = 0;i&lt;n;i++ )
78             if (visited[i])
79             {
80                 flag = false;
81             }
82         if (flag)
83             cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
84         else
85             cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
86 
87 
88 
89     }
90     return 0 ;
91 }
</code></pre><blockquote>
<p>太蠢的做法！结果超时了，完全可以第一次统计每个结点的入度，然后每次删除节点时对该入度数组进行- 操作，用bool真的太蠢了！而且这道题墨迹了一整个下午！<br>以后半小时内做不出来就研究答案！一道题目不要超过1个半小时！</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 using namespace std;
 7 
 8 queue&lt;int&gt; q;
 9 vector&lt;int&gt; vex[100];
10 
11 
12 int main()
13 {
14     int n,m,i,a,b;
15     vector&lt;int&gt;::iterator it;
16     int degree[100];
17     // i 为顶点 ， vex[i][0]为与该顶点相邻接的第一条弧的弧头顶点，vex[i] 为一个向量,记录与该顶点邻接的所有弧的弧头顶点
18     while (cin &gt;&gt; n &gt;&gt; m)
19     {
20         if (m==0&amp;&amp;n==0)
21             break;
22         // 初始化vector和degree数组
23         for (i = 0;i&lt;n;i++)
24         {
25             vex[i].clear();
26             degree[i] = 0;
27         }
28         // 初始化队列
29         while (!q.empty())
30             q.pop();
31         for (i = 0;i&lt;m;i++)
32         {
33             cin &gt;&gt; a &gt;&gt; b; // a-&gt;b为一条弧
34             vex[a].push_back(b);
35             // 增加b的入度
36             degree[b] ++;
37         }
38         for (i = 0;i&lt;n;i++)
39         {
40             if (degree[i] == 0)
41                 q.push(i);
42         }
43         int c = 0; // 计数器，用来确定已经被删除的结点的个数，或者用bool数组，但bool数组还得遍历
44         while (!q.empty())
45         {
46             a = q.front();// 从队列中取出队首
47             q.pop(); // 删除队首
48             c ++;
49             for (it = vex[a].begin();it != vex[a].end() ; it++)
50             {
51                 // 将待删除节点的邻接点的入度--，如果该邻接点成为入度为0的点，入队
52                 degree[*it] -- ;
53                 if (degree[*it] == 0)
54                     q.push(*it);
55             }
56             vex[a].erase(vex[a].begin(),vex[a].end());// 删除所有的邻接顶点
57 
58         }
59 
60         if (c == n)
61             cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
62         else
63             cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
64 
65 
66 
67     }
68     return 0 ;
69 }
</code></pre><ul>
<li>另一种遍历vector的方法</li>
<li>for (int i = 0;i</li>
</ul>
<h4 id="确定比赛名次-30min"><a href="#确定比赛名次-30min" class="headerlink" title="确定比赛名次 30min"></a>确定比赛名次 30min</h4><blockquote>
<p>和上面那道题比起来，只需要每次pop（）之前或之后输出结点数据。而且并不需要erase掉被选中结点的链表，因为我们看的是被push进queue的结点。</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 using namespace std;
 7 
 8 vector&lt;int&gt; vex[501];
 9 struct cmp{
10     bool operator() (const int &amp;a, const int&amp; b ){
11         return a &gt; b;
12     }
13 };
14 priority_queue&lt;int, vector&lt;int&gt;, cmp &gt; q;
15 int degree[501];
16 // 如何保证号小的先被选中？优先队列！
17 int main()
18 {
19   int n,m,i,a,b;
20   while (cin&gt;&gt;n&gt;&gt;m)
21   {
22       // 初始化
23       for (i=1;i&lt;=n;i++)
24       {
25           vex[i].clear();
26           degree[i] = 0;
27       }
28       // queue 没有 clear()方法，故需要循环pop()数据
29       while (!q.empty())
30         q.pop();
31 
32       for (i = 0;i&lt;m;i++)
33       {
34           cin &gt;&gt; a &gt;&gt; b;
35           vex[a].push_back(b);
36           degree[b]++;
37       }
38       for (i=1;i&lt;=n;i++)
39         if (degree[i] == 0)
40           q.push(i);
41       bool flag = true;
42       while (!q.empty())
43       {
44           a = q.top();// 选取队尾元素
45           q.pop();
46           if (flag)
47           {
48               flag = false;
49               cout &lt;&lt; a;
50           }else
51           cout &lt;&lt; &#39; &#39; &lt;&lt; a;
52           for (i=0;i&lt;vex[a].size();i++)
53           {
54               b = vex[a][i];
55               if ((--degree[b])==0)
56                 q.push(b);
57           }
58       }
59       cout &lt;&lt; endl;
60   }
61     return 0 ;
62 }
</code></pre><h4 id="产生冠军"><a href="#产生冠军" class="headerlink" title="产生冠军"></a>产生冠军</h4><blockquote>
<p>没调过，已经调了一个小时了，附带上正确答案</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 using namespace std;
 9 
10 vector&lt;int&gt; vex[10000];
11 int degree[10000];
12 queue&lt;int&gt; q;
13 int main()
14 {
15     int i,n,count,a;
16     string s1,s2;
17     map&lt;string,int&gt; m; // 映射
18     map&lt;string,int&gt;::iterator it;
19     while (cin&gt;&gt;n &amp;&amp; n!=0)
20     {
21         count =0;
22         for (i=0;i&lt;1000;i++)
23         {
24             vex[i].clear();
25             degree[i] = 0;
26         }
27         for (i=0;i&lt;n;i++)
28         {
29             // 难点：把名字和数组的i进行映射，不知道具体的队员个数
30             cin &gt;&gt;s1&gt;&gt;s2;
31             if (m.find(s1) == m.end())
32                 m.insert(pair&lt;string,int&gt;(s1,count++));
33             if (m.count(s2)==0)
34                 m.insert(pair&lt;string,int&gt;(s2,count++));
35             vex[m[s1]].push_back(m[s2]);
36             degree[m[s2]]++;
37             // 如果插入的字符串已经出现过了则不会执行该条语句的啦！名字和索引的映射成功！
38 //            for (it = m.begin() ; it!=m.end();it++)
39 //                cout &lt;&lt; (*it).first &lt;&lt; &quot; : &quot; &lt;&lt; (*it).second &lt;&lt; endl;
40         }
41         // !!!!!!
42         m.clear();
43         while (!q.empty())
44             q.pop();
45 
46         for (i=0;i&lt;m.size();i++)
47             if (degree[i] == 0)
48                 q.push(i);
49         int cnt = 0;
50         while (!q.empty())
51         {
52             a = q.front();
53             q.pop();
54             cnt ++;
55             for (i=0;i&lt;vex[a].size();i++)
56             {
57                 if ((--degree[vex[a][i]])==0)
58                     q.push(vex[a][i]);
59             }
60         }
61         if (cnt == 1)
62             cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
63         else
64             cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
65     }
66     return 0 ;
67 }
</code></pre><blockquote>
<p>正确答案：</p>
</blockquote>
<pre><code> 1 #include &lt;stdio.h&gt;
 2 #include &lt;string.h&gt;
 3 #include &lt;string&gt;
 4 #include &lt;algorithm&gt;
 5 #include &lt;vector&gt;
 6 #include &lt;queue&gt;
 7 #include &lt;iostream&gt;
 8 #include &lt;map&gt;
 9 using namespace std;
10 map&lt;string,int&gt; name;
11 vector&lt;int&gt; edge[10000];
12 queue&lt;int&gt; Q;
13 int indegree[10000];
14 int main(){
15     int n,i,j;
16     while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n){
17         for(i=0;i&lt;10000;i++) { edge[i].clear();indegree[i]=0;}
18         while(!Q.empty()) Q.pop();
19         i=0;
20         name.clear();
21         for(j=0;j&lt;n;j++){
22             string a,b;
23             cin&gt;&gt;a&gt;&gt;b;
24             if(name.find(a)==name.end()) { name[a]=i++;}
25             if(name.find(b)==name.end())  { name[b]=i++;}
26             edge[name[a]].push_back(name[b]);
27             indegree[name[b]]++;
28         }
29         int num=i;
30         int cnt=0;
31         for(i=0;i&lt;num;i++)
32             if(indegree[i]==0)    cnt++;
33         /*
34         int num=i;
35         for(i=0;i&lt;n;i++){
36             if(indegree[i]==0) Q.push(i);
37         }
38         int cnt=0;
39         while(!Q.empty()){
40             int nowp=Q.front();
41             Q.pop();
42             cnt++;
43             for(i=0;i&lt;edge[nowp].size();i++){
44                 indegree[edge[nowp][i]]--;
45                 if(indegree[edge[nowp][i]]==0) Q.push(edge[nowp][i]);
46             }
47         }
48         */
49         if(cnt==1) puts(&quot;Yes&quot;);
50         else puts(&quot;No&quot;);
51     }
52     return 0;
53 }
</code></pre><h4 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;vector&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;map&gt;
 7 #include &lt;string&gt;
 8 #define INFINITY 65535
 9 using namespace std;
10 
11 struct edge
12 {
13     int nextnode;
14     int d;//距离
15     int p;//花费
16 };
17 vector&lt;edge&gt; vex[1001]; // 邻接链表,vex[i]为一个向量，记录与vex[i]邻接的所有边的信息（邻接点以及权值）
18 bool S[1001]; // s集合为已经找到最短路径的顶点集合
19 int dis[1001]; // 距离向量
20 int cost[1001];//花费向量
21 int main()
22 {
23     int n,m,d,p,s,t,i,j,k,min,a,b;
24     edge e;
25     while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n!=0 &amp;&amp; m!=0)
26     {
27         // 1. 初始化邻接链表、距离向量和集合S，现在未知初始顶点和结束顶点是什么
28         for (i=1;i&lt;=n;i++)
29         {
30             vex[i].clear();
31             S[i] = false;
32             dis[i] = INFINITY; // -1代表不可达
33             cost[i] = 0;
34         }
35         // 2.输入数据
36         for (i=0;i&lt;m;i++)
37         {
38             cin &gt;&gt; a&gt;&gt;b&gt;&gt;d&gt;&gt;p;
39             e.d = d;e.p = p;
40             e.nextnode = b;
41             vex[a].push_back(e);
42             e.nextnode = a;
43             vex[b].push_back(e);
44             // 无向图，加入两条边
45         }
46         cin &gt;&gt; s &gt;&gt;t ;
47         // 确定初始顶点后，初始化集合S和dis
48         S[s] = true;dis[s] = 0; // 初始顶点自己到自己为0
49         for (i=0;i&lt;vex[s].size();i++)
50         {
51             int num = vex[s][i].nextnode;
52             dis[num] = vex[s][i].d;
53             cost[num] = vex[s][i].p;
54         }
55         // 循环找到最短路径
56         for (i=2;i&lt;=n;i++)
57         {
58             // 找到当前最短路径和顶点
59             min = INFINITY;
60             for (j=1;j&lt;=n;j++)
61             {
62                 if (!S[j] &amp;&amp; min &gt; dis[j] )
63                 {
64                     k = j;
65                     min = dis[j];
66                 }
67             }
68             S[k] = true;
69 
70             for (j = 0;j&lt;vex[k].size();j++)
71             {
72                 int node = vex[k][j].nextnode;
73                 if (S[node])
74                     continue;
75 
76                 if (min+vex[k][j].d&lt;dis[node] || min+vex[k][j].d == dis[node] &amp;&amp; cost[node] &gt; cost[k]+vex[k][j].p)
77                 {
78                     dis[node] = min + vex[k][j].d;
79                     cost[node] = cost[k]+vex[k][j].p;
80                 }
81             }
82 
83         }
84         cout &lt;&lt; dis[t]&lt;&lt;&quot; &quot;&lt;&lt; cost[t]&lt;&lt; endl;
85 
86     }
87 
88     return 0 ;
89 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（八）——数学问题" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（八）——数学问题/">计算机考研机试指南（八）——数学问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（八）——数学问题/" class="article-date">
  <time datetime="2018-08-20T17:48:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="机试指南-cha4-数学问题"><a href="#机试指南-cha4-数学问题" class="headerlink" title="机试指南 cha4 数学问题"></a>机试指南 cha4 数学问题</h3><h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 
 6 using namespace std;
 7 // 还是A+B : 注意是末尾K位而不是第K位
 8 /*
 9 pow()的返回值为double类型，有时会出现返回误差
10 解决方法：
11 double x  = pow(10,k);
12 int t  = (int)x;// 先(int)(double(pow()))
13 */
14 int main()
15 {
16     int a,b,k;
17     while(scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;k)!=EOF)
18     {
19         if (a == 0 &amp;&amp; b == 0)
20             break;
21         double t = pow(10,k);
22         int x = (int)t;
23         if ((a-b)%x == 0 )
24             cout &lt;&lt; -1 &lt;&lt; endl;
25         else
26             cout &lt;&lt; a+b &lt;&lt;endl;
27     }
28 
29     return 0;
30 }
</code></pre><h4 id="守形数"><a href="#守形数" class="headerlink" title="守形数"></a>守形数</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 
 6 using namespace std;
 7 // 守形数
 8 /*
 9 注意N的取值范围为2-100，故只能为低1位或者低2位
10 */
11 int main()
12 {
13     int n ;
14     while (cin &gt;&gt; n)
15     {
16         int i;
17         if (n&gt;=2 &amp;&amp; n&lt; 10)
18             i = 10;
19         else
20             i = 100;
21         int m = n*n; //尽量不用pow()
22 
23         if ((m-n)%i == 0)
24             cout &lt;&lt; &quot;Yes!&quot;&lt;&lt;endl;
25         else
26             cout &lt;&lt; &quot;No!&quot; &lt;&lt; endl;
27     }
28 
29     return 0;
30 }
</code></pre><h4 id="数位拆解"><a href="#数位拆解" class="headerlink" title="数位拆解"></a>数位拆解</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 
 6 using namespace std;
 7 /*
 8 */
 9 int main()
10 {
11     long x1,x2; // 两个小于10^9的整数，保险起见用long
12     int a[15],b[15];//存放两个数的每一位数字
13     int sum;
14     int i,j;
15     while (cin &gt;&gt; x1 &gt;&gt;x2)
16     {
17         sum = 0;
18         i = 0; j = 0 ;
19         while (x1 &gt; 0)
20         {
21             a[i++] = x1%10;
22             x1/= 10;
23         }
24         while (x2 &gt; 0)
25         {
26             b[j++] = x2%10;
27             x2/= 10;
28         }
29         for (int i1=0;i1&lt;i;i1++)
30             for (int j1 = 0;j1&lt;j;j1++)
31             sum+= a[i1]*b[j1];
32         cout &lt;&lt;sum &lt;&lt; endl;
33     }
34 
35     return 0;
36 }
</code></pre><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><h4 id="又一版A-B"><a href="#又一版A-B" class="headerlink" title="又一版A+B"></a>又一版A+B</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 
 6 using namespace std;
 7 /*
 8 */
 9 int main()
10 {
11    int m,a,b;
12    while (cin&gt;&gt;m&gt;&gt;a&gt;&gt;b)
13    {
14        if (m == 0)
15         break;
16        int c = a+b;
17        int size = 0;int d[10];
18        while (c&gt;0)
19        {
20            d[size++] =  c%m;
21            c = c/m;
22        }
23        for (int i = size-1;i&gt;=0;i--)
24         cout &lt;&lt; d[i];
25    }
26 
27     return 0;
28 }
</code></pre><h4 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 /*
 9 */
10 int main()
11 {
12    int a,b,a1;
13    char m[20],n[20];
14    while (scanf(&quot;%d %s %d&quot;,&amp;a,&amp;m,&amp;b)!=EOF)
15    {
16        int length = strlen(m);
17        int m1 = 0;
18        a1 = 1;  // 各位初始化权重为1
19        for (int i = length-1;i&gt;=0;i--)
20        {
21            int x;
22            if (m[i] &gt;= &#39;0&#39; &amp;&amp; m[i] &lt;= &#39;9&#39;)
23              x = m[i] - &#39;0&#39;;
24            else if (m[i] &gt;= &#39;a&#39; &amp;&amp; m[i] &lt;= &#39;z&#39;)
25              x = m[i] - &#39;a&#39; + 10;
26            else if (m[i] &gt;= &#39;A&#39; &amp;&amp; m[i] &lt;= &#39;Z&#39;)
27              x = m[i] - &#39;A&#39; + 10;
28            m1 += x*a1;
29            a1 *= a;
30        }
31        int size = 0;
32        while (m1&gt;0)
33        {
34            int x = m1%b;
35            n[size++] = (x&lt;10)?x+&#39;0&#39; : x-10+&#39;A&#39;;
36            m1 /= b;
37        }
38        for (int i =size-1;i&gt;=0;i--)
39         cout &lt;&lt; n[i];
40        cout &lt;&lt;endl;
41    }
42     return 0;
43 }
</code></pre><h4 id="gcd-lcd"><a href="#gcd-lcd" class="headerlink" title="gcd lcd"></a>gcd lcd</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 /*
 9 */
10 
11 int gcd(int a,int b)
12 {
13     if (b == 0)
14         return a;
15     else
16         return gcd(b,a%b);
17 }
18 int main()
19 {
20    int a,b;
21    while (cin &gt;&gt; a &gt;&gt; b)
22    {
23           cout &lt;&lt; gcd(a,b) &lt;&lt; endl;
24    }
25     return 0;
26 }
27  // 最小公倍数：a*b / gcd(a,b)
</code></pre><h4 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h4><h4 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 
 9 int judge(int n)
10 {
11     if (n ==1)
12         return 0;
13     if (n == 2)
14         return 1;
15     for (int i = 2; i &lt;= sqrt(n)+1;i++)
16     {
17         if (n%i == 0) // i为N的一个除1和自身以外的公因数，则不是素数
18             return 0;
19     }
20     return 1;
21 
22 }
23 int main()
24 {
25    int n ;
26    while (cin &gt;&gt; n)
27    {
28        if (judge(n))
29         cout &lt;&lt; &quot;yes&quot; &lt;&lt;endl;
30        else
31         cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
32    }
33     return 0;
34 }
</code></pre><h4 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 // 把2-n之间所有的素数找到，在main中判断是否个位为1
 9 int prime[10000]; // 存放找到的素数
10 bool isprime[10000];// 判断是否是素数
11 int primesize = 0;
12 void judge(int n)
13 {
14     for (int i = 1;i&lt;=n;i++)
15         isprime[i] = false ; // 未判断
16 
17     for (int i =2;i&lt;n;i++)
18     {
19         // 从2开始，因为2本身就是素数
20         if (isprime[i]  == true ) // 被标记成非素数
21             continue;
22         prime[primesize++] = i; // 为false时加入到prime素数数组
23         // 把素数的因数都标记为true
24         for (int j = i*i ; j&lt;=n;j = j+i) // 为什么从i*i开始
25             isprime[j] = true;
26 
27     }
28 }
29 int main()
30 {
31    int n ;
32    bool output = false;
33    while (cin &gt;&gt; n)
34    {
35        judge(n);
36        for (int i = 0;i&lt;primesize;i++)
37        {
38            if (prime[i]%10 == 1)
39            {
40                if (output == false)
41                {
42                    output = true;
43                    cout &lt;&lt; prime[i];
44                }
45                else
46                    cout &lt;&lt;&quot; &quot;&lt;&lt; prime[i];
47            }
48        }
49        cout &lt;&lt;endl;
50    }
51     return 0;
52 }
</code></pre><h4 id="Prime-Number-求1-10000内第K个素数"><a href="#Prime-Number-求1-10000内第K个素数" class="headerlink" title="Prime Number // 求1-10000内第K个素数"></a>Prime Number // 求1-10000内第K个素数</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 // 把2-n之间所有的素数找到，在main中判断是否个位为1
 9 int prime[100001]; // 存放找到的素数
10 int isprime[100001];// 判断是否是素数
11 int primesize = 0;
12 void judge(int n)
13 {
14     for (int i = 1;i&lt;=n;i++)
15         isprime[i] = false ; // 未判断
16 
17     for (int i =2;i&lt;n;i++)
18     {
19         // 从2开始，因为2本身就是素数
20         if (isprime[i]  == true ) // 被标记成非素数
21             continue;
22         prime[primesize++] = i; // 为false时加入到prime素数数组
23         // 把素数的因数都标记为true
24         for (int j = i*i ; j&lt;=n;j = j+i) // 为什么从i*i开始
25             isprime[j] = true;
26 
27     }
28 }
29 int main()
30 {
31    int k ;
32    judge(100000);
33    while (cin &gt;&gt; k)
34    {
35        cout &lt;&lt; prime[k-1] &lt;&lt; endl;
36    }
37 
38 
39     return 0;
40 }
</code></pre><h4 id="分解素因数"><a href="#分解素因数" class="headerlink" title="分解素因数"></a>分解素因数</h4><p>考虑N的取值范围是10^9，但是如果设成10^9的数组则内存空间不足，所以仅测试1-100000内的素数是否为N的素因数，如果N很大，还有一个大于100000的素因数则加一即可，因为大于100000的素因数最多只能有一个，两个就炸了INT了。</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 int prime[100001] ;
 9 bool isprime[100001];
10 int primesize = 0;
11 void judge(int n)
12 {
13     for (int i =0;i&lt;=n;i++)
14         isprime[i] = false;
15 
16     for (int i = 2;i&lt;n;i++)
17     {
18         if (isprime[i] == true)
19             continue;
20         prime[primesize++] = i;
21         for (int j = i*i;j&lt;n;j=j+i)
22             isprime[j] = true;
23     }
24 }
25 int main()
26 {
27    int n ;
28    int e[100]={0},p[100]; //存放N的质因数以及指数
29    int k = 0;
30    while (cin &gt;&gt; n)
31    {
32        judge(100000);
33        int number = 0 ;
34        for (int i = 0;i&lt;primesize;i++)
35        {
36            if (n%prime[i] == 0)
37             p[k] = i;
38            else
39             continue;
40 
41            while (n%prime[i] == 0)
42            {
43                e[k] ++;
44                n = n/prime[i];
45            }
46            k++;
47        }
48        for (int i =0;i&lt;k;i++)
49         number += e[i];
50         if (n!=1) // N的取值范围是10^9，若测试完100000内的素数仍不能被除尽，则说明有一个大于100000的素数
51             number ++;
52        cout &lt;&lt; number &lt;&lt; endl;
53 
54    }
55     return 0;
56 }
</code></pre><h4 id="整除问题（超难数学题）"><a href="#整除问题（超难数学题）" class="headerlink" title="整除问题（超难数学题）"></a>整除问题（超难数学题）</h4><pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

using namespace std;
int prime[1010] ;
bool isprime[1010];
int primesize = 0;
// 为什么是1000以内的素数？因为a的取值范围是1-1000，故a没有超过1000的素因数
// 而N！能整除a，说明N！的素因数和a的素因数必定相同
void judge(int n)
{
    for (int i =0;i&lt;=n;i++)
        isprime[i] = false;

    for (int i = 2;i&lt;n;i++)
    {
        if (isprime[i] == true)
            continue;
        prime[primesize++] = i;
        for (int j = i*i;j&lt;n;j=j+i)
            isprime[j] = true;
    }
}
int cnt[1010] ;// n!进行素因数分解后，对应prime[i]的素数的幂指数，可能为0
int cnt2[1010] ; //a的因子数
int main()
{
   int n ,a;
   int k ;
   while (cin&gt;&gt; n &gt;&gt;a)
   {
      judge(1000);
      for (int i =0;i&lt;primesize;i++)
        cnt[i] =  cnt2[i] = 0; // 初始化两个计数器

      for (int i=0;i&lt;primesize;i++)
      {
          // 对n!分解素因数，遍历到0-1000的每一个素数,
          int t = n;
          while (t)
          {
              cnt[i]+=t/prime[i];
              t = t/prime[i];
          }
      }
      int ans = 100000000;
      for (int i=0;i&lt;primesize;i++)
      {
          while (a%prime[i] == 0)
          {
              cnt2[i]++;
              a/=prime[i];
          }
          if (cnt2[i] == 0)
            continue;//没有该素数则跳过,否则容易影响整除

          if (cnt[i]/cnt2[i]&lt;ans )
            ans = cnt[i]/cnt2[i]; // 每计算出一个a的因数指数就和N！的比较一下
      }
      cout &lt;&lt;ans &lt;&lt;endl;
   }
    return 0;
}
</code></pre><h4 id="二分求幂"><a href="#二分求幂" class="headerlink" title="二分求幂"></a>二分求幂</h4><h4 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 
 7 using namespace std;
 8 
 9 int main()
10 {
11    int a,b;
12    while (cin&gt;&gt;a&gt;&gt;b)
13    {
14        if (a==0 &amp;&amp; b==0)
15         break;
16        int ans = 1;//最终结果变量
17        while (b!=0)
18        {
19            if (b%2==1)
20            {
21                ans *= a; // ans 累乘a
22                ans%=1000; // ans仅取后三位
23            }
24            b/=2;
25            a = a*a;//求下一位二进制位的权重
26            a %= 1000;//求a的后三位
27        }
28        cout &lt;&lt; ans &lt;&lt; endl;
29    }
30     return 0;
31 }
</code></pre><h4 id="A-sequence-of-numbers"><a href="#A-sequence-of-numbers" class="headerlink" title="A sequence of numbers"></a>A sequence of numbers</h4><p>10 min</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #define ret 200907
 3 long long cal(long long a,long long q,int k){
 4     long long ans=a;
 5     k--;
 6     while( k &gt; 0){
 7         if(k%2==1){
 8             ans = (ans * q) % ret;
 9         }
10         k/=2;
11         q= (q*q)%ret;
12     }
13     return ans;
14 }
15 int main(){
16     int n;
17     scanf(&quot;%d&quot;,&amp;n);
18     for(int i=0;i&lt;n;i++){
19         long long a,b,c,ans; // a,b,c取值范围为0-2^64，long long 为64位的
20         int k; // 10^9 int 足矣
21         scanf(&quot;%lld%lld%lld%d&quot;,&amp;a,&amp;b,&amp;c,&amp;k);
22         if(b-a==c-b)
23             ans=(a%ret+(k-1)*((b-a)%ret))%ret; // (a+b)%c = (a%c +b%c)%c ,防止（a+b)溢出问题
24         else{
25             long long q=b/a;
26             ans=cal(a,q,k);
27         }
28         printf(&quot;%lld\n&quot;,ans);
29     }
30     return 0;
31 }
</code></pre><h4 id="高精度整数"><a href="#高精度整数" class="headerlink" title="高精度整数"></a>高精度整数</h4><h4 id="a-b"><a href="#a-b" class="headerlink" title="a+b"></a>a+b</h4><p>超开心的是这道题我独立做出来了！虽然耗时很久，但自己思考比不停看别人的代码要强的多！</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdio.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;math.h&gt;
  5 #include &lt;string.h&gt;
  6 
  7 using namespace std;
  8 
  9 /*
 10 a + b 位数不超过1000位，大整数，不能用基本数据类型存储，必须用字符串或者数组的形式
 11 12354484 324645
 12 time : 20+20+20+20+20 = 1h 45 min 
 13 
 14 笔记： 
 15 1. 数组的初始化方式：
 16 int b[10]={0};  
 17 但是如果是： int b[10] = {1} , 却只有第一个元素被初始化为1，其余仍为0
 18 
 19 或者：
 20 int a[size] ; 
 21 memset(a,0,sizeof(int)*size); 对某指针指向的内存进行赋值，全部赋值为0
 22 
 23 2. 结构体的初始化方式：
 24 X x1 = { 1,2.2, &#39;c&#39; };
 25 X x2[3] = { {1, 1.1, &#39;a&#39;}, {2, 2.2, &#39;b&#39;}}; 使用大括号中嵌套大括号的方式
 26 
 27 3. 对齐输出0000
 28 %0xd // x为输出的整数宽度
 29 
 30 */
 31 struct bigInteger {
 32 int digit[300];
 33 int size; // 该大整数的位数
 34 }; // 每四位数字保存到一个数组里
 35 
 36 int cal(char s1[1010],int i,int n)
 37 {
 38     // s1[i] - s1[i-n+1]变为整数,循环N次
 39     int ans = 0;
 40     int r = 1;
 41     for (int j=0;j&lt;n;j++)
 42     {
 43         ans += (s1[i]-&#39;0&#39;)*r;
 44         i--;
 45         r *= 10;
 46     }
 47     return ans;
 48 }
 49 
 50 void print(bigInteger a)
 51 {
 52     // 输出的要求很严格：非第一个数组则补齐四位
 53     printf(&quot;%d&quot;,a.digit[a.size-1]);
 54     for (int i = a.size-2;i&gt;=0;i--)
 55     {
 56         printf(&quot;%04d&quot;,a.digit[i]);
 57     }
 58     cout &lt;&lt; endl;
 59 
 60 }
 61 void init(bigInteger &amp;a,char s[],int len)
 62 {
 63     int i;
 64     if (len &gt;= 4)
 65     {
 66         for (i = len-1;i&gt;=3;i = i-4)
 67             a.digit[a.size++] = cal(s,i,4);
 68         // 如果字符串不正好是4的倍数，开头剩余必小于4
 69         if (i!=-1)
 70         {
 71           a.digit[a.size++] = cal(s,i,i+1);
 72         }
 73     }
 74     else
 75         a.digit[a.size++] = cal(s,len-1,len);
 76 }
 77 int main()
 78 {
 79     bigInteger a={{0},0},b = {{0},0},c = {{0},0};
 80     int i;
 81     /* 1. 如何把很长的字符串输入到数组中
 82      输入到两个字符数组中，从size-1开始每四位字符形成一个整数，存放到数组中，
 83      从0开始倒着往数组中放，输出的时候从size反着输出即可
 84     */
 85     char s1[1010],s2[1010];
 86     int len1,len2;
 87     while (scanf(&quot;%s %s&quot;,s1,s2)!=EOF)
 88     {
 89         // 初始化为0，这样后面的相加部分才不用分长短讨论
 90         a={{0},0};b = {{0},0};c = {{0},0};
 91         len1 = strlen(s1);
 92         len2 = strlen(s2);
 93         init(a,s1,len1);
 94         init(b,s2,len2);
 95         // 把两部分相加，从数组0号开始递增，大于10000，截断第五位，加到下一个数组
 96         int add = 0,len = (a.size &gt;= b.size) ? a.size : b.size;// 进位
 97         for (i = 0;i&lt;len;i++)
 98         {
 99             int temp = a.digit[i] + b.digit[i] + add;
100             add = temp/10000;
101             c.digit[c.size++] = temp%10000;
102         }
103      //   print(a);
104      //   print(b);
105         print(c);
106 
107     }
108 
109     return 0;
110 }
</code></pre><h4 id="N的阶乘"><a href="#N的阶乘" class="headerlink" title="N的阶乘"></a>N的阶乘</h4><p>39 min</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 #include &lt;algorithm&gt;
 7 
 8 using namespace std;
 9 
10 struct bigInteger
11 {
12     int digit[1001];  // 1000 !  &lt; 1000^1000,每四位存储一个
13     int size; // digit的长度
14 }a = {{0},0};
15 
16 void print()
17 {
18     // 找到不为0的第一位
19     for (int i = 1 ;i&lt;=1001;i++)
20     {
21         if (a.digit[i]!=0 &amp;&amp; a.digit[i+1] == 0)
22         {
23             a.size = i;
24             break;
25         }
26 
27     }
28     // i 指向最后一位
29 
30     printf(&quot;%d&quot;,a.digit[a.size]);
31     for (int i = a.size-1; i &gt;=1 ;i--)
32         printf(&quot;%04d&quot;,a.digit[i]);
33     cout &lt;&lt; endl;
34 }
35 int main()
36 {
37     int n;
38     while (cin&gt;&gt;n)
39     {
40         a = {{0},0};
41         int c = 0;
42         a.digit[++a.size] = 1; // digit 从size=1 开始记录
43         for (int i = 2 ;i&lt;=n;i++)
44         {
45             for (int j = 1;j&lt;=1000;j++) // digit数组中的每个元素都要乘以乘数
46             {
47                 a.digit[j] = (a.digit[j]*i + c);
48                 int temp = a.digit[j];
49                 c = a.digit[j]/10000;
50                 a.digit[j] %= 10000;
51                 // size什么时候增加？每一位可能会产生无数次向前的进位
52             }
53         }
54         print();
55     }
56 
57     return 0;
58 }
</code></pre><h4 id="浮点数加法"><a href="#浮点数加法" class="headerlink" title="浮点数加法"></a>浮点数加法</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 #include &lt;math.h&gt;
 5 #include &lt;string.h&gt;
 6 #include &lt;algorithm&gt;
 7 
 8 using namespace std;
 9 
10 /*
11 浮点数从小数点进行分割，一个字符串分割成整数和小数数组，
12 但小数是左对齐，整数是右对齐。加完小数之后的进位和整数相加
13 */
14 
15 struct bigInteger
16 {
17     int digit[1001];
18     int size;
19     int point;
20 }a,b,c;
21 
22 int cal(char s[],int i,int n)
23 {
24     int sum = 0;
25     int c = 1;
26     for (int j = 0 ; j &lt; n ;j++)
27     {
28         sum += (s[i--]-&#39;0&#39;)*c;
29         c *= 10;
30     }
31     return sum;
32 }
33 void init(char s[],bigInteger &amp;a)
34 {
35     int len = strlen(s);
36     // 找到小数点，记录位置并删除
37     int i;
38     for (i = 0;i&lt;len;i++)
39     {
40         if (s[i] == &#39;.&#39;)
41         {
42             a.point = i;
43             break;
44         }
45     }
46     for (i; i &lt; len;i++)
47     {
48         s[i] = s[i+1];
49     }
50     for (i = len-2; i &gt;= 3 ;i -= 4)
51     {
52         a.digit[++a.size] = cal(s,i,4);
53     }
54     if (i != -1)
55     {
56      // 不是4的倍数
57         a.digit[++a.size] = cal(s,i,i+1);
58     }
59 }
60 void print(bigInteger a)
61 {
62     int i;
63     printf(&quot;%d&quot;,a.digit[a.size]);
64     for (i = a.size-1 ; i &gt;=1 ;i--)
65     {
66         printf(&quot;%04d&quot;,a.digit[i]);
67     }
68     cout  &lt;&lt; endl;
69 }
70 int main()
71 {
72     int len1,len2,len;
73     char s1[1001],s2[1001];
74     while (scanf(&quot;%s %s&quot;,s1,s2)!=EOF)
75     {
76         // 初始化biginteger结构体
77         init(s1,a);
78         init(s2,b);
79 
80         print(a);
81         print(b);
82 
83     }
84 
85 
86     return 0;
87 }
</code></pre><h4 id="二分求幂-问题重做-20min"><a href="#二分求幂-问题重做-20min" class="headerlink" title="二分求幂 问题重做 20min"></a>二分求幂 问题重做 20min</h4><blockquote>
<p>过程推演了一会儿，代码的编写比较简单，主要是把过程弄懂</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;string.h&gt;
 3 #include &lt;stdio.h&gt;
 4 #include &lt;stdlib.h&gt;
 5 #include &lt;queue&gt;
 6 #include &lt;vector&gt;
 7 
 8 using namespace std;
 9 
10 
11 
12 int main()
13 {
14     int a,b;
15     while (cin&gt;&gt;a&gt;&gt;b)
16     {
17         if (a == 0 &amp;&amp; b == 0)
18             break;
19         int ans = 1; int r = 0; // b对2的余数
20         int t = a; // a的平方
21         while (b&gt;0)
22         {
23             r = b%2;
24             b = b/2;
25 
26             if (r == 1)
27             {
28                 ans = (ans * t)%1000;
29             }
30             t = (t*t)%1000;
31         }
32         cout &lt;&lt; ans &lt;&lt; endl;
33 
34     }
35 
36     return 0;
37 }
</code></pre><h4 id="Tr"><a href="#Tr" class="headerlink" title="Tr"></a>Tr</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;stdio.h&gt;
 3 #include &lt;stdlib.h&gt;
 4 
 5 using namespace std;
 6 const int ret = 9973;
 7 void cal(int a[11][11],int b[11][11],int n,int c[][11])
 8 {
 9 
10     int i,j,k;
11     for (i=1;i&lt;11;i++)
12         for (j=1;j&lt;11;j++)
13         c[i][j] = 0;
14     for (i = 1 ; i&lt;=n;i++)
15     {
16         for (j=1;j&lt;=n;j++)
17         {
18             for (k = 1 ; k &lt;= n ;k++)
19             {
20               c[i][j] += a[i][k]*b[k][j];
21             }
22 
23         }
24     }
25 }
26 void equal(int ans[][11],int tmp[][11])
27 {
28     int i,j;
29     for (i=1;i&lt;11;i++)
30         for (j=1;j&lt;11;j++)
31     {
32         ans[i][j] = tmp[i][j];
33     }
34 }
35 int main()
36 {
37     int t,i,j,n,k,z;
38     int a[11][11];
39     while (cin &gt;&gt; t)
40     {
41     for (z = 0;z&lt;t;z++)
42     {
43         cin &gt;&gt; n &gt;&gt; k;
44         for (i = 1;i&lt;n+1;i++)
45             for (j = 1;j&lt;n+1;j++)
46             cin &gt;&gt; a[i][j];
47 
48         int ans[11][11] =
49         {1,0,0,
50          0,1,0,
51          0,0,1
52         };
53         int tmp[11][11];
54         while (k&gt;0)
55         {
56             if (k%2 == 1)
57             {
58               cal(ans,a,n,tmp);
59               equal(ans,tmp);
60             }
61             k = k/2;
62             //a = a * a;
63             cal(a,a,n,tmp);
64             equal(a,tmp);
65         }
66         int c = 0;
67         for (i  = 1 ;i&lt;=n;i++)
68         {
69            c += ans[i][i];
70         }
71         cout &lt;&lt; c &lt;&lt;endl;
72     }
73     }
74     return 0 ;
75 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 John Doe 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>