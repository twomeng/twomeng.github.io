<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-CCF 第一、二题" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/CCF 第一、二题/">CCF 第一、二题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/CCF 第一、二题/" class="article-date">
  <time datetime="2018-08-20T17:26:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="最小差值-另解"><a href="#最小差值-另解" class="headerlink" title="最小差值 另解"></a>最小差值 另解</h4><blockquote>
<p>先对数据进行排序，求相邻数据的最小值</p>
</blockquote>
<h4 id="打酱油"><a href="#打酱油" class="headerlink" title="打酱油"></a>打酱油</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：
10     用时：tomato *
11     思路：
12 */
13 
14 
15 int main()
16 {
17     int n; // n &lt;=300
18     while (cin&gt;&gt;n)
19     {
20         int x = n / 10 ;
21         int five = ( x / 5 ) * 2;
22         int thr = (x % 5) / 3 ;
23         cout &lt;&lt; five+thr + x &lt;&lt;endl;
24     }
25 
26 
27     return 0;
28 }
</code></pre><h5 id="工程做法：使用常量为了程序的通用性"><a href="#工程做法：使用常量为了程序的通用性" class="headerlink" title="工程做法：使用常量为了程序的通用性"></a>工程做法：使用常量为了程序的通用性</h5><pre><code>/* CCF201709-1 打酱油 */  

#include &lt;stdio.h&gt;  

const int ONE = 1;  
const int TWO = 2;  
const int FIVE = 5;  
const int THREE = 3;  
const int PRICE = 10;  

int main(void)  
{  
    int n, group1, group2, group3;  

    scanf(&quot;%d&quot;, &amp;n);  

    group1 = n / PRICE / FIVE;  
    group2 = (n - group1 * PRICE * FIVE) / PRICE / THREE;  
    group3 = (n - group1 * PRICE * FIVE - group2 * PRICE * THREE) / PRICE;  

    printf(&quot;%d\n&quot;, group1 * (FIVE + TWO) + group2 * (THREE + ONE) + group3);  

    return 0;  
}  
</code></pre><h4 id="分蛋糕"><a href="#分蛋糕" class="headerlink" title="分蛋糕"></a>分蛋糕</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：分蛋糕
10     思路：
11 */
12 
13 
14 int main()
15 {
16     int n,k;
17     int cake = 0;
18     int part = 0;
19     int num = 0;
20     while (cin&gt;&gt;n&gt;&gt;k)
21     {
22         while (n--)
23         {
24            cin &gt;&gt; part;
25            cake += part;
26            if (cake &gt;= k )
27            {
28                cake = 0 ;
29                num ++;
30            }
31         }
32         if (cake &lt; k )
33         {
34             num ++;
35         }
36         cout &lt;&lt; num &lt;&lt;endl;
37     }
38 
39 
40     return 0;
41 }
</code></pre><p>100分答案：</p>
<pre><code> 1 #include &lt;iostream&gt;
 2 using namespace std;
 3 
 4 int main()
 5 {
 6     int n, k, ans = 0, s = 0, a;
 7     cin &gt;&gt; n &gt;&gt; k;
 8     while (n--)
 9     {
10         cin &gt;&gt; a;
11         s += a;
12         if (s &gt;= k)
13         {
14             s = 0;
15             ans++;
16         }
17     }
18     if (s)ans++;
19     cout &lt;&lt; ans;
20     return 0;
21 }
</code></pre><blockquote>
<p>第一次做的只有20分，经过改进发现，<code>if (cake)</code>不要写成 <code>if （cake &lt; k
）</code>,因为如果是刚刚好，cake应该为0，大于0的话才是蛋糕不够的的情况。要注意 <strong>边界问题</strong><br> 另外能不使用数组而使用一次性变量的情况就使用变量，这不浪费内存呢么？</p>
</blockquote>
<h4 id="中间数"><a href="#中间数" class="headerlink" title="中间数"></a>中间数</h4><pre><code>* 



 1 #include  &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：分蛋糕
10     思路：
11 */
12 
13 bool equals(int a[],int n,int mid)
14 {
15     int lit = 0;
16     int big = 0;
17         for (int i = 0 ;i &lt; (n-1)/2 ; i++)
18     {
19         if (a[i] &lt; mid)
20             lit++;
21     }
22     for (int i = (n-1)/2+1 ;i &lt; n ; i++)
23     {
24         if (a[i] &gt; mid)
25             big++;
26     }
27     if (lit == big)
28         return true;
29 }
30 
31 int main()
32 {
33     int n;
34     int a[1000];
35     bool flag = 1;
36     while ( cin  &gt;&gt;  n )
37     {
38         for (int i = 0;i&lt;n;i++)
39             cin &gt;&gt; a[i];
40 
41         sort(a,a+n);
42         if ( n % 2 != 0 )
43     {
44         int mid = a[(n-1)/2];
45         if (equals(a,n,mid)){
46             cout &lt;&lt; mid &lt;&lt;endl;
47             flag = 0;
48         }
49 
50     }
51     else
52     {
53         int mid1= a[(n-1)/2];
54         int mid2= a[(n+1)/2];
55         if (equals(a,n,mid1)){
56             cout &lt;&lt;mid1 &lt;&lt;endl;
57             flag = 0;
58         }
59          else
60             if (equals(a,n,mid2))
61             {
62                 cout &lt;&lt;mid2&lt;&lt;endl;
63                 flag = 0;
64             }
65     }
66     if (flag)
67         cout &lt;&lt; -1 &lt;&lt;endl;
68 
69     }
70 
71     return 0;
72 }
</code></pre><blockquote>
<p>分数 ： 80<br> 满分答案：减去与两侧相同的数</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：分蛋糕
10     思路：
11 */
12 
13 
14 const int N = 1000;
15 int a[N];
16 int main()
17 {
18     int n;
19     while ( cin  &gt;&gt;  n )
20     {
21         for (int i = 0;i&lt;n;i++)
22             cin &gt;&gt; a[i];
23 
24         sort(a,a+n);
25         int mid = a[n/2];
26         int left = n/2;
27         int right = n - left - 1;
28         for (int i = 0 ;i &lt; n/2 ; i++)
29             if (a[i] == mid )
30                 left -- ;
31         for (int i = n/2+1 ;i &lt; n; i++)
32             if (a[i] == mid )
33                 right -- ;
34 
35         if (left == right)
36             cout &lt;&lt; mid &lt;&lt;endl;
37         else
38             cout &lt;&lt; -1&lt;&lt;endl;
39     }
40     return 0;
41 }
</code></pre><h4 id="最大波动"><a href="#最大波动" class="headerlink" title="最大波动"></a>最大波动</h4><pre><code> 1    * 不用数组，三个变量解决问题
 2 #include &lt;iostream&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;string.h&gt;
 5 #include &lt;string&gt;
 6 #include &lt;stdio.h&gt;
 7 #include &lt;iomanip&gt;
 8 using namespace std;
 9 /*
10     题目：
11     思路：
12 */
13 
14 const int N = 1000;
15 int a[N];
16 
17 int main()
18 {
19     int n;
20     int minN = 0;
21     while (cin &gt;&gt;n)
22     {
23         for (int i=0;i &lt; n;i++)
24         {
25             cin &gt;&gt; a[i];
26         }
27         for (int i = 0 ;i&lt;n-1;i++)
28         {
29             if (abs(a[i+1] - a[i])&gt; minN )
30             {
31                 minN = abs(a[i+1]-a[i]);
32             }
33         }
34         cout &lt;&lt; minN &lt;&lt;endl;
35     }
36     return 0;
37 }
38 * 不需要使用数组的方法， 先输入第一个数，后面的数循环输入
39 int main(void)  
40 {  
41     int n, first, second, delta, maxval=0;  
42 
43     // 输入n，输第１个数（从逻辑上来说应该写两句，为了简洁只需要写一句）  
44     scanf(&quot;%d%d&quot;, &amp;n, &amp;first);  
45 
46     while(--n) {  
47         //　输入第2至第n个数  
48         scanf(&quot;%d&quot;, &amp;second);  
49 
50         // 求差值（波动值），取绝对值，求最大值  
51         delta = second - first;  
52         if(delta&lt;0)  
53             delta = -delta;  
54         maxval = MAX(maxval, delta);  
55 
56         first = second;  
57     }  
58 
59     // 输出结果  
60     printf(&quot;%d\n&quot;, maxval);  
61 
62     return 0;  
63 }  
</code></pre><h4 id="折点计数"><a href="#折点计数" class="headerlink" title="折点计数"></a>折点计数</h4><pre><code> 1 *
 2 #include &lt;iostream&gt;
 3 #include &lt;algorithm&gt;
 4 #include &lt;string.h&gt;
 5 #include &lt;string&gt;
 6 #include &lt;stdio.h&gt;
 7 #include &lt;iomanip&gt;
 8 using namespace std;
 9 /*
10     题目：
11     思路：
12 */
13 
14 
15 int main()
16 {
17     // 求左边大右边大或左边小右边小的点的个数
18     int n;
19     int l, m ,r;
20     int num = 0;
21     while (cin &gt;&gt; n)
22     {
23         cin &gt;&gt;l&gt;&gt;m;
24         for (int i=0;i&lt;n-2;i++)
25         {
26             cin &gt;&gt; r;
27             if ((l &lt; m &amp;&amp; r &lt; m) || (l &gt; m &amp;&amp; r &gt; m ))
28                 num ++;
29             l = m; m = r;
30         }
31         cout &lt;&lt; num &lt;&lt;endl;
32 
33     }
34     return 0;
35 }
</code></pre><h4 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h4><blockquote>
<p>vector 没做出来，生气<img src="https://mp.csdn.net/mdeditor/1521093711205.png" alt="Alt text"><br> 1. 首先想到vector，注意vector的循环方法 迭代器+size（）判断<br> 2. 使用erase的时候应当避免使用迭代器<br> 3. 如果不使用STL，需要做一个变量标记</p>
</blockquote>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #include &lt;algorithm&gt;
  6 #include &lt;vector&gt;
  7 #define maxSize 20
  8 #define ERROR -1
  9 using namespace std;
 10 /*
 11      CCF ：2017-12-2
 12     Time : 游戏
 13     Date : 2018/3/14
 14 
 15 */
 16 struct stu
 17 {
 18     int num;
 19     int id;
 20 };
 21 int main()
 22 {
 23 
 24     int n,k;
 25     stu s;
 26     int i;
 27     vector&lt;stu&gt;::iterator iter;
 28     while (cin&gt;&gt;n&gt;&gt;k)
 29     {
 30         vector&lt;stu&gt; vec;
 31         for (int i = 0 ;i &lt; n ; i++)
 32         {
 33             s.id = i+1;
 34             vec.push_back(s);
 35         }
 36 
 37 
 38         int i = 0;
 39         while (vec.size() &gt; 1)
 40         {
 41             for (iter = vec.begin(); iter != vec.end();i++)
 42             {
 43                 iter-&gt;num = i+1;
 44                 cout &lt;&lt; &quot;num :&quot;&lt;&lt;iter-&gt;num&lt;&lt; &quot;  id :&quot;&lt;&lt;iter-&gt;id&lt;&lt;endl;
 45 
 46                 if (iter-&gt;num%k == 0 || iter-&gt;num % 10 == k)
 47                 {
 48                     cout &lt;&lt; iter-&gt;id &lt;&lt;&quot;号小朋友报数&quot; &lt;&lt; iter-&gt;num &lt;&lt; &quot;被淘汰&quot; &lt;&lt;endl;
 49                     iter = vec.erase(vec.begin()+ iter-&gt;id - 1);
 50                 }
 51                 else
 52                     iter ++;
 53 
 54             }
 55         }
 56         cout &lt;&lt; vec[0].id;
 57 
 58     }
 59     return 0;
 60 }
 61 * 正确：
 62 #include &lt;iostream&gt;
 63 #include &lt;string.h&gt;
 64 #include &lt;stdio.h&gt;
 65 #include &lt;stdlib.h&gt;
 66 #include &lt;algorithm&gt;
 67 #include &lt;vector&gt;
 68 #define maxSize 20
 69 #define ERROR -1
 70 using namespace std;
 71 /*
 72      CCF ：2017-12-2
 73     Time : 游戏
 74     Date : 2018/3/14
 75 
 76 */
 77 
 78 int main()
 79 {
 80     int n,k;
 81     cin &gt;&gt; n &gt;&gt; k;
 82     vector&lt;int&gt; vec;
 83     for (int i=0;i&lt;n;i++)
 84         vec.push_back(i+1);
 85     int i = -1,no = 0;
 86     while (vec.size() &gt; 1){
 87         no ++;
 88         i ++;
 89         i = i % vec.size(); // ★★★★ 相当于循环的作用
 90         if ( no % k == 0 || no % 10 == k)
 91         {
 92             vec.erase(vec.begin()+i);
 93             i--;
 94         }
 95 
 96     }
 97     cout &lt;&lt; vec[0] &lt;&lt;endl;
 98 
 99     return 0;
100 }
101 * 从第一个进队的元素开始取，并pop（）弹出队列，如果no符合要求则不行动否则push（）到队列中。和学生的顺序无关？
102  while(!q.empty()) {  
103         head = q.front();  
104         q.pop();  
105 
106         no++;  
107         if(no % k == 0 || no % 10 == k)  
108             ;  
109         else  
110             q.push(head);  
111     }  
112 * 变量标记
113 const int N = 1000;  
114 bool flag[N];  
115 
116 int main()  
117 {  
118     int n, k;  
119 
120     // 读入数据  
121     cin &gt;&gt; n &gt;&gt; k;  
122 
123     // 初始化  
124     memset(flag, false, sizeof(flag));  
125 
126     // 模拟出局过程  
127     int i = -1, no = 0, cnt = n;  
128     while(cnt &gt; 1) {  
129         i++;  
130         i %= n;  
131         if(!flag[i]) {  
132             no++;  
133             if(no % k == 0 || no % 10 == k) {  
134                 flag[i] = true;  
135 
136                 cnt--;  
137             }  
138         }  
139     }   
140     return 0;  
141 }  
</code></pre><h3 id="ISBN"><a href="#ISBN" class="headerlink" title="ISBN"></a>ISBN</h3><blockquote>
<p>首先想到string，字符与整数的转化过程不要忘记！</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 #include &lt;vector&gt;
 8 #include &lt;queue&gt;
 9 using namespace std;
10 /*
11     题目：ISBN号码
12     思路：
13 
14 */
15 
16 
17 int main()
18 {
19     string s;
20     cin &gt;&gt; s;
21     int c = 1;
22     int sum = 0;
23     for (int i = 0 ; i &lt; s.length()-1 ;i ++)
24     {
25         if (s[i] != &#39;-&#39;){
26             sum += (s[i]-&#39;0&#39;)*c;
27             c++;
28         }
29     }
30     int c1 = sum % 11;
31     char cc;
32     // 逻辑上的错误！
33     // 如果cc = x,不应该被认为是不正确的一类
34     if (c1 == 10)
35         cc = &#39;X&#39;;
36     else
37         cc = &#39;0&#39;+c1; // 统一转化为字符
38 
39     if ( cc == s[s.length()-1])
40         cout &lt;&lt; &quot;Right&quot; &lt;&lt; endl;
41     else
42     {
43         s[s.length()-1] = cc;
44         cout &lt;&lt;s&lt;&lt; endl;
45     }
46 
47 
48 
49     return 0;
50 }
</code></pre><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><blockquote>
<p>窗口和点击操作用结构体实现，窗口从上到下的顺序用order数组表示，为了标记每个窗口的位置，给窗口结构体增加num序号，便于进行窗口移动的调整。</p>
</blockquote>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;algorithm&gt;
  3 #include &lt;string.h&gt;
  4 #include &lt;string&gt;
  5 #include &lt;stdio.h&gt;
  6 #include &lt;iomanip&gt;
  7 #include &lt;vector&gt;
  8 #include &lt;queue&gt;
  9 using namespace std;
 10 /*
 11     题目：窗口
 12     思路：
 13 
 14 */
 15 struct win{
 16     int x1;
 17     int y1;
 18     int x2;
 19     int y2;
 20     int no;
 21 }win[11];
 22 
 23 struct point
 24 {
 25     int x;
 26     int y;
 27 }point[11];
 28 int order[11];
 29 
 30 
 31 int belongToWin(int j,int x,int y)
 32 {
 33     if ( (x &gt;= win[j].x1 &amp;&amp; x &lt;= win[j].x2) &amp;&amp;(y &gt;= win[j].y1 &amp;&amp; y &lt;= win[j].y2))
 34         return 1;
 35     else
 36         return 0;
 37 }
 38 void moveTo(int j,int n)
 39 {
 40     // order中移动顺序
 41     int  t = order[j];
 42     for (int i = j ; i &lt; n-1 ; i++ )
 43     {
 44         order[i] = order[i+1];
 45     }
 46     order[n-1] = t;
 47 }
 48 int main()
 49 {
 50     int N,M;
 51     cin &gt;&gt; N &gt;&gt; M;
 52     int i;
 53     for (i = 0 ; i &lt; N ;i++)
 54     {
 55         cin &gt;&gt; win[i].x1 &gt;&gt; win[i].y1 &gt;&gt; win[i].x2 &gt;&gt; win[i].y2;
 56         win[i].no = i+1;
 57         order[i] = i+1;
 58     }
 59     for ( i = 0 ; i &lt; M ; i++)
 60     {
 61         cin &gt;&gt; point[i].x &gt;&gt; point[i].y ;
 62     }
 63     // 对point操作进行循环，每次找出位于最上层（order中大的）的窗口：改变order移动到最外层，输出窗口序号
 64     for ( i = 0 ;i &lt; M ; i++)
 65     {
 66         bool flag = 1;
 67 
 68         for (int j = N-1 ; j &gt;= 0 ; j--) // 从order的上层开始往下找符合点击范围内的
 69         {
 70             if (belongToWin(j,point[i].x,point[i].y))
 71             {
 72                 if (j != N-1)
 73                 {
 74                     // 不是最外层
 75                     moveTo(j,N); // 移动到最外层的函数
 76                 }
 77                 cout &lt;&lt; win[order[N-1]-1].no &lt;&lt;endl;
 78                 flag = 0;
 79                 break;
 80             }
 81         }
 82         if (flag) // 都没点击到窗口内
 83             cout &lt;&lt;&quot;IGNORED&quot;&lt;&lt;endl;
 84 
 85     }
 86 
 87 
 88 
 89     return 0;
 90 }
 91 * 40 
 92 // 判断哪个窗口被点击  
 93         for(int j=0; j&lt;n; j++) {  
 94             if(win[order[j]].x1 &lt;= point[i].x &amp;&amp; point[i].x &lt;= win[order[j]].x2 &amp;&amp;  
 95                     win[order[j]].y1 &lt;= point[i].y &amp;&amp; point[i].y &lt;= win[order[j]].y2) {  
 96                 // 得到窗口号  
 97                 winno = win[order[j]].winno;  
 98 
 99                 // 将被点击的窗口移到最前端  
100                 temp = order[j];  
101                 for(int k=j; k&gt;0; k--)  
102                     order[k] = order[k-1];  
103                 order[0] = temp;  
104 
105                 break;  
106             }  
107         }  
108 
109         // 输出结果  
110         if(winno == -1)  
111             cout &lt;&lt; &quot;IGNORED&quot; &lt;&lt; endl;  
112         else  
113             cout &lt;&lt; winno &lt;&lt; endl;  
114     }  
</code></pre><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><blockquote>
<p>矩阵用结构体表示，整个画布用数组表示</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 #include &lt;vector&gt;
 8 #include &lt;queue&gt;
 9 using namespace std;
10 /*
11     题目：
12     思路：
13 
14 */
15 const int N = 101;
16 struct rec
17 {
18     int x1,y1,x2,y2;
19 }rec[N];
20 
21 int paper[N][N] ;
22 // memset(paper,1,sizeof(paper))
23 
24 int main()
25 {
26     int n;
27     int i,j,k;
28     cin &gt;&gt; n ;
29     for ( i = 0 ;i &lt; n ; i++)
30     {
31         cin &gt;&gt; rec[i].x1 &gt;&gt; rec[i].y1 &gt;&gt; rec[i].x2&gt;&gt;rec[i].y2;
32     }
33     for (i = 0 ; i &lt; N ; i++)
34         for (j = 0 ; j &lt; N ;j ++)
35             paper[i][j] = 0;
36 
37     for (i = 0 ;i &lt; n ;i++)
38     {
39         for ( j = rec[i].x1 ; j &lt; rec[i].x2 ; j++)
40             for ( k = rec[i].y1 ; k &lt; rec[i].y2 ; k++)
41         {
42             paper[j][k] = 1;
43         }
44     }
45 
46     int num = 0;
47      for (i = 0 ; i &lt; N ; i++)
48         for (int j = 0 ; j &lt; N ;j ++)
49             if (paper[i][j])
50                 num ++;
51 
52     cout &lt;&lt; num &lt;&lt;endl;
53 
54 
55 
56 
57     return 0;
58 }
</code></pre><h4 id="数字排序"><a href="#数字排序" class="headerlink" title="数字排序"></a>数字排序</h4><blockquote>
<p>每个数字对应一个数量，使用map表示，一次循环输入，map自动排序<br> 排序的工具使用优先队列，但需要创建对应Node结点和cmp函数，自定义优先队列的使用规则<br> 优先队列特殊：大堆输出，所以和正常的cmp函数要反着写</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 #include &lt;vector&gt;
 8 #include &lt;queue&gt;
 9 #include &lt;map&gt;
10 using namespace std;
11 /*
12     题目：
13     思路：
14     1.出现次数递减
15     2. 出现次数相同时，先输出值小的
16 
17     1. 使用map进行统计
18     2. 使用优先队列进行排序
19 
20 */
21 struct Node
22 {
23     int val,c ;
24 };
25 
26 struct cmp{
27     bool operator()(Node a, Node b){
28         if(a.c == b.c)  return a.val&gt;b.val;
29         return a.c &lt; b.c;
30     }
31 };
32 int main()
33 {
34     int n;
35     cin &gt;&gt; n;
36     map&lt;int,int&gt; m ;
37     int t;
38     // 1.输入数据统计出现次数
39     for (int i = 0; i &lt; n ; i++){
40         cin &gt;&gt; t;
41         m[t] += 1;
42     }
43     /*debug*/
44     // 2. 利用优先队列进行排序
45     // priority_queue&lt;map&lt;int,int&gt;,vector&lt;map&lt;int,int&gt;,cmp&gt; q; 不能把map作为队列元素
46     // 把map集合中的值一对一对取出，存入node中，插入队列
47     priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt; q;
48     Node no ;
49     map&lt;int,int&gt;::iterator iter ;
50     for (iter = m.begin() ; iter !=m.end() ; iter++)
51     {
52         no.val = iter-&gt;first ;
53         no.c = iter-&gt;second ;
54         q.push(no);
55     }
56 
57 
58 
59     // print
60     while(!q.empty()){
61         cout&lt;&lt;q.top().val&lt;&lt;&#39; &#39;&lt;&lt;q.top().c&lt;&lt;endl;
62         q.pop();
63     }
64 
65 
66 
67     return 0;
68 }
</code></pre><h4 id="公共钥匙盒"><a href="#公共钥匙盒" class="headerlink" title="公共钥匙盒"></a>公共钥匙盒</h4><blockquote>
<ol>
<li><p>钥匙盒用数组表示，存储钥匙ID，没有则为-1</p>
<p>2.<br>老师的时间、操作不同，对钥匙盒的改变也不同，需要创建坐标轴的元素改变结点Node并初始化，为了排序，使用优先队列存储Node结点，按照自定义排序规则排序。遍历优先队列。</p>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;stdio.h&gt;
  4 #include &lt;stdlib.h&gt;
  5 #include &lt;algorithm&gt;
  6 #include &lt;vector&gt;
  7 #include &lt;queue&gt;
  8 #include &lt;stack&gt;
  9 #define maxSize 20
 10 #define ERROR -1
 11 using namespace std;
 12 /*
 13      CCF ：2017-12-2
 14     Time : 公共钥匙盒（模拟题）
 15     思路 ：
 16     1. 如果在时间坐标轴上标记，某个事件，还/拿，某把钥匙，定义为一个操作节点
 17     2. 使用优先队列对操作节点进行排序，时间优先，时间相同先还再取，操作相同钥匙号小的有限
 18     3. 遍历优先队列中的操作，定义钥匙盒数组，没有钥匙为-1，利用循环从小到大找空位
 19 
 20 */
 21 const int K = 1001;
 22 struct Node
 23 {
 24     int key; // 钥匙ID
 25     int time; // 时间
 26     char op;// 还钥匙R，取钥匙G
 27     bool operator &lt; (Node a) const
 28     {
 29         if (time != a.time)
 30         {
 31             return time &gt; a.time ;
 32         }else if (op != a.op){
 33             return op &lt; a.op;
 34         }
 35         else{
 36             return key &gt; a.key ;
 37         }
 38     }
 39 
 40 };
 41 
 42 const int N1 = 10000;
 43 int box[N1]; // 钥匙盒子
 44 
 45 int main()
 46 {
 47     int n,k,c; // n 个房间，k 个老师
 48     // 输入老师的信息
 49     cin &gt;&gt; n &gt;&gt; k ;
 50 
 51     // 初始化钥匙盒信息
 52     memset(box,0,N1);
 53     for (int i = 0 ; i &lt; n ; i++)
 54         box[i] = i+1;
 55 
 56     // 初始化优先队列，放入取钥匙和拿钥匙操作节点
 57     Node a;
 58     int last;
 59     priority_queue&lt;Node&gt; p;
 60     for (int i = 0 ; i &lt; k ; i++ )
 61     {
 62         cin &gt;&gt; a.key &gt;&gt; a.time &gt;&gt; last;
 63         a.op = &#39;G&#39;;
 64         p.push(a);
 65         a.time = last + a.time;
 66         a.op = &#39;R&#39;;
 67         p.push(a);
 68 
 69    }
 70    /*debug
 71    while (!p.empty())
 72    {
 73        a = p.top();
 74        cout &lt;&lt; a.key &lt;&lt; &quot; &quot;;
 75        p.pop();
 76    }
 77    */
 78 
 79 
 80     // 遍历优先队列
 81     while (!p.empty())
 82     {
 83         a = p.top();
 84         p.pop();
 85         if (a.op == &#39;G&#39;)
 86         {
 87             for (int i = 0; i&lt;n;i++)
 88             {
 89                 if (box[i] == a.key)
 90                 {
 91                     box[i] = -1;
 92                     break;
 93                 }
 94             }
 95         }
 96         if (a.op == &#39;R&#39;)
 97         {
 98             for (int i=0;i&lt;n;i++)
 99             {
100                 if (box[i] == -1)
101                 {
102                     box[i] = a.key;
103                     break;
104                 }
105             }
106         }
107     }
108 
109     // print
110     for (int i = 0 ; i&lt; n-1;i++)
111     {
112         cout &lt;&lt; box[i] &lt;&lt; &quot; &quot;;
113     }
114     cout &lt;&lt;box[n-1]&lt;&lt;endl;
115 
116 
117 
118 
119 
120 
121     return 0;
122 }
</code></pre><h4 id="学生排队"><a href="#学生排队" class="headerlink" title="学生排队"></a>学生排队</h4><blockquote>
<p>vector 出队erase，入队insert，注意的是这两者的具体函数规则</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;string.h&gt;
 3 #include &lt;stdio.h&gt;
 4 #include &lt;stdlib.h&gt;
 5 #include &lt;algorithm&gt;
 6 #include &lt;vector&gt;
 7 #include &lt;queue&gt;
 8 #include &lt;stack&gt;
 9 #define maxSize 20
10 #define ERROR -1
11 using namespace std;
12 /*
13      CCF ：
14     Time :
15     思路 ：
16 
17 */
18 void print(vector&lt;int&gt; vec)
19 {
20         for (int i= 0;i&lt;vec.size();i++)
21     {
22         cout &lt;&lt;vec[i]&lt;&lt;&quot; &quot;;
23     }
24 }
25 
26 int main()
27 {
28     int n;
29     cin &gt;&gt;n;
30     int m;
31     cin &gt;&gt; m;
32     int p,q;
33 
34     // 构造队列
35     vector&lt;int&gt; vec;
36     for (int i=0;i&lt;n;i++)
37     {
38         vec.push_back(i+1);
39     }
40 
41     vector&lt;int&gt;::iterator iter;
42     for (int i= 0;i&lt;m;i++)
43     {
44         cin &gt;&gt;p &gt;&gt;q;
45         // 对队列进行操作
46         for (iter =vec.begin() ; iter !=vec.end();iter++)
47         {
48             if (*iter == p)
49                 break;
50         }
51         if (++iter != vec.end())
52         {
53             vec.erase(--iter);
54 //print(vec);
55             vec.insert(iter+q,p);
56      //       print(vec);
57         }
58         else
59         {
60             vec.pop_back();
61        //     print(vec);
62             iter = vec.end();
63             vec.insert(iter+q,p);
64          //   print(vec);
65         }
66     }
67 
68     // print
69     for (int i= 0;i&lt;vec.size();i++)
70     {
71         cout &lt;&lt;vec[i]&lt;&lt;&quot; &quot;;
72     }
73 
74     return 0;
75 }
</code></pre><h4 id="工资计算"><a href="#工资计算" class="headerlink" title="工资计算"></a>工资计算</h4><blockquote>
<p>分段问题：正着好求，反着则先正着创建一个表格，然后通过表格找到大致范围，然后推回去。</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;string.h&gt;
 3 #include &lt;stdio.h&gt;
 4 #include &lt;stdlib.h&gt;
 5 #include &lt;algorithm&gt;
 6 #include &lt;vector&gt;
 7 #include &lt;queue&gt;
 8 #include &lt;stack&gt;
 9 #define maxSize 20
10 #define ERROR -1
11 using namespace std;
12 /*
13      CCF ：
14     Time :
15     思路 ：
16 
17 */
18 int gal[10]={0,1500,4500,9000,35000,55000,80000};
19 float tax[10] ={0,0.03,0.1,0.2,0.25,0.3,0.35,0.45};
20 int sal[11]={0,3500,4955,7654,11253};
21 int main()
22 {
23     float t;
24     cin &gt;&gt;t;
25     float a = t - 3500; // 收税工资部分
26 
27     float sum = 3500;
28     for (int i=1;i&lt;7 ;i++)
29     {
30         sum += (gal[i]-gal[i-1])*(1-tax[i]);
31         sal[i+1] = sum;
32     }
33   //  for (int i = 0;i&lt;8;i++)
34  //  cout &lt;&lt; sal[i]&lt;&lt;endl;
35     float sum2 = 3500;
36     for (int i = 1;i&lt;8;i++)
37     {
38         if (t&lt;sal[i] &amp;&amp; t&gt;sal[i-1])
39         {
40             a = (t-sal[i-1])/(1-tax[i-1]);
41             sum2 += a;
42             sum2+=gal[i-2];
43         }
44         if ( t &gt; sal[7])
45         {
46             a = (t-sal[7])/(1-tax[7]);
47             sum2 +=gal[6];
48         }
49     }
50     cout &lt;&lt; (int)sum2 &lt;&lt; endl;
51 
52 
53 
54 
55 
56 
57 
58 
59     return 0;
60 }
</code></pre><p>60</p>
<pre><code> 1 /* CCF201612-2 工资计算 */  
 2 
 3 #include &lt;iostream&gt;  
 4 
 5 using namespace std;  
 6 
 7 //#define DEBUG  
 8 
 9 int salaryrange[] = {3500, 3500+1500, 3500+4500, 3500+9000, 3500+35000, 3500+55000, 3500+80000 };   
10 // 税前工资的范围
11 int taxrate[] = {3, 10, 20, 25, 30, 35, 45};  
12 const int SIZE = sizeof(salaryrange) / sizeof(int); 
13 // 定义长度不定的数组时计算size的方法 
14 
15 int range[SIZE];  
16 
17 int main()  
18 {  
19     int t, s;  
20 
21     // 计算税后工资范围   
22     range[0] = salaryrange[0];  
23     for(int i=1; i&lt;SIZE; i++) {  
24         range[i] = range[i-1] + (salaryrange[i] - salaryrange[i-1])  
25                 - (salaryrange[i] - salaryrange[i-1]) * taxrate[i-1] / 100;  
26     }  
27 
28 #ifdef DEBUG  
29     for(int i=0; i&lt;SIZE; i++)  
30         cout &lt;&lt; range[i] &lt;&lt; &quot; &quot;;  
31     cout &lt;&lt; endl;  
32 #endif  
33 
34     // 输入数据：  
35     cin &gt;&gt; t;  
36 
37     // 计算收入范围  
38     int i;  
39     for(i=0; i&lt;SIZE; i++)  
40         if(t &lt;= range[i])  
41             break;  
42 
43     // 计算税前工资  
44     if(i == 0)  
45         s = t;  
46     else {  
47         s = salaryrange[i-1] + (t - range[i-1]) * 100 / (100 - taxrate[i-1]);  
48     }  
49 
50     // 输出结果  
51     cout &lt;&lt; s &lt;&lt; endl;  
52 
53     return 0;  
54 }  
</code></pre><h4 id="消除游戏"><a href="#消除游戏" class="headerlink" title="消除游戏"></a>消除游戏</h4><blockquote>
<p>对于数组的灵活使用，两个数组，一个是变量标记数组</p>
</blockquote>
<pre><code> 1 * CCF201512-2 消除游戏 */  
 2 
 3 #include &lt;stdio.h&gt;  
 4 #include &lt;string.h&gt;  
 5 
 6 #define N 30  
 7 
 8 int a[N][N], t[N][N];  
 9 
10 int main(void)  
11 {  
12     int n, m, i, j;  
13 
14     scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  
15     for(i=0; i&lt;n; i++)  
16         for(j=0; j&lt;m; j++)  
17             scanf(&quot;%d&quot;, &amp;a[i][j]);  
18 
19  // 对二维数组的灵活运用
20     memset(t, 0, sizeof(t));  
21     // 进行行标记（可以消除则置1）  
22     for(i=0; i&lt;n; i++)  
23         for(j=0; j&lt;m-2; j++)  
24             if(a[i][j]== a[i][j + 1] &amp;&amp; a[i][j + 1] == a[i][j +2])  
25                 t[i][j] = t[i][j + 1] = t[i][j + 2] = 1;  
26     // 进行列标记（可以消除则置1）  
27     for(j=0; j&lt;m; j++)  
28         for(i=0; i&lt;n-2; i++)  
29             if(a[i][j] == a[i + 1][j] &amp;&amp; a[i + 1][j] == a[i + 2][j])  
30                 t[i][j] = t[i + 1][j] = t[i + 2][j] = 1;  
31 
32     // 重置矩阵a  
33     for(i=0; i&lt;n; i++)  
34         for(j=0; j&lt;m; j++)  
35             if(t[i][j])  
36                 a[i][j] = 0;  
37 
38     // 输出结果  
39     for(i=0; i&lt;n; i++) {  
40         for(j=0; j&lt;m; j++) {  
41             if(j != 0)  
42                 printf(&quot; &quot;);  
43             printf(&quot;%d&quot;, a[i][j]);  
44         }  
45         printf(&quot;\n&quot;);  
46     }  
47 
48     return 0;  
49 }  
</code></pre><h4 id="火车购票"><a href="#火车购票" class="headerlink" title="火车购票"></a>火车购票</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;map&gt; 
 3 /* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */
 4 // 火车购票问题
 5  using namespace std;
 6  const int LINE = 20;
 7  const int NUM = 5;
 8 int main(int argc, char** argv) {
 9     int n,v,start,end,j;
10     cin &gt;&gt; n ;
11     // 一行的座位打包，记录行数以及这行的剩余位置数 
12     map&lt;int ,int&gt; m;
13     // m初始化
14     map&lt;int,int&gt;::iterator iter;
15     for (int i = 1 ;i &lt;= LINE ; i++ )
16     {
17         m[i] = NUM ;  
18      } 
19     for (int i = 0 ; i &lt; n ; i++)
20     {
21         cin &gt;&gt; v; 
22         // 1. 一行内满足购票
23         // 逻辑：优先从小选择一行内的票，一行内从小到大排列 
24         for (iter = m.begin() ; iter != m.end() ; iter ++)
25         {
26             if ( iter-&gt;second &gt;= v )
27             {
28                 // 分配座位，输出
29                 start = (iter-&gt;first - 1) * NUM + NUM - iter-&gt;second + 1;
30                 end = start + v - 1 ; 
31                 for (j = start ; j &lt; end;j++)
32                 {
33                     cout &lt;&lt; j &lt;&lt;&quot; &quot;;
34                 }
35                 cout &lt;&lt; end &lt;&lt; endl;
36                 // 是否要删除座位 
37                 if (iter-&gt;second == v )
38                 {
39                     m.erase(iter);
40                 }else
41                 {
42                     iter-&gt;second = iter-&gt;second - v;
43                 }
44                 v = 0 ;
45                 break; 
46             }
47         }
48         // 2.多行购票  需要判断是不是最后一个 
49         bool isend = false; 
50         while (v &gt; 0)
51         {
52             for (iter = m.begin() ; iter!=m.end();iter ++){
53                 if (iter-&gt;second &gt;= v ) 
54             {
55                     // 分配座位，输出
56                 start = (iter-&gt;first - 1) * NUM + NUM - iter-&gt;second + 1;
57                 end = start + v - 1 ; 
58                 for (j = start ; j &lt; end;j++)
59                 {
60                     cout &lt;&lt; j &lt;&lt;&quot; &quot;;
61                 }
62                 if (!isend) 
63                     cout &lt;&lt; end &lt;&lt; &quot; &quot;;
64                 else
65                 {
66                     cout &lt;&lt; end &lt;&lt; endl;
67                     isend = true;
68                 }
69                 // 是否要删除座位 
70                 if (iter-&gt;second == v )
71                 {
72                     m.erase(iter);
73                 }else
74                 {
75                     iter-&gt;second = iter-&gt;second - v;
76                 }
77 
78             }else 
79             {
80                 start = (iter-&gt;first - 1) * NUM + NUM - iter-&gt;second + 1;
81                 end = start + iter-&gt;second - 1 ; 
82                 for (int j = start ; j &lt;= end;j++)
83                 {
84                     // 一定没有结束 
85                     cout &lt;&lt; j &lt;&lt;&quot; &quot;;
86                 }   
87                 v = v - iter-&gt;second; 
88                 // 要删除座位 
89                 m.erase(iter);  
90             }   
91             } 
92 
93         }
94 
95      } 
96     return 0;
97 }
</code></pre><h4 id="俄罗斯方块"><a href="#俄罗斯方块" class="headerlink" title="俄罗斯方块"></a>俄罗斯方块</h4><blockquote>
<p>coard 记录方格的具体位置，这样不用就4*4遍历了</p>
</blockquote>
<pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;map&gt; 
 3 /* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */
 4 
 5  using namespace std;
 6 
 7 const int ROW = 15;  
 8 const int COL = 10;  
 9 const int N = 4;  
10 
11 int board[ROW+1][COL];  
12 int block[N][N];  
13 struct {  
14     int row, col;  
15 } coords[N];
16 
17 int main(int argc, char** argv) {
18 
19      int row, col;  
20 
21     // 输入数据  
22     for(int i=0; i&lt;ROW; i++)  
23         for(int j=0; j&lt;COL; j++)  
24             cin &gt;&gt; board[i][j];  
25     for(int i=0; i&lt;N; i++)  
26         for(int j=0; j&lt;N; j++)  
27             cin &gt;&gt; block[i][j];  
28     cin &gt;&gt; col;  
29 
30     // 底边全放1  
31     for(int j=0; j&lt;COL; j++)  
32         board[ROW][j] = 1;  
33 
34     // 提取小方块坐标  
35     int k = 0;  
36     for(int i=N-1; i&gt;=0; i--)  
37         for(int j=0; j&lt;N; j++)  
38             if(block[i][j] == 1) {  
39                 coords[k].row = i;  
40                 coords[k].col = j;  
41                 k++;  
42             }  
43     // 模拟小方块落下过程  
44     row = 1;  
45     col--;  // 第i列表示的是数组中的i-1 
46     bool checkflag;  
47     for(;;) {  
48         checkflag = false;  
49 
50         for(int i=0; i&lt;N; i++)  
51             if(board[row + coords[i].row][col + coords[i].col] == 1) {  
52                 checkflag = true;  
53                 break;  
54             }  
55 
56         if(checkflag)  
57             break;  
58 
59         row++;  
60     }  
61     row--;  // 如果再往下一行会接触到1，就需要上移一行；或者是到了最底层 
62 
63     // 合并小方块到方格  
64     for(int i=0; i&lt;N; i++)  
65         board[row + coords[i].row][col + coords[i].col] = 1;  
66 
67        // 输出结果  
68     for(int i=0; i&lt;ROW; i++) {  
69         for(int j=0; j&lt;COL; j++) {  
70             if(j != 0)  
71                 cout &lt;&lt; &quot; &quot;;  
72             cout &lt;&lt; board[i][j];  
73         }  
74         cout &lt;&lt; endl;  
75     }  
76     return 0;
77 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（五）——查找" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（五）——查找/">计算机考研机试指南（五）——查找</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（五）——查找/" class="article-date">
  <time datetime="2018-08-20T17:21:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="编程日记-cha2-05-查找"><a href="#编程日记-cha2-05-查找" class="headerlink" title="编程日记 cha2-05 查找"></a>编程日记 cha2-05 查找</h4><h4 id="找x"><a href="#找x" class="headerlink" title="找x"></a>找x</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 #include &lt;iomanip&gt;
 6 using namespace std;
 7 /*
 8     题目：找x
 9     用时：tomato *
10     思路：
11 
12 
13 */
14 
15 int main()
16 {
17    int n,a[201],x;
18    bool flag = true;
19    while (cin &gt;&gt; n )
20    {
21        flag = true;
22        for (int i=0;i&lt;n;i++)
23         cin &gt;&gt; a[i];
24        cin &gt;&gt; x;
25        for (int i=0;i&lt;n;i++)
26             if (a[i] == x)
27             {
28                 cout&lt;&lt;i&lt;&lt;endl;
29                 flag = false;
30             }
31 
32         if (flag)
33             cout&lt;&lt;-1&lt;&lt;endl;
34    }
35 
36 
37 
38     return 0;
39 }
</code></pre><h3 id="查找学生信息"><a href="#查找学生信息" class="headerlink" title="查找学生信息"></a>查找学生信息</h3><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：查找学生信息
10     用时：tomato *
11     思路：二分法(序号是有序的)
12     为什么不能用普通的查找方法：时间复杂度o(m*n):学生个数*需要查找的次数
13     问题：strlen比较的时候总相反，猜想是因为char类型没有初始化的缘故
14     解决：最后发现因为没有sort排序的缘故,为什么一定要排序呢？？？？？
15     难点：重载大于运算符运用在sort中，看c++的书
16 
17 
18 */
19 struct Student
20 {
21     char num[5];
22     char name[10];
23     char gender[5];
24     int age;
25     bool operator &lt; (const Student &amp; A) const{
26     return strcmp(num,A.num)&lt;0;
27     }
28 }stu[1001];
29 
30 int binarySearch(char x[],int n)
31 {
32     // 在stu中根据二分法查找number x
33     int low = 0,high = n-1;
34     char temp[5];
35     while ( low &lt;= high )
36     {
37         int mid = ( low + high )/2;
38       //  cout &lt;&lt; &quot;mid num:&quot; &lt;&lt; stu[mid].num &lt;&lt;endl;
39 //        strcpy(temp,stu[mid].num);
40         if (strcmp(stu[mid].num , x)&gt;0 )
41         {
42             // x比中间小，区间变成左边
43             high = mid -1;
44         }
45         if (strcmp( stu[mid].num , x)&lt;0)
46         {
47             low = mid + 1;
48         }
49         if (strcmp (stu[mid].num , x ) == 0)
50             return mid;
51 
52     }
53     return -1;
54 }
55 
56 int main()
57 {
58 
59    int n;
60    int m;
61    char x[5];
62 
63    while (cin&gt;&gt;n)
64    {
65        for (int i=0;i&lt;n;i++)
66        {
67            scanf(&quot;%s %s %s %d&quot;,&amp;stu[i].num,&amp;stu[i].name,&amp;stu[i].gender,&amp;stu[i].age);
68        }
69        sort(stu,stu+n);
70        cin &gt;&gt; m;
71        for (int i=0;i&lt;n;i++)
72             cout &lt;&lt;stu[i].num&lt;&lt;&#39; &#39;&lt;&lt;stu[i].name&lt;&lt;&#39; &#39;&lt;&lt;stu[i].gender&lt;&lt;&#39; &#39;&lt;&lt;stu[i].age&lt;&lt;endl;
73 
74        for (int i=0 ; i&lt;m ; i++)
75        {
76            cin&gt;&gt;x;
77            int result_i = binarySearch(x,n);
78            if (result_i == -1)
79                 cout&lt;&lt;&quot;No Answer!&quot;&lt;&lt;endl;
80            else
81                 cout &lt;&lt;stu[result_i].num&lt;&lt;&#39; &#39;&lt;&lt;stu[result_i].name&lt;&lt;&#39; &#39;&lt;&lt;stu[result_i].gender&lt;&lt;&#39; &#39;&lt;&lt;stu[result_i].age&lt;&lt;endl;
82         }
83    }
84 
85 
86 
87     return 0;
88 }
</code></pre><h3 id="打印极值点下标"><a href="#打印极值点下标" class="headerlink" title="打印极值点下标"></a>打印极值点下标</h3><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;string&gt;
 5 #include &lt;stdio.h&gt;
 6 #include &lt;iomanip&gt;
 7 using namespace std;
 8 /*
 9     题目：打印极值点下标
10     用时：tomato *
11     思路：经过观察，只需比较中间值和两侧数据的大小：比两侧都大或比两侧都小
12     首尾数据比较特殊：只要不和旁边的数据相等则输出
13     注意：打印的时候最后一个数字后面没有空格,因此我把所有即将被打印的索引存放到数组中，最后一起输出
14 
15 
16 
17 
18 */
19 
20 
21 int main()
22 {
23     int k,a[80];
24     int x[80];
25     int cur = 0;
26     while (cin&gt;&gt;k)
27     {
28         for (int i=0;i&lt;k;i++)
29             cin&gt;&gt;a[i];
30 
31         for (int i=0;i&lt;k;i++)
32         {
33             if (i==0 &amp;&amp; a[i+1]!=a[i])
34             {
35                 x[cur] = i;
36                 cur ++;
37                 continue;
38             }
39             if (i==k-1 &amp;&amp; a[i]!=a[i-1])
40             {
41                 x[cur] = i;
42                 cur ++;
43                 break;
44             }
45             if ((a[i-1] &lt; a[i] &amp;&amp; a[i+1] &lt; a[i]) || (a[i-1] &gt; a[i] &amp;&amp; a[i+1] &gt; a[i]))
46             {
47                 x[cur] = i;
48                 cur ++;
49             }
50         }
51         for (int i=0;i&lt;cur-1;i++)
52         {
53             cout &lt;&lt; x[i]&lt;&lt;&#39; &#39;;
54         }
55         cout &lt;&lt;x[cur-1];
56 
57     }
58 
59 
60 
61     return 0;
62 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（四）——排版题" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（四）——排版题/">计算机考研机试指南（四）——排版题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（四）——排版题/" class="article-date">
  <time datetime="2018-08-20T17:20:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="编程日记-cha2-04-排版题"><a href="#编程日记-cha2-04-排版题" class="headerlink" title="编程日记 cha2-04 排版题"></a>编程日记 cha2-04 排版题</h4><h4 id="输出梯形（oj无）"><a href="#输出梯形（oj无）" class="headerlink" title="输出梯形（oj无）"></a>输出梯形（oj无）</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 #include &lt;iomanip&gt;
 6 using namespace std;
 7 /*
 8     题目：输出梯形
 9     用时：tomato *
10     思路：输出时设置宽度setw默认为左对齐，只能人工添加空格
11 
12 
13 */
14 
15 int main()
16 {
17     int h;
18     while (cin&gt;&gt;h)
19     {
20         int width = h + 2*(h-1);
21         for (int i=0;i&lt;h;i++)
22         {
23         // cout&lt;&lt;setw(width)&lt;&lt;&quot; &quot;; // ★头4文件 iomanip
24             for (int j = 1;j&lt;=2*(h-i-1);j++)
25                 cout&lt;&lt;&#39; &#39;;
26             for (int j = 1;j&lt;=(h+2*i);j++)
27                 cout&lt;&lt;&#39;*&#39;;
28             cout&lt;&lt;endl;
29         }
30     }
31 
32 
33 
34     return 0;
35 }
</code></pre><h4 id="叠筐"><a href="#叠筐" class="headerlink" title="叠筐"></a>叠筐</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 #include &lt;iomanip&gt;
 6 using namespace std;
 7 /*
 8     题目：叠筐
 9     用时：tomato *
10     思路：先排版再输出，n*n的二维数组，由内向外扩张圈
11     填充完之后填充四个角，最后打印输出矩阵
12 
13 
14 */
15 
16 int main()
17 {
18    int n;
19    char center,out;
20    char buffer[80][80];
21    int i,j,k;
22    char nc;
23    bool flag = true;
24    while (scanf(&quot;%d %c %c&quot;,&amp;n,&amp;center,&amp;out)!=EOF)
25    {
26        // 因为格式问题：第一个筐不输出空行，非第一个筐输出空行再输出筐
27        if (flag)
28        {
29             flag = false;
30        }
31        else 
32         cout&lt;&lt;endl;
33        for (i=0,j=0;i&lt;(n+1)/2;i++,j++)
34        {
35            if (((n+1)/2)%2 == 0 )
36                 nc = i%2==0?out: center;
37             else
38                 nc = i%2==0?center:out;
39 
40            //选择当前圈字符，现在的问题便转化为如何塑造一个空心的筐，循环缩小
41            int width = n-2*i;//筐的宽度、高度：循环次数,起点为(i,j)
42 
43            for (k = 0 ; k &lt; width ; k++)
44             {
45                 buffer[i][j+k] = nc; // 筐上
46                 buffer[n-1-i][j+k] = nc; // 下
47                 buffer[i+k][j] = nc; // 左
48                 buffer[i+k][n-1-j] = nc; // 右
49             }
50 
51        }
52        if (n!=1)  //当N=1时没有角可以去！★★★ 如果不判断会导致不能所有用例都通过测试
53        {
54                   // 去掉四个角
55             buffer[0][0] = &#39; &#39;;
56             buffer[0][n-1]=&#39; &#39;;
57             buffer[n-1][0]=&#39; &#39;;
58             buffer[n-1][n-1]=&#39; &#39;;
59        }
60 
61        for (i=0;i&lt;n;i++)
62        {
63            for (j=0;j&lt;n;j++)
64            {
65                cout&lt;&lt;buffer[i][j];
66            }
67            cout&lt;&lt;endl;
68        }
69    }
70 
71 
72 
73     return 0;
74 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（三）——hash" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（三）——hash/">计算机考研机试指南（三）——hash</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（三）——hash/" class="article-date">
  <time datetime="2018-08-20T17:18:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编程日记-cha2-3-Hash的应用"><a href="#编程日记-cha2-3-Hash的应用" class="headerlink" title="编程日记 cha2-3 Hash的应用"></a>编程日记 cha2-3 Hash的应用</h3><h4 id="统计同成绩学生人数"><a href="#统计同成绩学生人数" class="headerlink" title="统计同成绩学生人数"></a>统计同成绩学生人数</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 using namespace std;
 6 /*
 7     题目：统计同成绩学生人数
 8     用时：
 9     思路：hash数组统计
10 
11 */
12 
13 
14 int main()
15 {
16     int n;
17     int hs[101]={0};
18     int grade ;
19     int x;
20     while (scanf(&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n!=0)
21     {
22         for (int i=0;i&lt;n;i++)
23         {
24             cin &gt;&gt; grade ;
25             hs[grade]++;
26         }
27         cin &gt;&gt; x;
28         cout&lt;&lt;hs[x]&lt;&lt;endl;
29     }
30 
31     return 0;
32 }
</code></pre><h4 id="Sort（牛客没有）"><a href="#Sort（牛客没有）" class="headerlink" title="Sort（牛客没有）"></a>Sort（牛客没有）</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 using namespace std;
 6 /*
 7     题目：Sort
 8     用时：* tomato
 9     思路：hash数组统计
10     1.排序：N属于[0,1000000],O(nlogn)的快排也会使时间复杂度达到千万级以上
11     2.输入的数字属于[-500000,500000]的区间，创建数组a,把数字对应序号存进去，
12     时间复杂度则为遍历一边整个100万级的数组而已
13 
14 */
15 int a[1000001]={0};
16 
17 int main()
18 {
19     int n,m;
20     int num;
21     while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
22     {
23         for (int i=0;i&lt;n;i++)
24         {
25             cin&gt;&gt;num;
26             a[num+500000] ++;
27         }
28         int i = 1000000;
29         while (i-- &amp;&amp; m&gt;0)
30         {
31             if (a[i])
32             {
33                 m--;
34                 cout&lt;&lt;i-500000&lt;&lt;&#39; &#39;;
35             }
36         }
37     }
38     return 0;
39 }
</code></pre><h4 id="谁是你的潜在朋友"><a href="#谁是你的潜在朋友" class="headerlink" title="谁是你的潜在朋友"></a>谁是你的潜在朋友</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 using namespace std;
 6 /*
 7     题目：谁是你的潜在朋友
 8     用时：* tomato
 9     思路：hash数组统计 书的编号是1-200
10     但是需要根据学生的编号和书号决定他的潜在朋友个数，
11     通过一个数组stu解决此问题，
12     因为N是动态输入，我们可以用malloc动态分配
13 
14 
15 */
16 
17 
18 int main()
19 {
20     int n,m,num;
21     int book[201]={0};
22     int *stu ;
23     while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
24     {
25         stu = (int *)malloc(n*sizeof(int));
26         for (int i=0;i&lt;n;i++)
27         {
28             cin &gt;&gt; num ;
29             book[num] ++ ;
30             stu[i]=num;
31         }
32         for (int i=0;i&lt;n;i++)
33         {
34             if (book[stu[i]]&gt;1)
35                 cout &lt;&lt;book[stu[i]]-1&lt;&lt;endl;
36             else
37                 cout&lt;&lt;&quot;BeiJu&quot;&lt;&lt;endl;
38         }
39 
40 
41     }
42 
43     return 0;
44 }
</code></pre><h4 id="剩下的树"><a href="#剩下的树" class="headerlink" title="剩下的树"></a>剩下的树</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 using namespace std;
 6 /*
 7     题目：剩下的树
 8     用时：* tomato
 9     思路：hash数组统计
10 
11 
12 */
13 
14 int road[10001]={0};
15 int main()
16 {
17 
18     int l;// 1&lt;= l &lt;=10000
19     int m ;//1 &lt;= m &lt;= 100
20     int i,j;
21     int left,right;
22     int c=0;
23     for (i=0;i&lt;10001;i++)
24         road[i]=1;
25     while (scanf(&quot;%d %d&quot;,&amp;l,&amp;m)!=EOF)
26     {
27         for (i=0;i&lt;m;i++)
28         {
29             cin &gt;&gt;left &gt;&gt; right;
30             for (j=left;j&lt;right+1;j++)
31             {
32                 if (road[j]&gt;0)
33                     road[j]--; // 有树才需要砍树
34             }
35 
36         }
37         for (i=0;i&lt;=l;i++)
38             if (road[i]&gt;0)
39                 c++;
40         cout &lt;&lt; c &lt;&lt;endl;
41 
42     }
43     return 0;
44 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（二）——日期类问题" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（二）——日期类问题/">计算机考研机试指南（二）——日期类问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（二）——日期类问题/" class="article-date">
  <time datetime="2018-08-20T17:17:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编程笔记-cha2-2-日期类问题"><a href="#编程笔记-cha2-2-日期类问题" class="headerlink" title="编程笔记 cha2-2 日期类问题"></a>编程笔记 cha2-2 日期类问题</h3><h4 id="日期差值"><a href="#日期差值" class="headerlink" title="日期差值"></a>日期差值</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 #define isRein(x) ((x%100!=0)&amp;&amp;(x%4==0)) || (x%400 ==0)?1:0
 6 using namespace std;
 7 /*
 8     题目：日期差值
 9 
10 */
11 int dayOfMonth[13][2] =
12 {
13   0,0,// 便于直接从1月开始访问
14   31,31,
15   28,29,
16   31,31,
17   30,30,
18   31,31,
19   30,30,
20   31,31,
21   31,31,
22   30,30,
23   31,31,
24   30,30,
25   31,31
26 };
27 
28 struct Date
29 {
30     int Year;
31     int Month;
32     int Day;
33     void nextDay()
34     {
35         if (++Day &gt; dayOfMonth[Month][isRein(Year)])
36         {
37             Day = 1;
38             Month ++ ;
39         }
40         if (Month&gt;12)
41         {
42             Month = 1;
43             Year ++;
44         }
45 
46 
47     }
48 };
49 int buffer[5000][12][31];
50 void preProcess()
51 {
52     Date tmp ;
53     tmp.Day = 1;
54     tmp.Month = 1;
55     tmp.Year = 0;
56     int c = 1;
57     while (tmp.Year &lt; 5000)
58     {
59         buffer[tmp.Year][tmp.Month][tmp.Day] = c;
60         c++;
61         tmp.nextDay();
62     }
63 }
64 int main()
65 {
66     preProcess();
67     int y1,y2,m1,m2,d1,d2;
68     while ( scanf(&quot;%4d%2d%2d&quot;,&amp;y1,&amp;m1,&amp;d1)!=EOF )
69     {
70         scanf(&quot;%4d%2d%2d&quot;,&amp;y2,&amp;m2,&amp;d2);
71         int ans = abs(buffer[y1][m1][d1]-buffer[y2][m2][d2]);
72         printf(&quot;%d\n&quot;,ans+1);
73     }
74     return 0;
75 }
</code></pre><h4 id="今年的第几天"><a href="#今年的第几天" class="headerlink" title="今年的第几天"></a>今年的第几天</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 #define isRein(x) ((x%100!=0)&amp;&amp;(x%4==0)) || (x%400 ==0)?1:0
 6 using namespace std;
 7 /*
 8     题目：今年的第几天
 9     思路：减去本年的元旦那一天
10 
11 */
12 int dayOfMonth[13][2] =
13 {
14   0,0,// 便于直接从1月开始访问
15   31,31,
16   28,29,
17   31,31,
18   30,30,
19   31,31,
20   30,30,
21   31,31,
22   31,31,
23   30,30,
24   31,31,
25   30,30,
26   31,31
27 };
28 
29 struct Date
30 {
31     int Year;
32     int Month;
33     int Day;
34     void nextDay()
35     {
36         if (++Day &gt; dayOfMonth[Month][isRein(Year)])
37         {
38             Day = 1;
39             Month ++ ;
40         }
41         if (Month&gt;12)
42         {
43             Month = 1;
44             Year ++;
45         }
46 
47 
48     }
49 };
50 int buffer[5000][12][31];
51 void preProcess()
52 {
53     Date tmp ;
54     tmp.Day = 1;
55     tmp.Month = 1;
56     tmp.Year = 0;
57     int c = 1;
58     while (tmp.Year &lt; 5000)
59     {
60         buffer[tmp.Year][tmp.Month][tmp.Day] = c;
61         c++;
62         tmp.nextDay();
63     }
64 }
65 int main()
66 {
67     preProcess();
68     int y1,d1,m1;
69     while ( scanf(&quot;%4d %2d %2d&quot;,&amp;y1,&amp;m1,&amp;d1)!=EOF )
70     {
71         int ans = abs(buffer[y1][m1][d1]-buffer[y1][1][1]);
72         printf(&quot;%d\n&quot;,ans+1);
73     }
74     return 0;
75 }
</code></pre><h4 id="打印日期"><a href="#打印日期" class="headerlink" title="打印日期"></a>打印日期</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 #define isRein(x) ((x%100!=0)&amp;&amp;(x%4==0)) || (x%400 ==0)?1:0
 6 using namespace std;
 7 /*
 8     题目：日期差值
 9 
10 */
11 int dayOfMonth[13][2] =
12 {
13   0,0,// 便于直接从1月开始访问
14   31,31,
15   28,29,
16   31,31,
17   30,30,
18   31,31,
19   30,30,
20   31,31,
21   31,31,
22   30,30,
23   31,31,
24   30,30,
25   31,31
26 };
27 
28 struct Date
29 {
30     int Year;
31     int Month;
32     int Day;
33     void nextDay()
34     {
35         if (++Day &gt; dayOfMonth[Month][isRein(Year)])
36         {
37             Day = 1;
38             Month ++ ;
39         }
40         if (Month&gt;12)
41         {
42             Month = 1;
43             Year ++;
44         }
45 
46 
47     }
48 };
49 int buffer[5000][12][31];
50 void preProcess()
51 {
52     Date tmp ;
53     tmp.Day = 1;
54     tmp.Month = 1;
55     tmp.Year = 0;
56     int c = 1;
57     while (tmp.Year &lt; 5000)
58     {
59         buffer[tmp.Year][tmp.Month][tmp.Day] = c;
60         c++;
61         tmp.nextDay();
62     }
63 }
64 int main()
65 {
66     preProcess();
67     int y1,num;
68     while ( scanf(&quot;%4d %d&quot;,&amp;y1,&amp;num)!=EOF )
69     {
70         int yuandan = buffer[y1][1][1];
71         int today = yuandan + num -1 ;
72         for (int i = 1 ; i &lt; 13 ;i++)
73             for (int j = 1;j &lt; 32 ; j++)
74         {
75             if (today == buffer[y1][i][j])
76                 printf(&quot;%d-%02d-%02d\n&quot;,y1,i,j); // 控制输出格式，填充0
77         }
78 
79 
80     }
81     return 0;
82 }
</code></pre><h4 id="Day-ofWeek"><a href="#Day-ofWeek" class="headerlink" title="Day ofWeek"></a>Day ofWeek</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;algorithm&gt;
  3 #include &lt;string.h&gt;
  4 #include &lt;stdio.h&gt;
  5 #define isLeap(x) (x%100 != 0 &amp;&amp; x%4 == 0)||(x % 400 == 0)?1:0
  6 using namespace std;
  7 /*
  8     题目：Day ofweek
  9     用时：
 10     思路：1. 月份和星期日的转换器:利用字符串数组的索引对应字符串
 11         2. 已知：今天是星期四 2018 3/8
 12         3. 求：今天和求取的那天差了几天，以7位倍数循环
 13         4. 这两天谁在前，谁在后，如何通过7来求星期几
 14 
 15 */
 16 
 17     char tm[13][10] = {
 18     &quot;&quot;,
 19     &quot;January&quot;,
 20     &quot;February&quot;,
 21     &quot;March&quot;,
 22     &quot;April&quot;,
 23     &quot;May&quot;,
 24     &quot;June&quot;,
 25     &quot;July&quot;,
 26     &quot;August&quot;,
 27     &quot;September&quot;,
 28     &quot;October&quot;,
 29     &quot;November&quot;,
 30     &quot;December&quot;
 31     };
 32 
 33     char tw[7][10] = {
 34     &quot;Sunday&quot;, // 0 注意这里Sunday是0
 35     &quot;Monday&quot;, // 1
 36     &quot;Tuesday&quot;,
 37     &quot;Wednesday&quot;,
 38     &quot;Thursday&quot;,
 39     &quot;Friday&quot;,
 40     &quot;Saturday&quot;
 41     };
 42 
 43 int dayOfMonth[13][2]
 44 {
 45     0,0,
 46     31,31,
 47     28,29,
 48     31,31,
 49     30,30,
 50     31,31,
 51     30,30,
 52     31,31,
 53     31,31,
 54     30,30,
 55     31,31,
 56     30,30,
 57     31,31
 58 };
 59 struct Date
 60 {
 61     int year;
 62     int month;
 63     int day;
 64     void nextDay()
 65     {
 66         if (++day &gt; dayOfMonth[month][isLeap(year)])
 67         {
 68             day = 1;
 69             month++;
 70         }
 71         if (month &gt; 12 )
 72         {
 73             month = 1;
 74             year ++;
 75         }
 76     }
 77 };
 78 
 79 int buffer[3001][13][31];
 80 void preProcessing()
 81 {
 82     int c = 1;
 83     Date date;
 84     date.year = 0 ;
 85     date.month = 1;
 86     date.day = 1;
 87     while ( date.year &lt; 3001)
 88     {
 89         buffer[date.year][date.month][date.day] = c;
 90         c++;
 91         date.nextDay();
 92     }
 93 }
 94 int numberMonth (char month[])
 95 {
 96     for (int i=1 ;i&lt;13;i++)
 97     {
 98         if (strcmp(tm[i],month)==0)
 99         {
100             return i;
101         }
102     }
103     return 0;
104 }
105 
106 int main()
107 {
108     preProcessing();
109     int day,year;
110     char Month[10];
111     int today = buffer[2012][7][16];
112     int month,thatDay;
113     while (scanf(&quot;%d %s %d&quot;,&amp;day,Month,&amp;year)!=EOF)
114     {
115         month = numberMonth(Month);
116         thatDay = buffer[year][month][day];
117         // 如何根据差值计算星期几thatDayw?
118         int days = thatDay - today +1;
119         printf(&quot;%s\n&quot;,tw[(days%7+7)%7]);
120 
121 
122 
123     }
124     return 0;
125 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-计算机考研机试指南（一）——排序" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/计算机考研机试指南（一）——排序/">计算机考研机试指南（一）——排序</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/计算机考研机试指南（一）——排序/" class="article-date">
  <time datetime="2018-08-20T17:15:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="编程笔记-cha-2-1-排序"><a href="#编程笔记-cha-2-1-排序" class="headerlink" title="编程笔记 cha 2-1 排序"></a>编程笔记 cha 2-1 排序</h3><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="1-排序（牛客网）"><a href="#1-排序（牛客网）" class="headerlink" title="1. 排序（牛客网）"></a>1. 排序（牛客网）</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 using namespace std;
 4 /*
 5     题目：排序
 6     思路：1--n冒泡排序、选择排序、快排
 7 */
 8 void bubbleSort(int a[],int n){
 9     int t;
10     for (int i=0;i&lt;n-1;i++){
11         for (int j=0;j&lt;n-i-1;j++){
12             if (a[j]&gt;a[j+1]){
13                 t = a[j];
14                 a[j] = a[j+1];
15                 a[j+1] = t;
16             }
17         }
18     }
19 }
20 void selectSort(int a[],int n){
21     int k,t;
22     for (int i=0;i&lt;n-1;i++){
23         k = i;
24         for (int j=i+1;j&lt;n;j++){
25             if (a[j]&lt;a[k]){
26                 k = j;
27             }
28         }
29         if (k!=i){
30             t = a[k];
31             a[k] = a[i];
32             a[i] = t;
33         }
34     }
35 }
36 void Qsort(int a[],int low,int high){
37     if (low &gt;= high)
38         return;
39 
40     int first = low ;
41     int last = high ;
42     int key = a[first];
43     while (first &lt; last){
44         while (first &lt; last &amp;&amp; a[last] &gt;= key){
45             --last; // last先减一，再与first比较
46         }
47         a[first] = a[last];
48         while (first &lt; last &amp;&amp; a[first] &lt;= key){
49             ++first;
50         }
51         a[last] = a[first];
52     }
53     a[first]=key; // 交换过程中key并没有交换，此时first/last之前的比key小，之后的比key大，递归调用
54     Qsort(a,low,first-1);
55     Qsort(a,first+1,high);
56 
57 }
58 bool cmp(int x,int y){
59     return x&gt;y;
60 }
61 void print(int a[],int n){
62     for (int i=0;i&lt;n;i++)
63         cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;
64     cout&lt;&lt;endl;
65 }
66 int main()
67 {
68     int n,a[101];
69     while (cin &gt;&gt; n){
70         for (int i=0;i&lt;n;i++)
71             cin &gt;&gt; a[i];
72         //bubbleSort(a,n);
73         //selectSort(a,n);
74         //sort(a,a+n);//内置快排升序算法，推荐使用
75         //sort(a,a+n,cmp);重载降序
76         Qsort(a,0,n-1);
77         print(a,n);
78 
79     }
80     return 0;
81 }
</code></pre><h4 id="2-成绩排序"><a href="#2-成绩排序" class="headerlink" title="2.成绩排序"></a>2.成绩排序</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 using namespace std;
 5 /*
 6     题目：成绩排序
 7     思路：内置排序函数+重构cmp
 8 */
 9 struct Stu{
10     char name[100];
11     // string name;
12     int age;
13     int grade;
14 };
15 bool cmp(Stu s1,Stu s2){
16     if (s1.grade != s2.grade)
17         return s1.grade &lt; s2.grade;//成绩低的在前面
18     int tmp = strcmp(s1.name,s2.name);
19     // int tmp = s1.name - s2.name;
20     if (tmp != 0)
21         return tmp &lt; 0; // 字典序小的在前面
22     return s1.age &lt; s2.age;
23 }
24 void print(Stu s[],int n){
25     for (int i=0;i&lt;n;i++)
26         cout &lt;&lt; s[i].name &lt;&lt; &#39; &#39;&lt;&lt;s[i].age&lt;&lt;&#39; &#39;&lt;&lt;s[i].grade&lt;&lt;endl;
27 
28 }
29 int main()
30 {
31     int n;
32     Stu s[1001];
33     while (cin &gt;&gt; n){
34         for (int i=0;i&lt;n;i++)
35             cin &gt;&gt; s[i].name&gt;&gt;s[i].age&gt;&gt;s[i].grade;
36         sort(s,s+n,cmp);
37         print(s,n);
38     }
39 
40 
41     return 0;
42 }
</code></pre><h4 id="特殊排序"><a href="#特殊排序" class="headerlink" title="特殊排序"></a>特殊排序</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 using namespace std;
 5 /*
 6     题目：特殊排序
 7     思路：内置排序函数+重构cmp
 8 */
 9 
10 void print(int a[],int n){
11     cout&lt;&lt;a[n-1]&lt;&lt;endl;
12     if (n!=1){
13         for (int i=0;i&lt;n-2;i++)
14             cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;
15         cout &lt;&lt;a[n-2]&lt;&lt;endl;
16         // 提示格式错误：最后一个数后面没有空格
17     }
18     else{
19         cout&lt;&lt;-1&lt;&lt;endl;
20     }
21 }
22 int main()
23 {
24     int n,a[1001];
25     while (cin &gt;&gt; n){
26         for (int i=0;i&lt;n;i++)
27             cin &gt;&gt; a[i];
28         sort(a,a+n);
29         print(a,n);
30     }
31 
32 
33     return 0;
34 }
</code></pre><h4 id="EXCEL排序"><a href="#EXCEL排序" class="headerlink" title="EXCEL排序"></a>EXCEL排序</h4><pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;algorithm&gt;
  3 #include &lt;string.h&gt;
  4 using namespace std;
  5 /*
  6     题目：EXCEL排序
  7     遇到的问题：定义number和name同时为char类型时，在一行内输入&quot;010000 ack 30 &quot;时空格
  8     会被视为字符串内的一个字符，因此连续cin多个字符串时应当用回车来分离字符串。
  9     这里审题不清：将number定义为整数够用。
 10 
 11     报错：编译错误：
 12     error: control may reach end of non-void function [-Werror,-Wreturn-type]
 13     原因：某些测试条件下函数没有响应的返回
 14 
 15     输出int number时为了变成&#39;000001&#39;的6位形式需加上my_itoa()函数
 16 
 17     当number和name都是char[]类型时的另一种输入方法：
 18     scanf(&quot;%s %s %d&quot;,buf[i].num,buf[i].name,&amp;buf[i].score);
 19 */
 20 struct Stu{
 21     int number;
 22     char name[8];
 23     int grade;
 24 }student[100000];
 25 int c;
 26 /*
 27 替代写法：
 28  cout &lt;&lt; setw(6) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; list[i].num &lt;&lt; &quot; &quot;;
 29  setw设置输出宽度为6位
 30  除去输出数据num所占位数外其余填充fill0 
 31 */
 32 char *my_itoa(int n)
 33 {
 34     static char str[7];
 35     int i;
 36     for(i=0;i&lt;6;i++)
 37         str[i]=&#39;0&#39;;
 38     str[7]=&#39;\0&#39;;
 39     i=5;
 40     while(n)
 41     {
 42         str[i--]=n%10 + &#39;0&#39;;
 43         n/=10;
 44     }
 45     return str;
 46 }
 47 bool cmp(Stu a,Stu b)
 48 {
 49     switch(c)
 50     {
 51     case 1:return a.number&lt;b.number;
 52     case 2:
 53         if (strcmp(a.name,b.name)==0)
 54             return a.number-b.number&lt;0;
 55         else
 56             return strcmp(a.name,b.name)&lt;=0;
 57     case 3:
 58         if (a.grade==b.grade)
 59             return a.number&lt;b.number;
 60         else
 61             return a.grade&lt;=b.grade;
 62     default:return 0;
 63     }
 64 }
 65 
 66 /*
 67 cmp函数的另一种写法：
 68 
 69 
 70 bool cmp1(stu a, stu b) {
 71 
 72     return a.num &lt; b.num; // 递增，当a&lt;b时返回真
 73 
 74 }
 75 
 76 bool cmp2(stu a, stu b) {
 77 
 78     return a.name &lt;= b.name;// 非递减 
 79 
 80 }
 81 
 82 bool cmp3(stu a, stu b) {
 83 
 84     if (a.grade != b.grade) {
 85 
 86         return a.grade &lt;= b.grade; // 非递减 
 87 
 88     }
 89 
 90     else {
 91 
 92         return a.num &lt; b.num;
 93 
 94     }
 95 
 96 }
 97 */
 98 void print(int n)
 99 {
100     cout&lt;&lt;&quot;Case:&quot;&lt;&lt;endl;
101     for (int i=0;i&lt;n;i++)
102     {
103         cout&lt;&lt;my_itoa(student[i].number)&lt;&lt;&quot; &quot;&lt;&lt;student[i].name&lt;&lt;&quot; &quot;&lt;&lt;student[i].grade&lt;&lt;endl;
104     }
105 }
106 int main()
107 {
108 
109     int n;
110     while (cin&gt;&gt;n)
111     {
112         cin&gt;&gt;c;
113         for (int i=0;i&lt;n;i++)
114         {
115             cin&gt;&gt;student[i].number;
116             cin&gt;&gt;student[i].name;
117             cin&gt;&gt;student[i].grade;
118         }
119         sort(student,student+n,cmp);
120         print(n);
121 
122     }
123 
124 
125 
126 
127     return 0;
128 }
</code></pre><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><pre><code> 1 #include &lt;iostream&gt;
 2 #include &lt;algorithm&gt;
 3 #include &lt;string.h&gt;
 4 #include &lt;stdio.h&gt;
 5 using namespace std;
 6 /*
 7     题目：字符串内排序
 8     思路：字符串相当于一个数组，字母本质是个整数，所以用sort()配合strlen()求出字符串长度绰绰有余啦。
 9 */
10 int main()
11 {
12     char str[200];
13     while (scanf(&quot;%s&quot;,str)!=EOF)
14     {
15         sort(str,str+strlen(str));
16         cout&lt;&lt;str&lt;&lt;endl;
17     }
18     return 0;
19 }
</code></pre><p> 排序总结：</p>
<p>头文件：algorithm.h</p>
<p>快排函数：sort（数组名，数组名+数组长度，比较函数（默认为从小到大排序））</p>
<p>比较函数的定义：</p>
<p>（1）非结构体的基本数据类型作为参数的比较函数定义</p>
<pre><code>bool cmp(int x,int y)
{
    return x&lt;y; // 递增
}
bool cmp(int x,int y)
{
    return x&lt;=y; // 非递减
}
bool cmp(int x,int y)
{
    return x&gt;y; // 递减
}
bool cmp(int x,int y)
{
    return x&gt;=y; // 非递增
}
</code></pre><p>（2）结构体的比较函数定义</p>
<pre><code> 1 struct stu
 2 {
 3     char name[101];
 4     int age;
 5     int score;
 6     bool operator&lt;(const stu &amp;b)const 
 7 {
 8     // 分数不相同时分数低者在前
 9     if (score!=b.score) return score&lt;b.score;
10     int tmp=strcmp(name,b.name);
11     if (tmp!=0) return tmp&lt;0;
12     else return age &lt; b.age;
13 }
14 };
15 bool cmp(const stu &amp;a, const stu &amp;b)
16 {
17     // 分数不相同时分数低者在前
18     if (a.score!=b.score) return a.score&lt;b.score;
19     int tmp=strcmp(a.name,b.name);
20     if (tmp!=0) return tmp&lt;0;
21     else return a.age &lt; b.age;
22 }
</code></pre><p>第一种方式：定义cmp函数，参数最好写成const 数据类型 &amp;变量名的形式，防止调用函数过程中对于变量的改变</p>
<p>第二种方式：结构体内重载&lt;运算符，此时参数和成员函数进行比较，仅需要一个参数即可。注意此时函数要定义成const的不可变函数，否则会报错。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-大学生创新项目认真投一篇中文核心的坎坷故事" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/大学生创新项目认真投一篇中文核心的坎坷故事/">大学生创新项目认真投一篇中文核心的坎坷故事</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/大学生创新项目认真投一篇中文核心的坎坷故事/" class="article-date">
  <time datetime="2018-08-20T17:13:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="格式修改注意内容"><a href="#格式修改注意内容" class="headerlink" title="格式修改注意内容"></a>格式修改注意内容</h2><h2 id="Part-1-参考文献自动编号"><a href="#Part-1-参考文献自动编号" class="headerlink" title="Part 1 : 参考文献自动编号"></a>Part 1 : 参考文献自动编号</h2><ul>
<li>参考文献这个东西， 最好在写论文的过程中就把文献整理好。给大家推荐一个方法：打开百度学术，输入查询文献标题，点击引用便可得到所需论文的参考文献格式。</li>
<li>最后将所有的参考文献依次排列在文章末尾，建立编号格式即可。</li>
<li>具体的”参考文献自动标注以及论文中插入参考文献脚标方法”,请参考此链接：<br><a href="https://jingyan.baidu.com/article/066074d644f427c3c21cb0ab.html" target="_blank" rel="noopener">参考文献自动标号</a></li>
</ul>
<h2 id="Part-2-参考文件交叉引用、一处如何同时引用多篇参考文献"><a href="#Part-2-参考文件交叉引用、一处如何同时引用多篇参考文献" class="headerlink" title="Part 2 :参考文件交叉引用、一处如何同时引用多篇参考文献"></a>Part 2 :参考文件交叉引用、一处如何同时引用多篇参考文献</h2><ul>
<li>遇到一个问题：论文中一处同时引用多篇文献时，如果单纯的手输”[2-5]”,假装这是我交叉引用的参考文献，那么生成PDF式此不正经格式便不会逃过其法眼。那么要使用字体隐藏方法来解决该问题：<br><a href="https://jingyan.baidu.com/article/d2b1d102a252ac5c7e37d40d.html" target="_blank" rel="noopener">字体隐藏方法</a></li>
</ul>
<h2 id="Part-3-首页通信作者脚注修改、如何分栏不分脚注"><a href="#Part-3-首页通信作者脚注修改、如何分栏不分脚注" class="headerlink" title="Part 3 : 首页通信作者脚注修改、如何分栏不分脚注"></a>Part 3 : 首页通信作者脚注修改、如何分栏不分脚注</h2><ul>
<li><p>我们知道，论文首页末尾一般都有一条横线+通信作者个人信息的内容，这就是所谓的脚注，那么应该如何生成脚注呢？生成脚注后如果点击 页面设置 -&gt; 分栏，注意分栏是除了摘要和关键词、参考文献之外，其间的正文内容均是需要分栏的。为了避免脚注也被分栏，需要点击”脚注”右下角的扩展符号 -&gt; 脚注布局中的列应为”1”。这样就不用担心脚注也被分栏啦！<br><a href="https://jingyan.baidu.com/article/425e69e69634f0be15fc162e.html" target="_blank" rel="noopener">生成脚注（横线及以下内容）</a></p>
</li>
<li><p>通讯作者前面有两个特殊的星号，生成方法：插入 -&gt; 符号 -&gt; ※ 即可啦！</p>
</li>
<li>注意：通信作者中Email的正确打开方式是：”E-mail”,字体统一为times new roman这个大家应该已经知道了吧~</li>
</ul>
<h2 id="Part-4-word转成PDF格式时采用虚拟打印而不是直接转成PDF"><a href="#Part-4-word转成PDF格式时采用虚拟打印而不是直接转成PDF" class="headerlink" title="Part 4 : word转成PDF格式时采用虚拟打印而不是直接转成PDF"></a>Part 4 : word转成PDF格式时采用虚拟打印而不是直接转成PDF</h2><ul>
<li>搞笑的是，最后终于改好的word版论文，在生成PDF的时候不知道mathtype和PDF抽了什么风，公式莫名其妙地有的不显示、有的扭在一起，害得我捣鼓了半天没整明白咋个回事。然后发现只要生成PDF时采用虚拟打印的方式：点击 文件 -&gt; 打印 -&gt; foxer，产生保存目录，保存后便产生PDF，而且重要的是通过这种方式产生的PDF的公式没有抽风哦~</li>
</ul>
<h2 id="Part-5-格式上应该注意哪些地方的修改"><a href="#Part-5-格式上应该注意哪些地方的修改" class="headerlink" title="Part 5 : 格式上应该注意哪些地方的修改"></a>Part 5 : 格式上应该注意哪些地方的修改</h2><ul>
<li><p>像我这次投稿的出版社是”中国安全科学学报”，那么就在百度上先找到相关的出版社格式要求，比如：</p>
</li>
<li><p>论文构成及顺序：题目-&gt;作者-&gt;单位-&gt;中、英文摘要-&gt;中、英文关键词-&gt;正文-&gt;致谢-&gt;参考文献 排版软件：Word 2000以上版本 </p>
</li>
<li><p>纸型：A4 方向：纵向</p>
</li>
<li>页面设置 : 页边距：上2厘米，下2厘米，左2厘米，右2厘米，页眉1.5厘米，页脚1.75厘米 </li>
<li>文档网格：选中―只指定行网格‖，每页46行，跨度15.6磅，栏数：1，应用于：整篇文档 整篇文档段落设置：</li>
<li>行间距：段前0行，段后0行 5号字单倍行距 </li>
<li>字符间距设置：缩放：100％ 间距：标准 位置：标准 </li>
<li><p>字体和字号：   </p>
<ol>
<li>中文题名：3号宋体，加粗，居中（须简明、具体、确切，以20个字以内为宜，必要时可加副标题）； </li>
<li>英文题目：Times New Roman，4号，居中，所有实词首字母大写</li>
<li>作者姓名：中文5号宋体，中级（含）以上职称作者请注明职称，居中；</li>
<li>英文Times New Roman，5号，姓所有字母大写，名首字母大写，名中间用”-“连接，注明职称</li>
<li>作者单位：中文仿宋体、英文Times New Roman，小5号，不同单位间用空格分隔，要标明二级单位（大学：院系；研究院所：处、室等），所在城市 邮编，英文单位后应注明国籍，居中，多单位在作者右上角标阿拉伯数字区分，一名作者可多单位。</li>
</ol>
</li>
<li>收稿日期：20××-××-××； </li>
<li>修稿日期：20××-××-×× 宋体、Times New Roman小5号</li>
<li>学科分类与代码：620 ××××</li>
<li>中图分类号：X×××</li>
<li>文献标志码：× 宋体、Times New Roman小5号 </li>
<li>基金项目：国家（×××省）自然科学基金资助（×××××××）。宋体、Times New Roman小5号 </li>
<li>资助项目：国家科技××××××××××项目（×××××××）。宋体、Times New Roman小5号</li>
<li>摘要和关键词：中文仿宋体、英文Times New Roman 5号；关键词间用分号分隔；英文关键词首字母小写，关键词5～8个 （1）摘要的要素 摘要内容包括：目的、过程和方法、内容、研究结果及得出的结论，一定要给出具体的方法、数据指标等具体结果和结论。建议格式：为了……,基于/根据……的重要性，探讨/介绍/采用/提出……，研究……，结果表明：……。摘要以300字 左右为宜。</li>
<li><p>大标题：   </p>
<ol>
<li>一级标题：中文黑体，英文、数字Times New Roman字体4号，加粗，靠左顶格 （0，1，2，3 ……） </li>
<li>二级标题：中文黑体，英文、数字Times New Roman字体5号，加粗，靠左顶格（1.1，1.2，1.3 ……）</li>
<li>三级标题：中文准圆体，英文、数字Times New Roman字体小5号，加粗，靠左顶格（1.1.1，1.1.2，1.1.3 ……） </li>
<li>正文部分：中文宋体，英文、数字Times New Roman字体5号</li>
<li>图题、表题：要求中英文对照；中文宋体，英文、数字Times New Roman字体小5号，加粗，居中，图序、表序用表1、图1 图、表中文字，图注与说明、表注与说明用中文宋体，英文、数字Times New Roman字体小5号，量与单位之间用―/‖间隔，图、表中文字说明尽量用中文表示。</li>
</ol>
</li>
<li>参考文献：中文宋体，英文、数字Times New Roman字体小5号（注录格式参见附：参考文献著录内容要求及示例）。中文文献要求附英文翻译。</li>
<li>最后附作者简介，格式为：作者简介，姓名（出生年.月-），性别，籍贯（写到市县），职称，学位，研究方向（从事工作范围等）。E-mail地址，联系电话（只留给编辑联系用）。</li>
</ul>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-react" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/react/">react</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/react/" class="article-date">
  <time datetime="2018-08-20T17:12:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://codepen.io/" target="_blank" rel="noopener">CodePen</a> : CodePen is a social development environment<br>for front-end designers and developers.It’s the best place to build and deploy<br>a website, show off your work, build test cases, and find<br>inspiration.可以看到并修改别人写的前端项目，里面有很酷炫的前端技术。</p>
<h4 id="如何查看react-js所有的历史版本"><a href="#如何查看react-js所有的历史版本" class="headerlink" title="如何查看react.js所有的历史版本"></a>如何查看react.js所有的历史版本</h4><p><a href="https://reactjs.org/blog/all.html/" target="_blank" rel="noopener">react.js官方网站</a></p>
<p><a href="https://cdnjs.com/libraries/react/" target="_blank" rel="noopener">直接引用</a></p>
<p><a href="https://github.com/facebook/react/commits/master" target="_blank" rel="noopener">github的commit</a></p>
<p><a href="http://babeljs.io/learn-es2015/" target="_blank" rel="noopener">ES2015文档</a></p>
<p><a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm</a></p>
<p><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node.js</a></p>
<p>按照react官方网站上面的文档一步步进行：<br>1. 运行一个Hello world在本地文件和本地编译器上</p>
<pre><code> 1 &lt;!DOCTYPE html&gt;
 2 &lt;html&gt;
 3   &lt;head&gt;
 4     &lt;meta charset=&quot;UTF-8&quot; /&gt;
 5     &lt;title&gt;Hello World&lt;/title&gt;
 6     &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;
 7     &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;
 8     &lt;script src=&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&gt;&lt;/script&gt;
 9   &lt;/head&gt;
10   &lt;body&gt;
11     &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
12     &lt;script type=&quot;text/babel&quot;&gt;
13 
14       ReactDOM.render(
15         &lt;h1&gt;Hello, world!&lt;/h1&gt;,
16         document.getElementById(&#39;root&#39;)
17       );
18 
19     &lt;/script&gt;
20   &lt;/body&gt;
21 &lt;/html&gt;
</code></pre><p>我们可以看到，通过script外部JS文件的引入，包括在CodePen上显示的HelloWorld代码，他的主要”引擎”是Javascript，通过其语法将H5的内容展示出来。</p>
<ol>
<li>安装开发环境<br>使用npm、npx来安装环境，只需要通过终端输入几个简单的命令就可以啦~那么npm和npx究竟是什么呢？</li>
</ol>
<p><a href="http://www.jianshu.com/p/cc4ab46eca2f" target="_blank" rel="noopener">npm是什么</a><br><a href="http://blog.csdn.net/whh181/article/details/78363544?readlog" target="_blank" rel="noopener">npx是什么</a><br><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm官网</a></p>
<p>使用npm或者npx在控制台中输入命令即可：<br><img src="http://img.blog.csdn.net/20171201200730614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171201200655031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NDYwNTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><a href="https://www.cnblogs.com/-walker/p/6056529.html" target="_blank" rel="noopener">webpack是什么</a></p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-word2vec" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/word2vec/">word2vec</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/word2vec/" class="article-date">
  <time datetime="2018-08-20T17:10:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://blog.csdn.net/zhaoxinfan/article/details/11069485" target="_blank" rel="noopener">word2vec的学习</a><br>python的几个扩展工具：<br>1. numpy<br>2. scipy<br>3. gensim</p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>如何对新闻的关键词进行聚类？比如说，给你一个关键词”苍井空”，你怎么把”女优”，”写真集”等关联性极高的关键词找到？</p>
<p>想法1： 用新闻ID向量表示某个关键词，如：苍井空 （新闻ID1,新闻ID2,…）</p>
<p>可行性： 新闻数较小时，可以用kmeans等方法进行聚类； 但新闻数高达10万时，每个关键词则需要10万维的向量表示，计算难度太大。</p>
<p>解决方法：google的一个开源工具”word2vec”,可通过输入一个词的集合，计算出词与词之间的距离，通过距离进行聚类。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-流水作业" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/21/流水作业/">流水作业</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/21/流水作业/" class="article-date">
  <time datetime="2018-08-20T17:08:00.000Z" itemprop="datePublished">2018-08-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>王晓东的《计算机算法设计与分析》上这一节我看的云里雾里，数学公式让我眼花缭乱。但是读懂数学公式的推导过程并不是最重要的事情。重要的是解题的思路！</p>
<ul>
<li><p>我读懂了”流水作业”的题目要求，以及最优子结构性质<br><a href="http://www.cnblogs.com/f91og/p/6024706.html" target="_blank" rel="noopener">动态规划——流水作业调度问题</a></p>
</li>
<li><p>这里有流水作业的具体实例，很好地展示了自底向上的动规过程，C++代码<br><a href="http://lib.csdn.net/article/datastructure/9332" target="_blank" rel="noopener">0018算法笔记——【动态规划】流水作业调度问题与Johnson法则</a></p>
</li>
<li><p>Java 代码，注释写的很详细<br><a href="http://blog.csdn.net/qq_33054511/article/details/53813047?locationNum=12&amp;fps=1" target="_blank" rel="noopener">动态规划之流水作业调度Johnson法则</a></p>
</li>
</ul>
<pre><code>  1 #include &lt;iostream&gt;
  2 #include &lt;stdlib.h&gt;
  3 using namespace std;
  4 // 动态规划 流水作业调度问题
  5 
  6 class Jobtype
  7 {
  8     public:
  9         int operator &lt;=(Jobtype a) const
 10         {
 11             return(key&lt;=a.key);
 12         }
 13         int key,index;
 14         bool job;
 15 };
 16 
 17 /*
 18 定义作业Jobtype类：
 19 key : 关键字
 20 index ：索引值
 21 bool job : a[i]&lt;=b[i]的归入N1类，job值为1 ； 否则为0
 22 重新定义运算符 &lt;=
 23 */
 24 
 25 int FlowShop(int n,int a[],int b[],int c[]);
 26 void BubbleSort(Jobtype *d,int n);
 27 
 28 int FlowShop(int n,int a[],int b[],int c[])
 29 {
 30     Jobtype *d = new Jobtype[n];
 31     for(int i=0; i&lt;n; i++)
 32     {
 33         d[i].key = a[i]&gt;b[i]?b[i]:a[i];//按Johnson法则分别取对应的b[i]或a[i]值作为关键字
 34         d[i].job = a[i]&lt;=b[i];//给符合条件a[i]&lt;b[i]的放入到N1子集标记为true
 35         d[i].index = i;
 36     }
 37 
 38     BubbleSort(d,n);//对数组d按关键字升序进行排序
 39 
 40     int j = 0,k = n-1;
 41 
 42     for(int i=0; i&lt;n; i++)
 43     {
 44         if(d[i].job)
 45         {
 46             c[j++] = d[i].index;//将排过序的数组d，取其中作业序号属于N1的从前面进入
 47         }
 48         else
 49         {
 50             c[k--] = d[i].index;//属于N2的从后面进入，从而实现N1的非减序排序，N2的非增序排序
 51         }
 52     }
 53 
 54     j = a[c[0]];
 55     k = j+b[c[0]];
 56     for(int i=1; i&lt;n; i++)
 57     {
 58         j += a[c[i]];//M1在执行c[i]作业的同时，M2在执行c[i-1]号作业，最短执行时间取决于M1与M2谁后执行完
 59         k = j&lt;k?k+b[c[i]]:j+b[c[i]];//计算最优加工时间
 60     }
 61 
 62     delete d;
 63     return k;
 64 }
 65 
 66 //冒泡排序
 67 void BubbleSort(Jobtype *d,int n)
 68 {
 69     int i,j,flag;
 70     Jobtype temp;
 71 
 72     for(i=0;i&lt;n;i++){
 73         flag = 0;
 74         for(j=n-1;j&gt;i;j--){
 75             //如果前一个数大于后一个数，则交换
 76             if(d[j]&lt;=d[j-1]){
 77                 temp = d[j];
 78                 d[j] = d[j-1];
 79                 d[j-1] = temp;
 80                 flag = 1;
 81             }
 82         }
 83         //如果本次排序没有进行一次交换，则break，减少了执行之间。
 84         if(flag == 0){
 85             break;
 86         }
 87     }
 88 }
 89 int main()
 90 {
 91     int N; // 作业个数
 92     cout&lt;&lt;&quot;请输入作业总个数n：&quot;&lt;&lt;endl;
 93     cin&gt;&gt;N;
 94     int a[N],b[N],c[N];
 95     cout&lt;&lt;&quot;请输入machine1的作业运行时间：&quot;&lt;&lt;endl;
 96     for (int i=0 ; i&lt;N ;i++)
 97     {
 98         cin &gt;&gt; a[i];
 99     }
100     cout&lt;&lt;&quot;请输入machine2的作业运行时间：&quot;&lt;&lt;endl;
101     for (int i=0 ; i&lt;N ;i++)
102     {
103         cin &gt;&gt; b[i];
104     }
105     int minTime=FlowShop(N,a,b,c);
106     /*
107     a[N]:machine1的作业运行时间序列
108     b[N]:machine2的作业运行时间序列
109     c[N]:N个作业的调度顺序（编号从0开始）
110     */
111     cout&lt;&lt;&quot;初始作业在机器1上的运行时间序列为：&quot;&lt;&lt;endl;
112     for(int i=0; i&lt;N; i++)
113     {
114         cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
115     }
116     cout&lt;&lt;endl;
117 
118     cout&lt;&lt;&quot;初始作业在机器2上的运行时间序列为：&quot;&lt;&lt;endl;
119     for(int i=0; i&lt;N; i++)
120     {
121         cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;
122     }
123     cout&lt;&lt;endl;
124 
125     cout&lt;&lt;&quot;完成作业的最短时间为：&quot;&lt;&lt;minTime&lt;&lt;endl;
126     cout&lt;&lt;&quot;编号从0开始，作业调度的顺序为：&quot;&lt;&lt;endl;
127     for(int i=0; i&lt;N; i++)
128     {
129         cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;
130     }
131     cout&lt;&lt;endl;
132     return 0;
133 }
</code></pre>
      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 John Doe 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>